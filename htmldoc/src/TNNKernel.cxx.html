<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:03:07 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TNNKernel - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//////////////////////////////////////////////////////////////////////////</b>
<b>//									//</b>
<b>// <a href=".././TNNK.html">TNNK</a>									//</b>
<b>//									//</b>
<b>// Interface to J.P Ernenwein's neural network kernel <a href=".././TNNKernel.html">TNNKernel</a>		//</b>
<b>// Part of the Neural Network Objects package (NNO)			//</b>
<b>//									//</b>
<b>// Author List:								//</b>
<b>// M.Kunze, Bochum University						//</b>
<b>// (C) Copyright 2001, Ruhr-University Bochum.				//</b>
<b>//									//</b>
<b>//////////////////////////////////////////////////////////////////////////</b>

#include "RhoNNO/TNNK.h"
#include "RhoNNO/VNeuralNetPlotter.h"

ClassImp(TNNK)

#include &lt;iostream&gt;
using namespace std;

void TNNK::AllocNet(void)
{}

void TNNK::InitNet(void)
{}

void TNNK::WriteText(void)
{
    if (fFile!=0) fclose(fFile);
    fKernel-&gt;Export((char*)fFilename.Data());
}

void TNNK::WriteBinary(void)
{}

void TNNK::ReadText(void)
{
    if (fFile!=0) fclose(fFile);
    fKernel-&gt;Import((char*)fFilename.Data());
}

void TNNK::ReadBinary(void)
{}

TNNK::TNNK(Double_t learn,Double_t fse,Double_t mu,Int_t innodes,Text_t *hidnodes,Int_t outnodes,const char* netFile)
: VSupervisedNet("TNNK",innodes,outnodes,netFile) 
{
    fShouldSave = kTRUE;
    Text_t *name = "TNNK";
    fKernel = new TNNKernel(name,innodes,hidnodes,outnodes);
    fKernel-&gt;SetLearnParam(learn,fse,mu);
    fKernel-&gt;SetArraySize(1);
    fKernel-&gt;SetInitParam(-2.,2.);
    fKernel-&gt;SetUseBiases();
    fKernel-&gt;Init();
    fKernel-&gt;PrintS();
}

TNNK::TNNK(const char* netFile)
: VSupervisedNet("TNNK",5,10,netFile)
{
    fShouldSave = kFALSE;
    fKernel = new TNNKernel();
    ReadText();
}

TNNK::~TNNK()
{
    if (fShouldSave) WriteText();
    delete fKernel;
}

Double_t TNNK::Train(NNO_INTYPE* in,NNO_OUTTYPE* out)
{
    int i;

    for (i=0;i&lt;fParm.fOutNodes;i++) {
	fKernel-&gt;SetTeach(out[i],i);
    }

    for (i=0;i&lt;fParm.fInNodes;i++) {
	fKernel-&gt;SetInput(in[i],i);
    }

    fKernel-&gt;Forward();
    Double_t error = fKernel-&gt;Error();
    fKernel-&gt;LearnBackward();

<b>    // Copy over to base class</b>
    for (i=0;i&lt;fParm.fOutNodes;i++) {
	fOut[i] = fKernel-&gt;<a href="#TNNKernel:GetOutput">GetOutput</a>(i);
    }

    if (fPlotter) {
	fPlotter-&gt;AddTrainSample(out[0],out[0]&gt;fParm.fThreshold);
    }

    return error;
}

<a href="../ListOfTypes.html#Double_t">Double_t</a>* <a href=".././TNNK.html#TNNK:Recall">TNNK::Recall</a>(<a href="../ListOfTypes.html#NNO_INTYPE">NNO_INTYPE</a>* in,<a href="../ListOfTypes.html#NNO_OUTTYPE">NNO_OUTTYPE</a>* out)
{
    <a href="../ListOfTypes.html#int">int</a> i;

    for (i=0;i&lt;fParm.fOutNodes;i++) {
	fKernel-&gt;<a href="#TNNKernel:SetTeach">SetTeach</a>(out[i],i);
    }

    for (i=0;i&lt;fParm.fInNodes;i++) {
	fKernel-&gt;<a href="#TNNKernel:SetInput">SetInput</a>(in[i],i);
    }

    fKernel-&gt;<a href="#TNNKernel:GoThrough">GoThrough</a>();
    <a href="../ListOfTypes.html#Double_t">Double_t</a> error = fKernel-&gt;<a href="#TNNKernel:Error">Error</a>();

<b>    // Copy over to base class</b>
    for (i=0;i&lt;fParm.fOutNodes;i++) {
	fOut[i] = fKernel-&gt;<a href="#TNNKernel:GetOutput">GetOutput</a>(i);
    }

    if (fPlotter) {
	<a href="../ListOfTypes.html#Bool_t">Bool_t</a> good = kTRUE;
	if (out!=0) good = out[0]&gt;fParm.fThreshold;
	fPlotter-&gt;AddTestSample(fKernel-&gt;<a href="#TNNKernel:GetOutput">GetOutput</a>(),good);
    }

    return fOut;
}

<b>//////////////////////////////////////////////////////////////////</b>
<b>//</b>
<b>//  <a href=".././TNNKernel.html">TNNKernel</a> </b>
<b>//  Feed-Forward Neural Network </b>
<b>//</b>
<b>//////////////////////////////////////////////////////////////////</b>

#include "TDatime.h"

ClassImp(TNNKernel)

<a name="TNNKernel:TNNKernel"> </a>TNNKernel::TNNKernel(Text_t *name, Int_t nInput, Text_t *hidden, Int_t nOutput):TNamed(name,"Neural Network"),
 fW(0), fNUnits(0), fArrayIn(0), fArrayOut(0), fEventsList(0), fValues(0), fTeach(0)
{
<b>    // constructor</b>
    <a href="#TNNKernel:AllocateVW">AllocateVW</a>(nInput,hidden,nOutput);
    
    <a href=".././TNNKernel.html#TNNKernel:fUseBiases">fUseBiases</a>=1.;
    <a href=".././TNNKernel.html#TNNKernel:fLearnParam">fLearnParam</a>=0.2;
    <a href=".././TNNKernel.html#TNNKernel:fFlatSE">fFlatSE</a>=0.;
    <a href=".././TNNKernel.html#TNNKernel:fMu">fMu</a>=0.;
    <a href=".././TNNKernel.html#TNNKernel:fLowerInitWeight">fLowerInitWeight</a>=-1.;
    <a href=".././TNNKernel.html#TNNKernel:fUpperInitWeight">fUpperInitWeight</a>=1.;
    
    <a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>=0;
    
    <a href=".././TNNKernel.html#TNNKernel:fNTrainCycles">fNTrainCycles</a>=0;
    
    TDatime temps;
    <a href=".././TNNKernel.html#TNNKernel:fRandom">fRandom</a>.SetSeed(temps.Convert());
    printf("First Random Seed = %in",<a href=".././TNNKernel.html#TNNKernel:fRandom">fRandom</a>.GetSeed());
    printf("Neural Network is created : n");
<b>    //  <a href="#TNNKernel:PrintS">PrintS</a>();</b>
    
}

<a name="TNNKernel:TNNKernel"> </a><a href=".././TNNKernel.html#TNNKernel:TNNKernel">TNNKernel::TNNKernel</a>() : <a href=".././TNNKernel.html#TNNKernel:fW">fW</a>(0), <a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>(0), <a href=".././TNNKernel.html#TNNKernel:fArrayIn">fArrayIn</a>(0), <a href=".././TNNKernel.html#TNNKernel:fArrayOut">fArrayOut</a>(0), 
                         <a href=".././TNNKernel.html#TNNKernel:fEventsList">fEventsList</a>(0), <a href=".././TNNKernel.html#TNNKernel:fValues">fValues</a>(0), <a href=".././TNNKernel.html#TNNKernel:fTeach">fTeach</a>(0)
{
<b>    // constructor witn no parameter </b>
    <a href=".././TNNKernel.html#TNNKernel:fUseBiases">fUseBiases</a>=1.;
    <a href=".././TNNKernel.html#TNNKernel:fLearnParam">fLearnParam</a>=0.2;
    <a href=".././TNNKernel.html#TNNKernel:fFlatSE">fFlatSE</a>=0.;
    <a href=".././TNNKernel.html#TNNKernel:fMu">fMu</a>=0.;
    <a href=".././TNNKernel.html#TNNKernel:fLowerInitWeight">fLowerInitWeight</a>=-1.;
    <a href=".././TNNKernel.html#TNNKernel:fUpperInitWeight">fUpperInitWeight</a>=1.;
    <a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>=0;
    
    <a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>=0;
    
    <a href=".././TNNKernel.html#TNNKernel:fNTrainCycles">fNTrainCycles</a>=0;
    
    TDatime temps;
    <a href=".././TNNKernel.html#TNNKernel:fRandom">fRandom</a>.SetSeed(temps.Convert());
    printf("First Random Seed = %in",<a href=".././TNNKernel.html#TNNKernel:fRandom">fRandom</a>.GetSeed());
}


<a name="TNNKernel:~TNNKernel"> </a><a href=".././TNNKernel.html">TNNKernel</a>::~<a href=".././TNNKernel.html">TNNKernel</a>() 
{
<b>    // destructor  </b>
    
    <a href="#TNNKernel:DeleteArray">DeleteArray</a>();
    <a href="#TNNKernel:FreeVW">FreeVW</a>();
    if(<a href=".././TNNKernel.html#TNNKernel:fEventsList">fEventsList</a>) delete [] <a href=".././TNNKernel.html#TNNKernel:fEventsList">fEventsList</a>;
}  


<a name="TNNKernel:SetHidden"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:SetHidden">TNNKernel::SetHidden</a>(<a href="../ListOfTypes.html#Text_t">Text_t</a> *ttext)
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> i,j;
    <a href="../ListOfTypes.html#Text_t">Text_t</a> text[100];
    strcpy(text,ttext);
    
    <a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>=1;
    for (i=0;text[i];i++)if(text[i]==':')<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>++;
    if (<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>) delete [] <a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>;
    <a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a> = new <a href="../ListOfTypes.html#Int_t">Int_t</a>[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2];
    
    j=0;
    for (i=1;i&lt;=<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>;i++)
    {
	TString number;
	while(text[j]&amp;&amp;(text[j]!=':')){number.Append(text[j]);j++;}
	j++;
	sscanf(number.Data(),"%i",&amp;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i]);  
	printf("%i n",<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i]); 
    }
    
}


<a name="TNNKernel:FreeVW"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:FreeVW">TNNKernel::FreeVW</a>()
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> i,l;
    
<b>    // free of values</b>
    
    if (<a href=".././TNNKernel.html#TNNKernel:fValues">fValues</a>)
    {
	for (i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2;i++)
	{delete [] <a href=".././TNNKernel.html#TNNKernel:fValues">fValues</a>[i]; delete [] <a href=".././TNNKernel.html#TNNKernel:fErrors">fErrors</a>[i]; delete [] <a href=".././TNNKernel.html#TNNKernel:fBiases">fBiases</a>[i];delete [] <a href=".././TNNKernel.html#TNNKernel:fDB">fDB</a>[i];} 
	delete [] <a href=".././TNNKernel.html#TNNKernel:fValues">fValues</a>; delete [] <a href=".././TNNKernel.html#TNNKernel:fErrors">fErrors</a>; delete [] <a href=".././TNNKernel.html#TNNKernel:fBiases">fBiases</a>;delete [] <a href=".././TNNKernel.html#TNNKernel:fDB">fDB</a>;
	<a href=".././TNNKernel.html#TNNKernel:fValues">fValues</a>=0;
    }
    
<b>    // free of teaching</b>
    
    if (<a href=".././TNNKernel.html#TNNKernel:fTeach">fTeach</a>) 
    {
	delete [] <a href=".././TNNKernel.html#TNNKernel:fTeach">fTeach</a>;
	<a href=".././TNNKernel.html#TNNKernel:fTeach">fTeach</a>=0;
    }
    
<b>    // free of weights</b>
    
    if (<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>)
    {
	for (i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1;i++)
	{
	    for(l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++){delete [] <a href=".././TNNKernel.html#TNNKernel:fW">fW</a>[i][l];delete [] <a href=".././TNNKernel.html#TNNKernel:fDW">fDW</a>[i][l];}  
	    delete [] <a href=".././TNNKernel.html#TNNKernel:fW">fW</a>[i];delete [] <a href=".././TNNKernel.html#TNNKernel:fDW">fDW</a>[i];
	}    
	<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>=0;
    }
    
<b>    // free of units</b>
    
    if (<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>){ delete [] <a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>; <a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>=0;}
}

<a name="TNNKernel:AllocateVW"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:AllocateVW">TNNKernel::AllocateVW</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> nInput, <a href="../ListOfTypes.html#Text_t">Text_t</a> *hidden, <a href="../ListOfTypes.html#Int_t">Int_t</a> nOutput)
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> i,l;
    
    if(<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>){printf("free memory first !n");return;}
    
    <a href="#TNNKernel:SetHidden">SetHidden</a>(hidden);
    <a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[0]=nInput;
    <a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1]=nOutput;
    
<b>    // allocation of values</b>
    
    <a href=".././TNNKernel.html#TNNKernel:fValues">fValues</a> = new <a href="../ListOfTypes.html#Float_t">Float_t</a>*[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2];
    <a href=".././TNNKernel.html#TNNKernel:fErrors">fErrors</a> = new <a href="../ListOfTypes.html#Double_t">Double_t</a>*[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2];
    <a href=".././TNNKernel.html#TNNKernel:fBiases">fBiases</a> = new <a href="../ListOfTypes.html#Double_t">Double_t</a>*[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2];
    <a href=".././TNNKernel.html#TNNKernel:fDB">fDB</a> = new <a href="../ListOfTypes.html#Double_t">Double_t</a>*[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2];
    
    for (i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2;i++)
    {
	<a href=".././TNNKernel.html#TNNKernel:fValues">fValues</a>[i]=new <a href="../ListOfTypes.html#Float_t">Float_t</a>[<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i]]; 
	<a href=".././TNNKernel.html#TNNKernel:fErrors">fErrors</a>[i]=new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i]]; 
	<a href=".././TNNKernel.html#TNNKernel:fBiases">fBiases</a>[i]=new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i]]; 
	<a href=".././TNNKernel.html#TNNKernel:fDB">fDB</a>[i]=new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i]]; 
	for (<a href="../ListOfTypes.html#int">int</a> j=0;j&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];j++) {
	    <a href=".././TNNKernel.html#TNNKernel:fValues">fValues</a>[i][j] = 0.0;
	    <a href=".././TNNKernel.html#TNNKernel:fErrors">fErrors</a>[i][j] = 0.0;
	    <a href=".././TNNKernel.html#TNNKernel:fBiases">fBiases</a>[i][j] = 0.0;
	    <a href=".././TNNKernel.html#TNNKernel:fDB">fDB</a>[i][j] = 0.0;
	}
    }
    
<b>    // allocation of teaching</b>
    
    <a href=".././TNNKernel.html#TNNKernel:fTeach">fTeach</a>=new <a href="../ListOfTypes.html#Float_t">Float_t</a>[<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1]]; 
    
<b>    // allocation of weights</b>
    
    <a href=".././TNNKernel.html#TNNKernel:fW">fW</a>=new <a href="../ListOfTypes.html#Double_t">Double_t</a>**[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1];
    <a href=".././TNNKernel.html#TNNKernel:fDW">fDW</a>=new <a href="../ListOfTypes.html#Double_t">Double_t</a>**[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1];
    
    for (i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1;i++)
    {
	<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>[i]=new <a href="../ListOfTypes.html#Double_t">Double_t</a>*[<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i]];
	<a href=".././TNNKernel.html#TNNKernel:fDW">fDW</a>[i]=new <a href="../ListOfTypes.html#Double_t">Double_t</a>*[<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i]];
	for (l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++)
	{
	    <a href=".././TNNKernel.html#TNNKernel:fW">fW</a>[i][l]=new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i+1]];  
	    <a href=".././TNNKernel.html#TNNKernel:fDW">fDW</a>[i][l]=new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i+1]]; 
	}
    }
    
}

<a name="TNNKernel:SetKernel"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:SetKernel">TNNKernel::SetKernel</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> nInput, <a href="../ListOfTypes.html#Text_t">Text_t</a> *hidden, <a href="../ListOfTypes.html#Int_t">Int_t</a> nOutput)
{  
    <a href="#TNNKernel:FreeVW">FreeVW</a>();
    <a href="#TNNKernel:AllocateVW">AllocateVW</a>(nInput,hidden,nOutput);
}

<a name="TNNKernel:SetLearnParam"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:SetLearnParam">TNNKernel::SetLearnParam</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> learnParam,<a href="../ListOfTypes.html#Double_t">Double_t</a> fse,<a href="../ListOfTypes.html#Double_t">Double_t</a> mu)
{
<b>    // Sets the learning parameters :</b>
<b>    // the main learning parameter is around 0.2 (in ]0,1])</b>
<b>    // fse is for flat spot elimination, with values in [0,0.25], often 0.1</b>
<b>    // mu is for backprop momentum, values in [0,1]</b>
    <a href=".././TNNKernel.html#TNNKernel:fLearnParam">fLearnParam</a>=TMath::Abs(learnParam);
    <a href=".././TNNKernel.html#TNNKernel:fFlatSE">fFlatSE</a>=TMath::Abs(fse);
    <a href=".././TNNKernel.html#TNNKernel:fMu">fMu</a>=TMath::Abs(mu);
    
    if (<a href=".././TNNKernel.html#TNNKernel:fLearnParam">fLearnParam</a>&gt;1.0) printf("Warning : %6.2f is not an usual valuen",<a href=".././TNNKernel.html#TNNKernel:fLearnParam">fLearnParam</a>);
    if (<a href=".././TNNKernel.html#TNNKernel:fLearnParam">fLearnParam</a>==0.0) printf("Warning : 0 is a stupid valuen");
    printf("Learning Parameter set to : %6.2fn",<a href=".././TNNKernel.html#TNNKernel:fLearnParam">fLearnParam</a>);
    printf("Flat Spot elimination value  set to : %6.2fn",<a href=".././TNNKernel.html#TNNKernel:fFlatSE">fFlatSE</a>);
    printf("Momentum set to : %6.2fn",<a href=".././TNNKernel.html#TNNKernel:fMu">fMu</a>);
}

<a name="TNNKernel:SetInitParam"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:SetInitParam">TNNKernel::SetInitParam</a>(<a href="../ListOfTypes.html#Float_t">Float_t</a> lowerInitWeight, <a href="../ListOfTypes.html#Float_t">Float_t</a> upperInitWeight)
{
<b>    // Sets the initialisation parameters : max and min weights </b>
    <a href="../ListOfTypes.html#Float_t">Float_t</a> temp;
    
    <a href=".././TNNKernel.html#TNNKernel:fLowerInitWeight">fLowerInitWeight</a>=lowerInitWeight;
    <a href=".././TNNKernel.html#TNNKernel:fUpperInitWeight">fUpperInitWeight</a>=upperInitWeight;
    if (<a href=".././TNNKernel.html#TNNKernel:fLowerInitWeight">fLowerInitWeight</a>&gt;<a href=".././TNNKernel.html#TNNKernel:fUpperInitWeight">fUpperInitWeight</a>)
    {
	temp=<a href=".././TNNKernel.html#TNNKernel:fUpperInitWeight">fUpperInitWeight</a>;
	<a href=".././TNNKernel.html#TNNKernel:fUpperInitWeight">fUpperInitWeight</a>=<a href=".././TNNKernel.html#TNNKernel:fLowerInitWeight">fLowerInitWeight</a>;
	<a href=".././TNNKernel.html#TNNKernel:fLowerInitWeight">fLowerInitWeight</a>=temp;
    } 
    if (<a href=".././TNNKernel.html#TNNKernel:fLowerInitWeight">fLowerInitWeight</a>==<a href=".././TNNKernel.html#TNNKernel:fUpperInitWeight">fUpperInitWeight</a>)printf("Warning : the weights initialisation bounds are equal !n");
    printf("Init Parameters set to :n");
    printf(" --&gt; Lower bound = %6.2fn",<a href=".././TNNKernel.html#TNNKernel:fLowerInitWeight">fLowerInitWeight</a>);
    printf(" --&gt; Upper bound = %6.2fn",<a href=".././TNNKernel.html#TNNKernel:fUpperInitWeight">fUpperInitWeight</a>);
    
}


<a name="TNNKernel:Alea"> </a><a href="../ListOfTypes.html#Float_t">Float_t</a> <a href=".././TNNKernel.html#TNNKernel:Alea">TNNKernel::Alea</a>()
{
    return (<a href="../ListOfTypes.html#Float_t">Float_t</a>) <a href=".././TNNKernel.html#TNNKernel:fLowerInitWeight">fLowerInitWeight</a>+<a href=".././TNNKernel.html#TNNKernel:fRandom">fRandom</a>.Rndm()*(<a href=".././TNNKernel.html#TNNKernel:fUpperInitWeight">fUpperInitWeight</a>-<a href=".././TNNKernel.html#TNNKernel:fLowerInitWeight">fLowerInitWeight</a>);
}

<a name="TNNKernel:Init"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:Init">TNNKernel::Init</a>()
{
<b>    // initialisation of  biases and weights.  </b>
<b>    // the init parameters can be changed by :</b>
<b>    // <a href="#TNNKernel:SetInitParam">SetInitParam</a>(<a href="../ListOfTypes.html#Float_t">Float_t</a> lowerInitWeight, <a href="../ListOfTypes.html#Float_t">Float_t</a> upperInitWeight)</b>
<b>    // The default is -1 and 1</b>
    
    <a href="../ListOfTypes.html#Int_t">Int_t</a> i,l,c;
    
    if(!<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>){printf("allocate memory first !n");return;}
    
<b>    // init of weights</b>
    
    for (i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1;i++)
	for (l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++)
	    for (c=0;c&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i+1];c++) <a href=".././TNNKernel.html#TNNKernel:fW">fW</a>[i][l][c]=(<a href="../ListOfTypes.html#Double_t">Double_t</a>)<a href="#TNNKernel:Alea">Alea</a>();
	    
    for(i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1;i++)for(l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++)for(c=0;c&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i+1];c++)
	<a href=".././TNNKernel.html#TNNKernel:fDW">fDW</a>[i][l][c]=0.;       
    
<b>    // init of biases</b>
    
    for (i=1;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2;i++)
	for (l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++) <a href=".././TNNKernel.html#TNNKernel:fBiases">fBiases</a>[i][l]=(<a href="../ListOfTypes.html#Double_t">Double_t</a>)(<a href="#TNNKernel:Alea">Alea</a>())*<a href=".././TNNKernel.html#TNNKernel:fUseBiases">fUseBiases</a>;
	
    for(i=1;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2;i++)for(l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++)<a href=".././TNNKernel.html#TNNKernel:fDB">fDB</a>[i][l]=0.;
    
    
    <a href=".././TNNKernel.html#TNNKernel:fNTrainCycles">fNTrainCycles</a>=0;
    printf("Initialisation donen");
}

<a name="TNNKernel:PrintS"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:PrintS">TNNKernel::PrintS</a>()
{
<b>    // prints structure of network on screen</b>
    <a href="../ListOfTypes.html#Int_t">Int_t</a> i,l,c;
    
    if(!<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>){printf("no unit !n");return;} 
    
    printf("+++++++++ Neural Network %s ++++++++++++n",GetName());
    for(i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2;i++)printf("Layer %1i contains %2i unitsn",i,<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i]);
    
    if(<a href=".././TNNKernel.html#TNNKernel:fUseBiases">fUseBiases</a>)printf("&gt;&gt;&gt;&gt;&gt;&gt;&gt; Biases USED");else printf("&gt;&gt;&gt;&gt;&gt;&gt;&gt;Biases DUMMY");
    
    printf("n ----------   Biases   ---------- n");
    <a href="../ListOfTypes.html#Int_t">Int_t</a> maxl=0;
    for(i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2;i++)if(<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i]&gt;=maxl)maxl=<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];
    for(i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2;i++)printf("    %1i   | ",i);printf("n");
    for(i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2;i++)printf("--------|-");printf("n");
    for(l=0;l&lt;maxl;l++)
    {
	for(i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2;i++)
	    if(l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i])printf("%6.2f  | ",<a href=".././TNNKernel.html#TNNKernel:fBiases">fBiases</a>[i][l]);else printf("        | ");
	    printf("n");
    }
    
    
    printf("n    ----------   Weights ----------- n");
    for(i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1;i++)
    {
	printf(" From  %1i  to  %1i  : n",i,i+1);
	printf("%2i |",i);for(l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++)printf("  %3i |",l);printf("n");
	printf("===|");for(l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++)printf("-------");printf("n");
	printf("%2i |",i+1);for(l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++)printf("-------");printf("n");
	for(c=0;c&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i+1];c++)
	{ 
	    printf("%2i |",c);
	    for(l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++)printf("%6.2f|",<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>[i][l][c]);
	    printf("n");
	}     
	printf("n");
    }  
    
    printf("n");
    printf("Learning parameter = %6.2fn",<a href=".././TNNKernel.html#TNNKernel:fLearnParam">fLearnParam</a>);
    printf("Flat Spot elimination value = %6.2fn",<a href=".././TNNKernel.html#TNNKernel:fFlatSE">fFlatSE</a>);
    printf("Momentum = %6.2fn",<a href=".././TNNKernel.html#TNNKernel:fMu">fMu</a>);
    printf("Lower initialisation weight = %6.2fn",<a href=".././TNNKernel.html#TNNKernel:fLowerInitWeight">fLowerInitWeight</a>);
    printf("Upper initialisation weight = %6.2fn",<a href=".././TNNKernel.html#TNNKernel:fUpperInitWeight">fUpperInitWeight</a>);
    printf("Number of events for training   = %5in",<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>);
    printf("Number of events for validation = %5in",<a href=".././TNNKernel.html#TNNKernel:fNValidEvents">fNValidEvents</a>);
    printf("Number of cycles done = %3in",<a href=".././TNNKernel.html#TNNKernel:fNTrainCycles">fNTrainCycles</a>);
    printf("+++++++++++++++++++++++++++++++++++++++++++++++n");
    
}

<a name="TNNKernel:Forward"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:Forward">TNNKernel::Forward</a>()
{
<b>    // general function to propagate the input activation </b>
<b>    //  The input activation array must be filled  </b>
    <a href="../ListOfTypes.html#Int_t">Int_t</a> i,l,c;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> sum;
    
    if(!<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>){printf("no unit !n");return;}  
    
    for (i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1;i++)  
	for (c=0;c&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i+1];c++)
	{
	    sum=0.; 
	    for(l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++)sum+=<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>[i][l][c]*(<a href="../ListOfTypes.html#Double_t">Double_t</a>)<a href=".././TNNKernel.html#TNNKernel:fValues">fValues</a>[i][l];
	    <a href=".././TNNKernel.html#TNNKernel:fValues">fValues</a>[i+1][c]=(<a href="../ListOfTypes.html#Float_t">Float_t</a>)<a href="#TNNKernel:Sigmoide">Sigmoide</a>(sum+<a href=".././TNNKernel.html#TNNKernel:fBiases">fBiases</a>[i+1][c]*<a href=".././TNNKernel.html#TNNKernel:fUseBiases">fUseBiases</a>);
	}
}

<a name="TNNKernel:LearnBackward"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:LearnBackward">TNNKernel::LearnBackward</a>()
{
<b>    // gradient retropropagation (updates of biases and weights)  </b>
    
    if(<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>&lt;1){printf("No event to train !!!n");return;}
    if(!<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>){printf("no unit !n");return;}
    
    <a href="../ListOfTypes.html#Int_t">Int_t</a> i,l,c;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> delta;
    
<b>    // weights</b>
    
    for (i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1;i++)  
	for (l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++)
	    for(c=0;c&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i+1];c++)
	    {
		delta=<a href=".././TNNKernel.html#TNNKernel:fLearnParam">fLearnParam</a>*<a href=".././TNNKernel.html#TNNKernel:fErrors">fErrors</a>[i+1][c]*(<a href="../ListOfTypes.html#Double_t">Double_t</a>)<a href=".././TNNKernel.html#TNNKernel:fValues">fValues</a>[i][l]+<a href=".././TNNKernel.html#TNNKernel:fMu">fMu</a>*<a href=".././TNNKernel.html#TNNKernel:fDW">fDW</a>[i][l][c];
		<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>[i][l][c]+=delta;
		<a href=".././TNNKernel.html#TNNKernel:fDW">fDW</a>[i][l][c]=delta;
	    }

<b>    // biases</b>
    if(((<a href="../ListOfTypes.html#Bool_t">Bool_t</a>)<a href=".././TNNKernel.html#TNNKernel:fUseBiases">fUseBiases</a>))
    {
	for (i=1;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2;i++)  
	    for (l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++)
	    {
		delta=<a href=".././TNNKernel.html#TNNKernel:fLearnParam">fLearnParam</a>*<a href=".././TNNKernel.html#TNNKernel:fErrors">fErrors</a>[i][l]+<a href=".././TNNKernel.html#TNNKernel:fMu">fMu</a>*<a href=".././TNNKernel.html#TNNKernel:fDB">fDB</a>[i][l];
		<a href=".././TNNKernel.html#TNNKernel:fBiases">fBiases</a>[i][l]+=delta;
		<a href=".././TNNKernel.html#TNNKernel:fDB">fDB</a>[i][l]=delta;
	    }
    }
}

<a name="TNNKernel:Error"> </a><a href="../ListOfTypes.html#Double_t">Double_t</a> <a href=".././TNNKernel.html#TNNKernel:Error">TNNKernel::Error</a>()
{
<b>    // function to compute the errors between forward propagation and teaching.  </b>
<b>    // this error is = |teaching-computed| summed on NN outputs and divided by their number.  </b>
    <a href="../ListOfTypes.html#Int_t">Int_t</a> i,l,c;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> sum,error=0,errorOneUnit;
    if(!<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>){printf("no unit !n");return 0;}    
    
<b>    //  Error on Output Units</b>
    
    for(l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1];l++)
    {
	errorOneUnit=(<a href="../ListOfTypes.html#Double_t">Double_t</a>)(<a href=".././TNNKernel.html#TNNKernel:fTeach">fTeach</a>[l]-<a href=".././TNNKernel.html#TNNKernel:fValues">fValues</a>[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1][l]);
	error+=TMath::Abs(errorOneUnit);
	<a href=".././TNNKernel.html#TNNKernel:fErrors">fErrors</a>[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1][l]=errorOneUnit*(<a href="#TNNKernel:SigPrim">SigPrim</a>(<a href=".././TNNKernel.html#TNNKernel:fValues">fValues</a>[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1][l])+<a href=".././TNNKernel.html#TNNKernel:fFlatSE">fFlatSE</a>);
    }
    error=error/(<a href="../ListOfTypes.html#Double_t">Double_t</a>)<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1];
    
<b>    //  Error on Hidden Units</b>
    
    for(i=<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>;i==1;i--)
    {  
	for(l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++)
	{
	    sum=0.;
	    for(c=0;c&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i+1];c++) sum+=<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>[i][l][c]*<a href=".././TNNKernel.html#TNNKernel:fErrors">fErrors</a>[i+1][c];
	    <a href=".././TNNKernel.html#TNNKernel:fErrors">fErrors</a>[i][l]=sum*(<a href="#TNNKernel:SigPrim">SigPrim</a>((<a href="../ListOfTypes.html#Double_t">Double_t</a>)<a href=".././TNNKernel.html#TNNKernel:fValues">fValues</a>[i][l])+<a href=".././TNNKernel.html#TNNKernel:fFlatSE">fFlatSE</a>);
	}  
    }
    
    return error;
}

<a name="TNNKernel:ErrorO"> </a><a href="../ListOfTypes.html#Double_t">Double_t</a> <a href=".././TNNKernel.html#TNNKernel:ErrorO">TNNKernel::ErrorO</a>()
{
<b>    // function to compute the errors between forward propagation and teaching.  </b>
<b>    // this error is = |teaching-computed| summed on NN outputs and divided by their number.  </b>
<b>    //  Error on Output Units</b>
    
    <a href="../ListOfTypes.html#Int_t">Int_t</a> l;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> error=0;
    if(!<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>){printf("no unit !n");return 0;}    
    for(l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1];l++)
	error+=TMath::Abs((<a href="../ListOfTypes.html#Double_t">Double_t</a>)(<a href=".././TNNKernel.html#TNNKernel:fTeach">fTeach</a>[l]-<a href=".././TNNKernel.html#TNNKernel:fValues">fValues</a>[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1][l]));
    
    error=error/(<a href="../ListOfTypes.html#Double_t">Double_t</a>)<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1];  
    
    return error;
    
}  

<a name="TNNKernel:TrainOneCycle"> </a><a href="../ListOfTypes.html#Double_t">Double_t</a> <a href=".././TNNKernel.html#TNNKernel:TrainOneCycle">TNNKernel::TrainOneCycle</a>()
{
<b>    // one loop on internal events = one cycle.  </b>
<b>    // takes each event from internal array in an order fixed by an array ( <a href=".././TNNKernel.html#TNNKernel:fEventsList">fEventsList</a> ).</b>
<b>    // It is necessary to call the method <a href="#TNNKernel:Mix">Mix</a>() before each call to this function</b>
<b>    // in order to change the presentation order.</b>
<b>    // The learning is done by this function.</b>
<b>    // The private variable  <a href=".././TNNKernel.html#TNNKernel:fNTrainCycles">fNTrainCycles</a> is incremented.</b>
    
    if(<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>&lt;1){printf("No event to train !!!n");return 0.;}
    if(!<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>){printf("no unit !n");return 0.;}
    
    <a href="../ListOfTypes.html#Int_t">Int_t</a> i;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> error=0.;
    
    for(i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>;i++)
    {  
	<a href="#TNNKernel:GetArrayEvt">GetArrayEvt</a>(<a href=".././TNNKernel.html#TNNKernel:fEventsList">fEventsList</a>[i]); 
	<a href="#TNNKernel:Forward">Forward</a>();
	error+=<a href="#TNNKernel:Error">Error</a>();
	<a href="#TNNKernel:LearnBackward">LearnBackward</a>();
    }
    
    <a href=".././TNNKernel.html#TNNKernel:fNTrainCycles">fNTrainCycles</a>++;
    error=error/(<a href="../ListOfTypes.html#Double_t">Double_t</a>)<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>;
<b>    //  printf("cycle %i : E_t = %6.4f ",<a href=".././TNNKernel.html#TNNKernel:fNTrainCycles">fNTrainCycles</a>,error);</b>
    
    return error;
}
/*
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href=".././TNNKernel.html#TNNKernel:Valid">TNNKernel::Valid</a>()
{
<b>    // one loop on valid events.  </b>
<b>    // takes each event from validation tree.</b>
<b>    // the events are passed trough the kernel, and a mean output</b>
<b>    // error is computed.</b>
    
    if(<a href=".././TNNKernel.html#TNNKernel:fNValidEvents">fNValidEvents</a>&lt;1) return 0.;
    
<b>    // we will now pass all the validation events through the kernel, and</b>
<b>    // compute the mean error on output </b>
    <a href="../ListOfTypes.html#Double_t">Double_t</a> error=0.;
    for (<a href="../ListOfTypes.html#Int_t">Int_t</a> j=0;j&lt;<a href=".././TNNKernel.html#TNNKernel:fNValidEvents">fNValidEvents</a>;j++)
    {
	<a href=".././TNNKernel.html#TNNKernel:fValidTree">fValidTree</a>-&gt;GetEvent(<a href="#TNNKernel:GetInputAdr">GetInputAdr</a>(),<a href="#TNNKernel:GetTeachAdr">GetTeachAdr</a>(),j);
	error+=<a href="#TNNKernel:GoThrough">GoThrough</a>(); // forward propagation and error on one event	
    }
    error=error/(<a href="../ListOfTypes.html#Double_t">Double_t</a>)<a href=".././TNNKernel.html#TNNKernel:fNValidEvents">fNValidEvents</a>; // mean
    return error;
}
*/
/*
<a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:TrainNCycles">TNNKernel::TrainNCycles</a>(TNNControlE *conte, <a href="../ListOfTypes.html#Int_t">Int_t</a> period, <a href="../ListOfTypes.html#Int_t">Int_t</a> nCycles)
{
<b>    // method to train on N cycles, with mixing and plot of errors</b>
<b>    // on the controller conte.</b>
    
    if(!conte){printf("no controller !n");return;}
    <a href="../ListOfTypes.html#Float_t">Float_t</a> errt,errv;
    for(<a href="../ListOfTypes.html#Int_t">Int_t</a> i=0;i&lt;nCycles;i++)
    {
	<a href="#TNNKernel:Mix">Mix</a>();
	errt=(<a href="../ListOfTypes.html#Float_t">Float_t</a>)<a href="#TNNKernel:TrainOneCycle">TrainOneCycle</a>();
	errv=(<a href="../ListOfTypes.html#Float_t">Float_t</a>)Valid();
	printf("cycle %3i &gt; train : %7.3f",<a href=".././TNNKernel.html#TNNKernel:fNTrainCycles">fNTrainCycles</a>,errt);
	if(<a href=".././TNNKernel.html#TNNKernel:fNValidEvents">fNValidEvents</a>)printf(" and valid : %7.3f n",errv);else printf("n");
	if(!(i%period)||i==(nCycles-1))
	{  
	    conte-&gt;AddTP(<a href=".././TNNKernel.html#TNNKernel:fNTrainCycles">fNTrainCycles</a>,errt); // add Train Point
	    conte-&gt;AddVP(<a href=".././TNNKernel.html#TNNKernel:fNTrainCycles">fNTrainCycles</a>,errv); // add Valid Point
	    conte-&gt;UpdateG();  // update graphics
	}     
	
    }
    
}
*/
<a name="TNNKernel:Export"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:Export">TNNKernel::Export</a>(<a href="../ListOfTypes.html#Text_t">Text_t</a> *fileName)
{
<b>    // Put the structure in a file</b>
<b>    // WARNING : the weights and biases are stored with 4 digits</b>
<b>    // in decimal part.    </b>
<b>    // Learning parameters are not stored</b>
    <a href="../ListOfTypes.html#Int_t">Int_t</a> i,l,c;
    
    if(!<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>){printf("no unit !n");return;} 
    
    FILE *file;
    file=fopen(fileName,"w");
    
    fprintf(file,"%3in",<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>);
    for(i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2;i++)fprintf(file,"%3in",<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i]);
    
    for(i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2;i++)
	for(l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++)fprintf(file,"%8.4fn",<a href=".././TNNKernel.html#TNNKernel:fBiases">fBiases</a>[i][l]);
	
    for(i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1;i++)
	for(l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++)
	    for(c=0;c&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i+1];c++)fprintf(file,"%8.4fn",<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>[i][l][c]);
		
    fprintf(file,"%5in",<a href=".././TNNKernel.html#TNNKernel:fNTrainCycles">fNTrainCycles</a>);  
    fprintf(file,"%2.0fn",<a href=".././TNNKernel.html#TNNKernel:fUseBiases">fUseBiases</a>); 
    
    fclose(file);   
}

<a name="TNNKernel:Import"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:Import">TNNKernel::Import</a>(<a href="../ListOfTypes.html#Text_t">Text_t</a> *fileName)
{
<b>    // Get the structure from a file</b>
<b>    // WARNING : the weights and biases are stored with 4 digits</b>
<b>    // in decimal part.</b>
<b>    // Learning parameteres are not stored.  </b>
    <a href="../ListOfTypes.html#Int_t">Int_t</a> i,l,c,newI,newHL,newO;
    <a href="../ListOfTypes.html#Text_t">Text_t</a> hidden[100],piece[5];
    FILE *file;
    file=fopen(fileName,"r");
    if (file==0) {
	cerr &lt;&lt; "<a href=".././TNNKernel.html#TNNKernel:Import">TNNKernel::Import</a>: Could not open " &lt;&lt; fileName &lt;&lt; endl;
	return;
    }
    
    fscanf(file,"%3i",&amp;newHL);
    fscanf(file,"%3i",&amp;newI); 
    strcpy(hidden,"");
    for(i=1;i&lt;newHL;i++)
    {fscanf(file,"%s",piece);strcat(hidden,piece);strcat(hidden,":");} 
    fscanf(file,"%s",piece);strcat(hidden,piece);
    fscanf(file,"%3i",&amp;newO); 
    
    printf("New NN set to : %3i  %s  %3i n",newI,hidden,newO);
    <a href="#TNNKernel:FreeVW">FreeVW</a>();			  
    <a href="#TNNKernel:AllocateVW">AllocateVW</a>(newI,hidden,newO);
    <a href="../ListOfTypes.html#Float_t">Float_t</a> tmpfl;
    for(i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+2;i++)
	for(l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++){<a href=".././TNNKernel.html#TNNKernel:fDB">fDB</a>[i][l]=0.;fscanf(file,"%f",&amp;tmpfl);*(<a href=".././TNNKernel.html#TNNKernel:fBiases">fBiases</a>[i]+l)=(<a href="../ListOfTypes.html#Double_t">Double_t</a>)tmpfl;}
	
    for(i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1;i++)
	for(l=0;l&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i];l++)
	    for(c=0;c&lt;<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[i+1];c++){<a href=".././TNNKernel.html#TNNKernel:fDW">fDW</a>[i][l][c]=0.;fscanf(file,"%f",&amp;tmpfl);*(<a href=".././TNNKernel.html#TNNKernel:fW">fW</a>[i][l]+c)=(<a href="../ListOfTypes.html#Double_t">Double_t</a>)tmpfl;}
		
		
    fscanf(file,"%5i",&amp;<a href=".././TNNKernel.html#TNNKernel:fNTrainCycles">fNTrainCycles</a>);  
    fscanf(file,"%f",&amp;tmpfl);<a href=".././TNNKernel.html#TNNKernel:fUseBiases">fUseBiases</a>=(<a href="../ListOfTypes.html#Double_t">Double_t</a>)tmpfl;  
    
    fclose(file);   
}

<a name="TNNKernel:Mix"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:Mix">TNNKernel::Mix</a>()
{
<b>    // mix the events before learning. VERY IMPORTANT.</b>
<b>    // is has to be used before  <a href="#TNNKernel:TrainOneCycle">TrainOneCycle</a>() , </b>
<b>    // IT IS NOT used by <a href="#TNNKernel:TrainOneCycle">TrainOneCycle</a>() , you have to do the call yourself</b>
    
    <a href="../ListOfTypes.html#Int_t">Int_t</a> i,i1,i2;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> temp;
    for (i=0;i&lt;3*<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>;i++)
    {
	i1=(<a href="../ListOfTypes.html#Int_t">Int_t</a>)(<a href=".././TNNKernel.html#TNNKernel:fRandom">fRandom</a>.Rndm()*(<a href="../ListOfTypes.html#Float_t">Float_t</a>)<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>);
	i2=(<a href="../ListOfTypes.html#Int_t">Int_t</a>)(<a href=".././TNNKernel.html#TNNKernel:fRandom">fRandom</a>.Rndm()*(<a href="../ListOfTypes.html#Float_t">Float_t</a>)<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>);
	temp=<a href=".././TNNKernel.html#TNNKernel:fEventsList">fEventsList</a>[i1];
	<a href=".././TNNKernel.html#TNNKernel:fEventsList">fEventsList</a>[i1]=<a href=".././TNNKernel.html#TNNKernel:fEventsList">fEventsList</a>[i2];
	<a href=".././TNNKernel.html#TNNKernel:fEventsList">fEventsList</a>[i2]=temp;
    }
    
<b>    //  for (i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>;i++)printf("%i n",<a href=".././TNNKernel.html#TNNKernel:fEventsList">fEventsList</a>[i]);  </b>
<b>    //  printf("Mixed ... ");</b>
}

<a name="TNNKernel:SetArraySize"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:SetArraySize">TNNKernel::SetArraySize</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> size)
{
    <a href="#TNNKernel:DeleteArray">DeleteArray</a>();
    if (<a href=".././TNNKernel.html#TNNKernel:fEventsList">fEventsList</a>) delete [] <a href=".././TNNKernel.html#TNNKernel:fEventsList">fEventsList</a>;
    if(!size)return;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> i;
    <a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>=size;  
    <a href=".././TNNKernel.html#TNNKernel:fArrayIn">fArrayIn</a>  = new <a href="../ListOfTypes.html#Float_t">Float_t</a>*[<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>];
    for (i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>;i++) <a href=".././TNNKernel.html#TNNKernel:fArrayIn">fArrayIn</a>[i] = new <a href="../ListOfTypes.html#Float_t">Float_t</a>[<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[0]];
    
    <a href=".././TNNKernel.html#TNNKernel:fArrayOut">fArrayOut</a> = new <a href="../ListOfTypes.html#Float_t">Float_t</a>*[<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>];  
    for (i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>;i++) <a href=".././TNNKernel.html#TNNKernel:fArrayOut">fArrayOut</a>[i] = new <a href="../ListOfTypes.html#Float_t">Float_t</a>[<a href=".././TNNKernel.html#TNNKernel:fNUnits">fNUnits</a>[<a href=".././TNNKernel.html#TNNKernel:fNHiddL">fNHiddL</a>+1]];
    
    <a href=".././TNNKernel.html#TNNKernel:fEventsList">fEventsList</a> = new <a href="../ListOfTypes.html#Int_t">Int_t</a>[<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>];
    for (i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>;i++)<a href=".././TNNKernel.html#TNNKernel:fEventsList">fEventsList</a>[i]=i;
}

<a name="TNNKernel:DeleteArray"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:DeleteArray">TNNKernel::DeleteArray</a>()
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> i; 
    
    if(<a href=".././TNNKernel.html#TNNKernel:fArrayIn">fArrayIn</a>) 
    {
	for (i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>;i++)delete [] <a href=".././TNNKernel.html#TNNKernel:fArrayIn">fArrayIn</a>[i];
	delete [] <a href=".././TNNKernel.html#TNNKernel:fArrayIn">fArrayIn</a>;
	<a href=".././TNNKernel.html#TNNKernel:fArrayIn">fArrayIn</a>=0;
    }
    
    if(<a href=".././TNNKernel.html#TNNKernel:fArrayOut">fArrayOut</a>) 
    {
	for (i=0;i&lt;<a href=".././TNNKernel.html#TNNKernel:fNTrainEvents">fNTrainEvents</a>;i++)delete [] <a href=".././TNNKernel.html#TNNKernel:fArrayOut">fArrayOut</a>[i];
	delete [] <a href=".././TNNKernel.html#TNNKernel:fArrayOut">fArrayOut</a>;
	<a href=".././TNNKernel.html#TNNKernel:fArrayOut">fArrayOut</a>=0;
    }
    
}
/*
<a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:SetTrainTree">TNNKernel::SetTrainTree</a>(TNNTree *t)
{
<b>    // method to associate a TNNTree to the kernel :</b>
<b>    // the events of the tree will be transferred in the internal</b>
<b>    // array of the kernel.</b>
    
    if(!t){printf("no tree !n");return;}
    <a href="../ListOfTypes.html#Int_t">Int_t</a> i;
    
<b>    //allocation  </b>
    
    <a href="#TNNKernel:SetArraySize">SetArraySize</a>((<a href="../ListOfTypes.html#Int_t">Int_t</a>)(t-&gt;GetTree()-&gt;GetEntries()));
    printf(" nbr evts for training : %i n",<a href="#TNNKernel:GetNTrainEvents">GetNTrainEvents</a>());  
    
<b>    // loop  </b>
<b>    // the methods <a href="#TNNKernel:GetInputAdr">GetInputAdr</a>() and <a href="#TNNKernel:GetTeachAdr">GetTeachAdr</a>()</b>
<b>    // return the adresses of arrays in kernel, and the method</b>
<b>    // GetEvent fills these adresses with event i of the train tree t</b>
<b>    // the method <a href="#TNNKernel:Fill">Fill</a>(i) translates the filled arrays in the internal array</b>
    
    for (i=0;i&lt;(<a href="../ListOfTypes.html#Int_t">Int_t</a>)(t-&gt;GetTree()-&gt;GetEntries());i++)
    {
	t-&gt;GetEvent(<a href="#TNNKernel:GetInputAdr">GetInputAdr</a>(),<a href="#TNNKernel:GetTeachAdr">GetTeachAdr</a>(),i);
	<a href="#TNNKernel:Fill">Fill</a>(i);  
    }
    
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././TNNKernel.html#TNNKernel:SetValidTree">TNNKernel::SetValidTree</a>(TNNTree *t)
{
<b>    // method to associate a TNNTree to the kernel :</b>
<b>    // a link will be done between the tree and the kernel.</b>
<b>    // it is not necessary to keep these events in the kernel</b>
    
    if(!t){printf("no tree !n");return;}
    <a href=".././TNNKernel.html#TNNKernel:fValidTree">fValidTree</a>=t;
    <a href=".././TNNKernel.html#TNNKernel:fNValidEvents">fNValidEvents</a>=(<a href="../ListOfTypes.html#Int_t">Int_t</a>)(t-&gt;GetTree()-&gt;GetEntries());
}
</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
