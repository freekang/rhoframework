<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:03:27 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TSimpleVertexSelector - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//////////////////////////////////////////////////////////////////////////</b>
<b>//                                                                      //</b>
<b>// <a href=".././TSimpleVertexSelector.html">TSimpleVertexSelector</a>						//</b>
<b>//                                                                      //</b>
<b>// Selector class to estimate the geometric intersection of two tracks  //</b>
<b>// Intended to provide the initial vertex position for V0 fits          //</b>
<b>//                                                                      //</b>
<b>// Author List:                                                         //</b>
<b>// Marcel Kunze,  RUB, Feb. 99                                          //</b>
<b>// Copyright (C) 1999-2001, Ruhr-University Bochum.                     //</b>
<b>//                                                                      //</b>
<b>//////////////////////////////////////////////////////////////////////////</b>

#include "RhoSelector/TSimpleVertexSelector.h"
#include "RhoManager/TPersistenceManager.h"
#include "RhoBase/TRho.h"
#include "RhoBase/TCandidate.h"

ClassImp(TSimpleVertexSelector)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, TSimpleVertexSelector *&amp;obj)
{
   obj = (TSimpleVertexSelector *) buf.ReadObject(TSimpleVertexSelector::Class());
   return buf;
}

#include &lt;iostream&gt;
using namespace std;

<a name="TSimpleVertexSelector:TSimpleVertexSelector"> </a>TSimpleVertexSelector::TSimpleVertexSelector(const char *name, Double_t d, Double_t a, Double_t r1, Double_t r2) :
VAbsVertexSelector(name), fQC(0)
{
    fDoca = d;
    fVtxip = a;
    fRmin = r1;
    fRmax = r2;
}

<a name="TSimpleVertexSelector:~TSimpleVertexSelector"> </a>TSimpleVertexSelector::~TSimpleVertexSelector() { delete fQC; }

<a name="TSimpleVertexSelector:Accept"> </a>Bool_t TSimpleVertexSelector::Accept(TCandidate&amp; a, TCandidate&amp; b) 
{
    if (&amp;a==0 || &amp;b==0) return kFALSE;
    
    Float_t bField = TRho::Instance()-&gt;GetMagnetField();	// Retrieve the B-Field
    
<b>    // Position vectors</b>
    TVector3 position1 = a.GetPosition();
    TVector3 position2 = b.GetPosition();
    
<b>    // Momentum vectors</b>
    TVector3 ap3 = a.P3();
    <a href="../ListOfTypes.html#Double_t">Double_t</a> pPerp1 = ap3.Perp();
    TVector3 d1 = ap3;
    d1.SetZ(0);
    d1*=1.0/pPerp1;
    
    TVector3 bp3 = b.P3();
    <a href="../ListOfTypes.html#Double_t">Double_t</a> pPerp2 = bp3.Perp();
    TVector3 d2 = bp3;
    d2.SetZ(0);
    d2*=1.0/pPerp2;
    
    
    TVector3 dB(0,0,1.0);
<b>    // Radius and center</b>
    <a href="../ListOfTypes.html#Double_t">Double_t</a> rho1 = 100. * pPerp1/(0.3*bField); // Radius in cm
    TVector3 r1=d1.Cross(dB);
    r1 *= -a.Charge()*rho1;
    TVector3 center1 = position1 - r1;
    center1.SetZ(0);
    
    <a href="../ListOfTypes.html#Double_t">Double_t</a> rho2 = 100. * pPerp2/(0.3*bField); // Radius in cm
    TVector3 r2=d2.Cross(dB);
    r2 *= -b.Charge()*rho2;
    TVector3 center2 = position2 - r2;
    center2.SetZ(0);
    
<b>    // distance and angle of the axis between the two centers</b>
    TVector3 ab = center2 - center1;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> dab = ab.Perp();
    <a href="../ListOfTypes.html#Double_t">Double_t</a> cosTheAB = ab.X()/dab;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> sinTheAB = ab.Y()/dab;
    
    
<b>    // x value of intersect at reduced system </b>
    <a href="../ListOfTypes.html#Double_t">Double_t</a> x = dab/2 + ( rho1*rho1 - rho2*rho2 )/(2*dab); 
    
<b>    // y*y value of intersect at reduced system for helix A</b>
    <a href="../ListOfTypes.html#Double_t">Double_t</a> y2 = (rho1+x)*(rho1-x); 
    
<b>    // both circles do not intersect (only one solution)</b>
    <a href="../ListOfTypes.html#Int_t">Int_t</a> nSolMax=1;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> y=0; 
    
    if (y2 &gt; 0) {
	nSolMax=2;
	y = sqrt(y2);
    }else{
<b>	//if( fabs(dab-rho1-rho2) &gt; fActualDoca);</b>
<b>	//return kFALSE;</b>
    }
    
<b>    // now we compute the solution(s)</b>
    
    TVector3 newap3[2];
    TVector3 newbp3[2];
    TVector3 newapos[2];
    TVector3 newbpos[2];
    <a href="../ListOfTypes.html#Int_t">Int_t</a> best=0;
    fActualDoca=1.E8;
    for (<a href="../ListOfTypes.html#Int_t">Int_t</a> ns=0; ns&lt;nSolMax; ns++){      // loop on the solutions
	
<b>	// radius vector of intersection point</b>
	<a href="../ListOfTypes.html#Double_t">Double_t</a> sign = ns ? 1.0 : -1.0;
	TVector3 rs1( cosTheAB*x - sinTheAB*y * sign, sinTheAB*x + cosTheAB*y * sign, 0);  
	TVector3 rs2( rs1-ab );
	
<b>	// are we moving forward or backward?</b>
	<a href="../ListOfTypes.html#Double_t">Double_t</a> adir=(rs1-r1).Dot(ap3)&gt;0 ? 1.0 : -1.0;
	<a href="../ListOfTypes.html#Double_t">Double_t</a> aangle=adir * r1.Angle(rs1);
<b>	// intersection point</b>
	<a href="../ListOfTypes.html#Double_t">Double_t</a> newaz=position1.Z() + rho1*aangle/pPerp1 * ap3.Z();
	newapos[ns].SetX( center1.X() + rs1.X() );
	newapos[ns].SetY( center1.Y() + rs1.Y() );
	newapos[ns].SetZ( newaz );
	
<b>	// adjust momentum</b>
	newap3[ns]=rs1.Cross(dB);
	newap3[ns]*=a.Charge()/rho1*pPerp1;
	newap3[ns].SetZ(ap3.Z());
	
	
<b>	// same for b</b>
	<a href="../ListOfTypes.html#Double_t">Double_t</a> bdir=(rs2-r2).Dot(bp3)&gt;0 ? 1.0 : -1.0;
	<a href="../ListOfTypes.html#Double_t">Double_t</a> bangle=bdir * r2.Angle(rs2);
	<a href="../ListOfTypes.html#Double_t">Double_t</a> newbz=position2.Z() + rho2*bangle/pPerp2 * bp3.Z();
	newbpos[ns].SetX( center2.X() + rs2.X());   // ==newapos[ns].X()
	newbpos[ns].SetY( center2.Y() + rs2.Y());   // ==newapos[ns].Y()
	newbpos[ns].SetZ( newbz );
	newbp3[ns]=rs2.Cross(dB);
	newbp3[ns]*=b.Charge()/rho2*pPerp2;
	newbp3[ns].SetZ(bp3.Z());
	
	<a href="../ListOfTypes.html#Double_t">Double_t</a> delta = (newapos[ns]-newbpos[ns]).Mag();
	
<b>	// take the solution of minimal deltaZ</b>
	if ( delta &lt; fActualDoca ) {
	    best=ns;
	    fActualDoca  = delta;
	}
    }
    
    fVertex=0.5*(newapos[best]+newbpos[best]);
    fMomA=newap3[best];
    fMomB=newbp3[best];
    
<b>    // Now reconstruct original flight path and</b>
<b>    // calculate the angle to vertex-ip</b>
    
    TVector3 p=fMomA+fMomB;
    TVector3 vtxip = fVertex-fPrimaryVertex;
    fActualVtxip = vtxip.Angle(p);
    fActualR = vtxip.Mag();
    
    if (<a href=".././TSimpleVertexSelector.html#TSimpleVertexSelector:fQC">fQC</a>!=0) <a href=".././TSimpleVertexSelector.html#TSimpleVertexSelector:fQC">fQC</a>-&gt;<a href=".././THistogram.html#THistogram:Accumulate">Accumulate</a>((<a href="../ListOfTypes.html#Float_t">Float_t</a>)fActualDoca,(<a href="../ListOfTypes.html#Float_t">Float_t</a>)fActualVtxip);
    
    if ( fActualDoca &lt; fDoca &amp;&amp; 
	 fActualR &gt;= fRmin &amp;&amp; fActualR &lt; fRmax &amp;&amp; 
	 fActualVtxip &lt; fVtxip ){
      
      return kTRUE;
      
    }else{
      fMomA=ap3;
      fMomB=bp3;
      fVertex = fPrimaryVertex;
      return kFALSE;
    }
    return kFALSE; //get rid of warnings
}


<a name="TSimpleVertexSelector:ActivateQualityControl"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TSimpleVertexSelector.html#TSimpleVertexSelector:ActivateQualityControl">TSimpleVertexSelector::ActivateQualityControl</a>()
{
    <a href=".././TPersistenceManager.html">TPersistenceManager</a> *persmgr = TRho::Instance()-&gt;GetPersistenceManager();
    if (persmgr == 0) {
	std::cerr &lt;&lt; "TVertexSelector: Can not activate QC w/o PersistenceManager." &lt;&lt; std::endl;
	return;
    }

<b>    // Make a quality control directory, if needed and cd into it</b>

    persmgr-&gt;SetDir("QC/TVertexSelector");    
    <a href=".././TSimpleVertexSelector.html#TSimpleVertexSelector:fQC">fQC</a> = persmgr-&gt;Histogram(GetName(),100,0.0,10.,100,0.0,kPI);
}

</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
