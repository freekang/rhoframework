<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:02:49 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TDirectoryManager - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//////////////////////////////////////////////////////////////////////////</b>
<b>//                                                                      //</b>
<b>// <a href=".././TDirectoryManager.html">TDirectoryManager</a>							//</b>
<b>//                                                                      //</b>
<b>// Directory manager					    		//</b>
<b>// Organize chains of files according to physics topics and periods	//</b>
<b>// of interest.								//</b>
<b>//                                                                      //</b>
<b>// Author: Marcel Kunze, Bochum University, April 99			//</b>
<b>// Copyright (C) 1999-2001, Ruhr-University Bochum.			//</b>
<b>//									//</b>
<b>//////////////////////////////////////////////////////////////////////////</b>

#include &lt;stdlib.h&gt;
#include "RhoManager/TDirectoryManager.h"
#include "RhoBase/TRho.h"

ClassImp(TDirectoryManager)

#include &lt;iostream&gt;
using namespace std;

<a name="TDirectoryManager:TDirectoryManager"> </a>TDirectoryManager::TDirectoryManager() : 
fBaseDirectory(TRho::Instance()-&gt;GetEventStore()), fNumberFiles(0), 
fCounter(0),fActualFile(0), fEntries(0)
{    
    TRho *rho = const_cast&lt;TRho*&gt; (TRho::Instance());
    rho-&gt;SetDirectoryManager(this);
}

<a name="TDirectoryManager:TDirectoryManager"> </a>TDirectoryManager::TDirectoryManager(const char* directory) : 
fBaseDirectory(directory), fNumberFiles(0), 
fCounter(0),fActualFile(0), fEntries(0)
{
    TRho *rho = const_cast&lt;TRho*&gt; (TRho::Instance());
    rho-&gt;SetDirectoryManager(this);
}

<a name="TDirectoryManager:~TDirectoryManager"> </a>TDirectoryManager::~TDirectoryManager()
{
}

<a name="TDirectoryManager:AddFile"> </a>void TDirectoryManager::AddFile(const char* s) 
{
    TString name = ExpandFilename(s);
    fFiles.Add(new TObjString(name));
    fNumberFiles++;
    cout &lt;&lt; "TDirectoryManager::AddFile " &lt;&lt; name.Data() &lt;&lt; endl;
}


<a name="TDirectoryManager:PrintOn"> </a>void TDirectoryManager::PrintOn ( std::ostream &amp; oout ) const {
<b>    // Dump a directory of what's going on</b>
    oout &lt;&lt; "<a href=".././TDirectoryManager.html">TDirectoryManager</a>: " &lt;&lt; <a href=".././TDirectoryManager.html#TDirectoryManager:fNumberFiles">fNumberFiles</a> &lt;&lt; " file(s) in " &lt;&lt; <a href=".././TDirectoryManager.html#TDirectoryManager:fBaseDirectory">fBaseDirectory</a> &lt;&lt; endl;
    for (<a href="../ListOfTypes.html#int">int</a> o=0;o&lt;<a href=".././TDirectoryManager.html#TDirectoryManager:fNumberFiles">fNumberFiles</a>;o++) oout &lt;&lt; (((TObjString*) <a href=".././TDirectoryManager.html#TDirectoryManager:fFiles">fFiles</a>.At(o))-&gt;GetString()).Data() &lt;&lt; endl;
    oout &lt;&lt; endl;
}

<b>// Here comes the VAbsCollection interface</b>

<a name="TDirectoryManager:Rewind"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TDirectoryManager.html#TDirectoryManager:Rewind">TDirectoryManager::Rewind</a>() 
{ 
    <a href=".././TDirectoryManager.html#TDirectoryManager:fCounter">fCounter</a> = 0;
    <a href=".././TDirectoryManager.html#TDirectoryManager:fEntries">fEntries</a> = 0;
    <a href=".././TDirectoryManager.html#TDirectoryManager:fActualFile">fActualFile</a> = 0;
}

<a name="TDirectoryManager:NextIndex"> </a><a href="../ListOfTypes.html#Int_t">Int_t</a> <a href=".././TDirectoryManager.html#TDirectoryManager:NextIndex">TDirectoryManager::NextIndex</a>(<a href="../ListOfTypes.html#Bool_t">Bool_t</a> &amp;changeFile) 
{
    if (<a href=".././TDirectoryManager.html#TDirectoryManager:fCounter">fCounter</a> &gt;= <a href=".././TDirectoryManager.html#TDirectoryManager:fEntries">fEntries</a>) {
	changeFile = kTRUE;
	<a href=".././TDirectoryManager.html#TDirectoryManager:fCounter">fCounter</a> = 0;
	<a href=".././TDirectoryManager.html#TDirectoryManager:fActualFile">fActualFile</a>++;
	if (<a href=".././TDirectoryManager.html#TDirectoryManager:fActualFile">fActualFile</a>&gt;=<a href=".././TDirectoryManager.html#TDirectoryManager:fNumberFiles">fNumberFiles</a>) return -1;
	while (!<a href="#TDirectoryManager:InitRead">InitRead</a>()) {
	    cerr &lt;&lt; "<a href=".././TDirectoryManager.html#TDirectoryManager:NextIndex">TDirectoryManager::NextIndex</a>: Can not open " &lt;&lt; ((TObjString*) <a href=".././TDirectoryManager.html#TDirectoryManager:fFiles">fFiles</a>.At(<a href=".././TDirectoryManager.html#TDirectoryManager:fActualFile">fActualFile</a>-1))-&gt;GetString() &lt;&lt; endl;
	    <a href="../ListOfTypes.html#Bool_t">Bool_t</a> newFile;
	    if (<a href="#TDirectoryManager:NextIndex">NextIndex</a>(newFile)==-1) {
		cerr &lt;&lt; "<a href=".././TDirectoryManager.html#TDirectoryManager:NextIndex">TDirectoryManager::NextIndex</a>: No valid collection" &lt;&lt; endl;
		return -1;
	    }
	}
    }

    fCurrentIndex = <a href=".././TDirectoryManager.html#TDirectoryManager:fCounter">fCounter</a>;
    return <a href=".././TDirectoryManager.html#TDirectoryManager:fCounter">fCounter</a>++; 
}

<a name="TDirectoryManager:GetFileName"> </a>const <a href="../ListOfTypes.html#char">char</a>* <a href=".././TDirectoryManager.html#TDirectoryManager:GetFileName">TDirectoryManager::GetFileName</a>() const 
{
    if (<a href=".././TDirectoryManager.html#TDirectoryManager:fFiles">fFiles</a>.At(<a href=".././TDirectoryManager.html#TDirectoryManager:fActualFile">fActualFile</a>) == 0) return "";
    return ((TObjString*) <a href=".././TDirectoryManager.html#TDirectoryManager:fFiles">fFiles</a>.At(<a href=".././TDirectoryManager.html#TDirectoryManager:fActualFile">fActualFile</a>))-&gt;GetString().Data(); 
}

<a name="TDirectoryManager:InitRead"> </a><a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href=".././TDirectoryManager.html#TDirectoryManager:InitRead">TDirectoryManager::InitRead</a>() 
{
<b>    // Count the entries in the file</b>
    <a href=".././TDirectoryManager.html#TDirectoryManager:fEntries">fEntries</a> = 0;
    TString filename, treename;
    <a href="../ListOfTypes.html#Bool_t">Bool_t</a> status = kTRUE;

    TString s(((TObjString*) <a href=".././TDirectoryManager.html#TDirectoryManager:fFiles">fFiles</a>.At(<a href=".././TDirectoryManager.html#TDirectoryManager:fActualFile">fActualFile</a>))-&gt;GetString());

    if (s.Index("-micro")==s.Length()-6) { // A Kanga file
	filename = s + TString(".root");
	treename = "microDST";
    }
    else if (s.Index("Kanga")&gt;=0) { // Kanga shortcut
        filename = s + TString("-micro.root");
        treename = "microDST";
    }
    else {
	filename = s + TString("Tag.root"); // A PAF file
	treename = "TagTree";
    }

    if (<a href=".././TDirectoryManager.html#TDirectoryManager:fBaseDirectory">fBaseDirectory</a>.Index("root:")&gt;=0) TRho::Authorize();

    TFile *fFile = TFile::Open(filename);

    if (fFile-&gt;IsOpen()) {
      
      TTree* newTree = (TTree*) fFile-&gt;Get(treename);
      
      if (newTree==0) {
	cout &lt;&lt; "ERROR ! Could not find " &lt;&lt; treename.Data() 
	     &lt;&lt; " in File " &lt;&lt; filename.Data() &lt;&lt; endl;
	fFile-&gt;Close();
	status = kFALSE;
      }

      <a href=".././TDirectoryManager.html#TDirectoryManager:fEntries">fEntries</a> = (<a href="../ListOfTypes.html#Int_t">Int_t</a>) newTree-&gt;GetEntries();
    }
    else
      status = kFALSE; // File does not exist

    fFile-&gt;Close();

    if (!status) { // Try another file
	<a href="../ListOfTypes.html#Bool_t">Bool_t</a> newFile;
	if (<a href="#TDirectoryManager:NextIndex">NextIndex</a>(newFile)!=-1) status = kTRUE;
    }

    return status;
}

<b>// --------------------</b>
<b>// non-member functions</b>
<b>// --------------------</b>

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././TDirectoryManager.html">TDirectoryManager</a>&amp; a) {a.<a href="#TDirectoryManager:PrintOn">PrintOn</a>(o); return o;}

<b>// Experiment specific directory conversion routine</b>

<a name="TDirectoryManager:ExpandFilename"> </a>TString <a href=".././TDirectoryManager.html#TDirectoryManager:ExpandFilename">TDirectoryManager::ExpandFilename</a>(TString name)
{
<b>    // Special treatment of BFROOT</b>
    if (name.Index("BFROOT")&gt;=0) {
	TString base="";
	if (getenv("BFROOT")) 
	    base = getenv("BFROOT");
	else if (getenv("RHOROOT"))
	    base = getenv("RHOROOT");
	

	if (base!="") {
	    if (name.Index("$env(BFROOT)")&gt;=0) name = base + name(12,name.Length()-12);
	    if (name.Index("$BFROOT")&gt;=0) name = base + name(7,name.Length()-7);
	}
	else {
	    cerr &lt;&lt; "<a href=".././TDirectoryManager.html">TDirectoryManager</a>: BFROOT and RHOROOT not set. Unable to locate " &lt;&lt; name &lt;&lt; endl;
	}
    }

    <a href="../ListOfTypes.html#Bool_t">Bool_t</a> kanga =  name.Index("Kanga") &gt;= 0;

<b>    // It could as well be that a Kanga file is given relative to $EVENT_STORE with a leading "/"</b>
    if (kanga &amp;&amp; name.Index("/groups")==0) name = <a href=".././TDirectoryManager.html#TDirectoryManager:fBaseDirectory">fBaseDirectory</a> + name;
    if (kanga &amp;&amp; name.Index("/user")==0)   name = <a href=".././TDirectoryManager.html#TDirectoryManager:fBaseDirectory">fBaseDirectory</a> + name;
    if (kanga &amp;&amp; name.Index("/system")==0) name = <a href=".././TDirectoryManager.html#TDirectoryManager:fBaseDirectory">fBaseDirectory</a> + name;

    return <a href="#TDirectoryManager:FullyQualified">FullyQualified</a>(name);
}

<a name="TDirectoryManager:FullyQualified"> </a>TString <a href=".././TDirectoryManager.html#TDirectoryManager:FullyQualified">TDirectoryManager::FullyQualified</a>(TString s)
{
<b>    // Check that we have a fully qualified Unix or Windows filename</b>

    if (s.Data()[0] == '/') return s; // UNIX
    if (s.Data()[0] == '$') return s; // Environment
    if (s.Data()[0] == '~') return s; // Home directory
    if (s.Data()[0] == '.') return s; // Absolute path
    if (s.Data()[1] == ':') return s; // Windows drive letter
    if (s.Index("root:")==0) return s; // ROOTD file

    s = <a href=".././TDirectoryManager.html#TDirectoryManager:fBaseDirectory">fBaseDirectory</a>+"/"+s; // Prepend the base directory

    return s;
}

</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
