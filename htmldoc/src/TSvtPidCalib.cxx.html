<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:03:28 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TSvtPidCalib - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//////////////////////////////////////////////////////////////////////////</b>
<b>//                                                                      //</b>
<b>// <a href=".././TSvtPidCalib.html">TSvtPidCalib</a>			    					//</b>
<b>//                                                                      //</b>
<b>// SVT conditions class							//</b>
<b>//                                                                      //</b>
<b>// Author: Marcel Kunze, RUB, Nov. 99					//</b>
<b>// Copyright (C) 1999-2001, Ruhr-University Bochum.			//</b>
<b>//                                                                      //</b>
<b>//////////////////////////////////////////////////////////////////////////</b>

#include "RhoConditions/TSvtPidCalib.h"

ClassImp(SvtPidSimpleTMCalibR)

#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

SvtPidSimpleTMCalibR::SvtPidSimpleTMCalibR()
{ 
<b>  // these values are taken from SvtPidInfo. They should be overridden by</b>
<b>  // condDB</b>

  <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_aMean">_aMean</a> = 3.00;
  <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_pMean">_pMean</a> = 2.66;
  <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_pgb">_pgb</a>   = 0.025;
  <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_cMean">_cMean</a> = 3.54;

  <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_aSig1">_aSig1</a>  = 0.254;
  <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_pSig1">_pSig1</a>  = 2.97;
  <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_bSig1">_bSig1</a>  = 0.933;
  <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_cSig1">_cSig1</a>  = 0.443;

  <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_aSig2">_aSig2</a>  = 0.286;
  <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_pSig2">_pSig2</a>  = 3.11;
  <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_bSig2">_bSig2</a>  = 1.029;
  <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_cSig2">_cSig2</a>  = 0.465;
}

<a href=".././SvtPidSimpleTMCalibR.html">SvtPidSimpleTMCalibR</a>::~<a href=".././SvtPidSimpleTMCalibR.html">SvtPidSimpleTMCalibR</a>() { }

<a href="../ListOfTypes.html#Double_t">Double_t</a>
<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:Beta2dedx">SvtPidSimpleTMCalibR::Beta2dedx</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> beta) const {  
  <a href="../ListOfTypes.html#Double_t">Double_t</a> dedx=0.;
  if (beta &gt; 0 &amp;&amp; beta &lt;= 1.) {
<b>    // put in a relativistic rise with a plateau for electrons</b>
    <a href="../ListOfTypes.html#Double_t">Double_t</a> gammaBeta = 40.;
    if ( beta &lt; 1.) gammaBeta = beta / sqrt(1.0-beta*beta);
    <a href="../ListOfTypes.html#Double_t">Double_t</a> modifiedGammaBeta = gammaBeta;
    if(gammaBeta&gt;40.) modifiedGammaBeta=40.;
    dedx=<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_aMean">_aMean</a>*pow(beta,-<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_pMean">_pMean</a>) * pow(modifiedGammaBeta,<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_pgb">_pgb</a>);
  }
  return dedx;
}

<a href="../ListOfTypes.html#Double_t">Double_t</a>
<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:Dedx2beta">SvtPidSimpleTMCalibR::Dedx2beta</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> dedx) const 
{
<b>  //</b>
<b>  // this is now only an approximation (good to ~5%)</b>
<b>  //</b>
  <a href="../ListOfTypes.html#Double_t">Double_t</a> beta=1.;
  if (dedx &gt; 0 &amp;&amp; dedx &lt; <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_cMean">_cMean</a>) {
    beta=pow(dedx/<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_aMean">_aMean</a>,-1./<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_pMean">_pMean</a>);
  }

  beta=TMath::Max(TMath::Min(beta,1.),0.);

  return beta;
}

<a href="../ListOfTypes.html#Double_t">Double_t</a>
<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:Beta2sig1">SvtPidSimpleTMCalibR::Beta2sig1</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> beta) const 
{
<b>  //</b>
<b>  // This is actually sig(log(dedx)), but the fit is</b>
<b>  // better for sig(dedx). The fit variable is gamma*beta</b>
<b>  //</b>

  <a href="../ListOfTypes.html#Double_t">Double_t</a> sig1=0;
  if (beta &gt; 0 &amp;&amp; beta &lt;= 1.) {
    <a href="../ListOfTypes.html#Double_t">Double_t</a> dedx=Beta2dedx(beta);
<b>    // put in a relativistic rise with a plateau for electrons</b>
    <a href="../ListOfTypes.html#Double_t">Double_t</a> gammaBeta = 40.;
    if ( beta &lt; 1.) gammaBeta = beta / sqrt(1.0-beta*beta);
    if ( dedx&gt;0 ) {
      sig1=<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_aSig1">_aSig1</a>*pow(gammaBeta/<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_bSig1">_bSig1</a>,-<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_pSig1">_pSig1</a>)/dedx+<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_cSig1">_cSig1</a>;
    }
  }
  return sig1;
}

<a href="../ListOfTypes.html#Double_t">Double_t</a>
<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:Beta2sig2">SvtPidSimpleTMCalibR::Beta2sig2</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> beta) const 
{
<b>  //</b>
<b>  // This is actually sig(log(dedx)), but the fit is</b>
<b>  // better for sig(dedx). The fit variable is gamma*beta</b>
<b>  //</b>

  <a href="../ListOfTypes.html#Double_t">Double_t</a> sig2=0;
  if (beta &gt; 0 &amp;&amp; beta &lt;= 1.) {
    <a href="../ListOfTypes.html#Double_t">Double_t</a> dedx=Beta2dedx(beta);
    <a href="../ListOfTypes.html#Double_t">Double_t</a> gammaBeta = 40.;
    if ( beta &lt; 1.) gammaBeta = beta / sqrt(1.0-beta*beta);
    if ( dedx&gt;0 ) {
      sig2=<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_aSig2">_aSig2</a>*pow(gammaBeta/<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_bSig2">_bSig2</a>,-<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_pSig2">_pSig2</a>)/dedx+<a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_cSig2">_cSig2</a>;
    }
  }
  return sig2;
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:PrintOn">SvtPidSimpleTMCalibR::PrintOn</a>(std::ostream&amp; os) const 
{
  os &lt;&lt; "Class SvtPidSimpleTMCalib:" &lt;&lt; endl;

  os &lt;&lt; "t meanPar: "; 
  os &lt;&lt; setw(10) &lt;&lt; setprecision(4) &lt;&lt; <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_aMean">_aMean</a> 
     &lt;&lt; setw(10) &lt;&lt; setprecision(4) &lt;&lt; <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_pMean">_pMean</a> 
     &lt;&lt; setw(10) &lt;&lt; setprecision(4) &lt;&lt; <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_pgb">_pgb</a> 
     &lt;&lt; setw(10) &lt;&lt; setprecision(4) &lt;&lt; <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_cMean">_cMean</a> 
     &lt;&lt; endl;

  os &lt;&lt; "t sig1Par: ";
  os &lt;&lt; setw(10) &lt;&lt; setprecision(4) &lt;&lt; <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_aSig1">_aSig1</a> 
     &lt;&lt; setw(10) &lt;&lt; setprecision(4) &lt;&lt; <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_bSig1">_bSig1</a>
     &lt;&lt; setw(10) &lt;&lt; setprecision(4) &lt;&lt; <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_pSig1">_pSig1</a>
     &lt;&lt; setw(10) &lt;&lt; setprecision(4) &lt;&lt; <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_cSig1">_cSig1</a>
     &lt;&lt; endl;

  os &lt;&lt; "t sig2Par: ";
  os  &lt;&lt; setw(10) &lt;&lt; setprecision(4) &lt;&lt; <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_aSig2">_aSig2</a>
      &lt;&lt; setw(10) &lt;&lt; setprecision(4) &lt;&lt; <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_bSig2">_bSig2</a> 
      &lt;&lt; setw(10) &lt;&lt; setprecision(4) &lt;&lt; <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_pSig2">_pSig2</a>
      &lt;&lt; setw(10) &lt;&lt; setprecision(4) &lt;&lt; <a href=".././SvtPidSimpleTMCalibR.html#SvtPidSimpleTMCalibR:_cSig2">_cSig2</a>
      &lt;&lt; endl;
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././SvtPidSimpleTMCalibR.html">SvtPidSimpleTMCalibR</a>&amp; a) { a.PrintOn(o); return o; }

ClassImp(<a href=".././TSvtPidCalib.html">TSvtPidCalib</a>)


</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
