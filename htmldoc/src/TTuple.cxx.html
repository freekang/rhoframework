<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:03:31 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TTuple - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//////////////////////////////////////////////////////////////////////////</b>
<b>//                                                                      //</b>
<b>// <a href=".././TTuple.html">TTuple</a>		                                                //</b>
<b>//                                                                      //</b>
<b>// Nested class hierarchy to hold information about <a href=".././TTuple.html">TTuple</a> columns.	//</b>
<b>//									//</b>
<b>// Author List:								//</b>
<b>// Marcel Kunze, RUB,Mar. 99						//</b>
<b>// Apr.2001 (MK),Faster implementation based on THashList		//</b>
<b>// Copyright (C) 1999-2001,Ruhr-University Bochum.			//</b>
<b>//									//</b>
<b>//////////////////////////////////////////////////////////////////////////</b>

#include "TTree.h"
#include "TBranch.h"
#include "TString.h"

#include "RhoHistogram/TTuple.h"

ClassImp(TTuple)

#include &lt;iostream&gt;
using namespace std;

<a name="TTuple:TTuple"> </a>TTuple::TTuple() 
{ 
    fMap   = new THashList(); 
}

<b>// Constructor to create a tuple with name and title:</b>
<a name="TTuple:TTuple"> </a><a href=".././TTuple.html#TTuple:TTuple">TTuple::TTuple</a>(const <a href="../ListOfTypes.html#char">char</a>* name,const <a href="../ListOfTypes.html#char">char</a>* title) : 
TNamed(name,title)
{
    <a href=".././TTuple.html#TTuple:fMap">fMap</a>  = new THashList(); 
    <a href=".././TTuple.html#TTuple:fTree">fTree</a> = new TTree(name,title);
}

<b>// Destructor:</b>
<a name="TTuple:~TTuple"> </a><a href=".././TTuple.html">TTuple</a>::~<a href=".././TTuple.html">TTuple</a>() 
{
    delete <a href=".././TTuple.html#TTuple:fTree">fTree</a>;
    delete <a href=".././TTuple.html#TTuple:fMap">fMap</a>;
}

<b>// Column booking/filling. All these have the same name - <a href="#TTuple:Column">Column</a>(...)</b>

<b>// Specify the data for a Column. The string is to the key to</b>
<b>// the Column,so it must be unique.</b>


<b>// ===== = Bool type ======</b>
<b>// Make/fill Column with a single value</b>
<a name="TTuple:Column"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>(const <a href="../ListOfTypes.html#char">char</a>* label,
			<a href="../ListOfTypes.html#Bool_t">Bool_t</a> value,
			<a href="../ListOfTypes.html#Bool_t">Bool_t</a> defval,
			const <a href="../ListOfTypes.html#char">char</a>* block) 
{   
    <a href=".././TColumn.html">TColumn</a>* colp = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(label);
    if(colp) {
<b>	// Column exists,fill corresponding memory location with value:</b>
	colp-&gt;SetValue(&amp;value);
	colp-&gt;SetUseDefValue(0);
    }
    else {
<b>	// Create a new Column:</b>
	colp = new BoolColumn(label,value,defval,<a href=".././TTuple.html#TTuple:fTree">fTree</a>);
	<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;Add(colp);
    }
    
}

<b>// Make/fill Column-array. Length is fixed at creation time.</b>
<a name="TTuple:Column"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>(const <a href="../ListOfTypes.html#char">char</a>* label,
			const HTAbsValVector&lt;<a href="../ListOfTypes.html#Bool_t">Bool_t</a>&gt; &amp;vector,
			<a href="../ListOfTypes.html#Bool_t">Bool_t</a> defval,
			const <a href="../ListOfTypes.html#char">char</a>* block)
{   
    <a href=".././TColumn.html">TColumn</a>* colp = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(label);
    if(colp) {
<b>	// Column exists,fill corresponding memory location with value:</b>
	colp-&gt;SetValue(&amp;vector);
	colp-&gt;SetUseDefValue(kFALSE);
    }
    else {
<b>	// Create a new Column:</b>
	colp = new BoolArrColumn(label,vector,defval,<a href=".././TTuple.html#TTuple:fTree">fTree</a>);
	<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;Add(colp);
    }
    
}

<b>// Make/fill Column-array. Length is variable and is taken from </b>
<b>// another Column.</b>
<a name="TTuple:Column"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>(const <a href="../ListOfTypes.html#char">char</a>* label,
			const HTAbsValVector&lt;<a href="../ListOfTypes.html#Bool_t">Bool_t</a>&gt; &amp;vector,
			const <a href="../ListOfTypes.html#char">char</a>* ilab,
			<a href="../ListOfTypes.html#Bool_t">Bool_t</a> defval,
			const <a href="../ListOfTypes.html#char">char</a>* block) 
{ 
    <a href=".././TColumn.html">TColumn</a>* colp = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(label);
    if(colp) {
<b>	// Column exists,fill corresponding memory location with value:</b>
	colp-&gt;SetValue(&amp;vector,(<a href=".././TColumn.html">TColumn</a>*)<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(ilab));
	colp-&gt;SetUseDefValue(kFALSE);
    }
    else {
<b>	// Create a new branch:</b>
	<a href=".././TColumn.html">TColumn</a>* indexPtr = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(ilab);
	colp = new BoolDynArrColumn(label,vector,defval,indexPtr,<a href=".././TTuple.html#TTuple:fTree">fTree</a>);
	<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;Add(colp);
    }
    
}


<b>// ===== = Int type ======</b>
<b>// Make/fill Column with a single value</b>
<a name="TTuple:Column"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>(const <a href="../ListOfTypes.html#char">char</a>* label,
			<a href="../ListOfTypes.html#Int_t">Int_t</a> value,
			<a href="../ListOfTypes.html#Int_t">Int_t</a> defval,
			const <a href="../ListOfTypes.html#char">char</a>* block,
			const HTRange&lt;<a href="../ListOfTypes.html#Int_t">Int_t</a>&gt; &amp;range)
{
    <a href=".././TColumn.html">TColumn</a>* colp = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(label);
    if(colp) {
<b>	// Column exists,fill corresponding memory location with value:</b>
	colp-&gt;SetValue(&amp;value);
	colp-&gt;SetUseDefValue(0);
    }
    else {
<b>	// Create a new Column:</b>
	colp = new IntColumn(label,value,defval,<a href=".././TTuple.html#TTuple:fTree">fTree</a>);
	<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;Add(colp);
    }
    
}

<b>// Make/fill Column-array. Length is fixed at creation time.</b>
<a name="TTuple:Column"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>(const <a href="../ListOfTypes.html#char">char</a>* label,
			const HTAbsValVector&lt;<a href="../ListOfTypes.html#Int_t">Int_t</a>&gt; &amp;vector,
			<a href="../ListOfTypes.html#Int_t">Int_t</a> defval,
			const <a href="../ListOfTypes.html#char">char</a>* block,
			const HTRange&lt;<a href="../ListOfTypes.html#Int_t">Int_t</a>&gt; &amp;range)
{
    <a href=".././TColumn.html">TColumn</a>* colp = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(label);
    if(colp) {
<b>	// Column exists,fill corresponding memory location with value:</b>
	colp-&gt;SetValue(&amp;vector);
	colp-&gt;SetUseDefValue(kFALSE);
    }
    else {
<b>	// Create a new Column:</b>
	colp = new IntArrColumn(label,vector,defval,<a href=".././TTuple.html#TTuple:fTree">fTree</a>);
	<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;Add(colp);
    }
    
}

<b>// Make/fill Column-array. Length is variable and is taken from </b>
<b>// another Column.</b>
<a name="TTuple:Column"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>(const <a href="../ListOfTypes.html#char">char</a>* label,
			const HTAbsValVector&lt;<a href="../ListOfTypes.html#Int_t">Int_t</a>&gt; &amp;vector,
			const <a href="../ListOfTypes.html#char">char</a>* ilab,
			<a href="../ListOfTypes.html#Int_t">Int_t</a> defval,
			const <a href="../ListOfTypes.html#char">char</a>* block,
			const HTRange&lt;<a href="../ListOfTypes.html#Int_t">Int_t</a>&gt; &amp;range)
{
    <a href=".././TColumn.html">TColumn</a>* colp = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(label);
    if(colp) {
<b>	// Column exists,fill corresponding memory location with value:</b>
	colp-&gt;SetValue(&amp;vector,(<a href=".././TColumn.html">TColumn</a>*)<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(ilab));
	colp-&gt;SetUseDefValue(kFALSE);
    }
    else {
<b>	// Create a new branch:</b>
	<a href=".././TColumn.html">TColumn</a>* indexPtr = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(ilab);
	colp = new IntDynArrColumn(label,vector,defval,indexPtr,<a href=".././TTuple.html#TTuple:fTree">fTree</a>);
	<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;Add(colp);
    }
    
}


<b>// ===== = Float type ======</b>
<b>// Make/fill Column with a single value</b>
<a name="TTuple:Column"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>(const <a href="../ListOfTypes.html#char">char</a>* label,
			<a href="../ListOfTypes.html#Float_t">Float_t</a> value,
			<a href="../ListOfTypes.html#Float_t">Float_t</a> defval,
			const <a href="../ListOfTypes.html#char">char</a>* block,
			const HTRange&lt;<a href="../ListOfTypes.html#Float_t">Float_t</a>&gt; &amp;range) 
{
    <a href=".././TColumn.html">TColumn</a>* colp = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(label);
    if(colp) {
<b>	// Column exists,fill corresponding memory location with value:</b>
	colp-&gt;SetValue(&amp;value);
	colp-&gt;SetUseDefValue(0);
    }
    else {
<b>	// Create a new Column:</b>
	colp = new FloatColumn(label,value,defval,<a href=".././TTuple.html#TTuple:fTree">fTree</a>);
	<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;Add(colp);
    }
    
    
}

<b>// Make/fill Column-array. Length is fixed at creation time.</b>
<a name="TTuple:Column"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>(const <a href="../ListOfTypes.html#char">char</a>* label,
			const TVector &amp;vector,
			<a href="../ListOfTypes.html#Float_t">Float_t</a> defval,
			const <a href="../ListOfTypes.html#char">char</a>* block,
			const HTRange&lt;<a href="../ListOfTypes.html#Float_t">Float_t</a>&gt; &amp;range)
{
    <a href=".././TColumn.html">TColumn</a>* colp = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(label);
    if(colp) {
<b>	// Column exists,fill corresponding memory location with value:</b>
	colp-&gt;SetValue(&amp;vector);
	colp-&gt;SetUseDefValue(0);
    }
    else {
<b>	// Create a new Column:</b>
	colp = new FloatArrColumn(label,vector,defval,<a href=".././TTuple.html#TTuple:fTree">fTree</a>);
	<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;Add(colp);
    }
    
    
}

<b>// Make/fill Column-array. Length is variable and is taken from </b>
<b>// another Column.</b>
<a name="TTuple:Column"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>(const <a href="../ListOfTypes.html#char">char</a>* label,
			const TVector &amp;vector,
			const <a href="../ListOfTypes.html#char">char</a> *ilab,
			<a href="../ListOfTypes.html#Float_t">Float_t</a> defval,
			const <a href="../ListOfTypes.html#char">char</a>* block,
			const HTRange&lt;<a href="../ListOfTypes.html#Float_t">Float_t</a>&gt; &amp;range)
{   
    <a href=".././TColumn.html">TColumn</a>* colp = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(label);
    if(colp) {
<b>	// Column exists,fill corresponding memory location with value:</b>
	colp-&gt;SetValue(&amp;vector,(<a href=".././TColumn.html">TColumn</a>*)<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(ilab));
	colp-&gt;SetUseDefValue(0);
    }
    else {
<b>	// Create a new branch:</b>
	<a href=".././TColumn.html">TColumn</a>* indexPtr = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(ilab);
	colp = new FloatDynArrColumn(label,vector,defval,indexPtr,<a href=".././TTuple.html#TTuple:fTree">fTree</a>);
	<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;Add(colp);
    }
    
}

<b>// Make/fill Column-array. Length is fixed at creation time.</b>
<a name="TTuple:Column"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>(const <a href="../ListOfTypes.html#char">char</a>* label,
			const HTAbsValVector&lt;<a href="../ListOfTypes.html#Float_t">Float_t</a>&gt; &amp;vector,
			<a href="../ListOfTypes.html#Float_t">Float_t</a> defval,
			const <a href="../ListOfTypes.html#char">char</a>* block,
			const HTRange&lt;<a href="../ListOfTypes.html#Float_t">Float_t</a>&gt; &amp;range) 
{
    <a href=".././TColumn.html">TColumn</a>* colp = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(label);
    if(colp) {
<b>	// Column exists,fill corresponding memory location with value:</b>
	colp-&gt;SetValue(&amp;vector);
	colp-&gt;SetUseDefValue(kFALSE);
    }
    else {
<b>	// Create a new Column:</b>
	colp = new FloatArrColumn(label,vector,defval,<a href=".././TTuple.html#TTuple:fTree">fTree</a>);
	<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;Add(colp);
    }
    
    
}

<b>// Make/fill Column-array. Length is variable and is taken from </b>
<b>// another Column.</b>
<a name="TTuple:Column"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>(const <a href="../ListOfTypes.html#char">char</a>* label,
			const HTAbsValVector&lt;<a href="../ListOfTypes.html#Float_t">Float_t</a>&gt; &amp;vector,
			const <a href="../ListOfTypes.html#char">char</a> *ilab,
			<a href="../ListOfTypes.html#Float_t">Float_t</a> defval,
			const <a href="../ListOfTypes.html#char">char</a>* block,
			const HTRange&lt;<a href="../ListOfTypes.html#Float_t">Float_t</a>&gt; &amp;range) 
{
    <a href=".././TColumn.html">TColumn</a>* colp = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(label);
    if(colp) {
<b>	// Column exists,fill corresponding memory location with value:</b>
	colp-&gt;SetValue(&amp;vector,(<a href=".././TColumn.html">TColumn</a>*)<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(ilab));
	colp-&gt;SetUseDefValue(kFALSE);
    }
    else {
<b>	// Create a new branch:</b>
	<a href=".././TColumn.html">TColumn</a>* indexPtr = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(ilab);
	colp = new FloatDynArrColumn(label,vector,defval,indexPtr,<a href=".././TTuple.html#TTuple:fTree">fTree</a>);
	<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;Add(colp);
    }
    
}

<b>// ===== = Double type ======</b>
<b>// Make/fill Column with a single value</b>
<a name="TTuple:Column"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>(const <a href="../ListOfTypes.html#char">char</a>* label,
			<a href="../ListOfTypes.html#Double_t">Double_t</a> value,
			<a href="../ListOfTypes.html#Double_t">Double_t</a> defval,
			const <a href="../ListOfTypes.html#char">char</a>* block,
			const HTRange&lt;<a href="../ListOfTypes.html#Double_t">Double_t</a>&gt; &amp;range) 
{
    <a href=".././TColumn.html">TColumn</a>* colp = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(label);
    if(colp) {
<b>	// Column exists,fill corresponding memory location with value:</b>
	colp-&gt;SetValue(&amp;value);
	colp-&gt;SetUseDefValue(0);
    }
    else {
<b>	// Create a new Column:</b>
	colp = new DoubleColumn(label,value,defval,<a href=".././TTuple.html#TTuple:fTree">fTree</a>);
	<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;Add(colp);
    }
    
    
}

<b>// Make/fill Column-array. Length is fixed at creation time.</b>
<a name="TTuple:Column"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>(const <a href="../ListOfTypes.html#char">char</a>* label,
			const HTAbsValVector&lt;<a href="../ListOfTypes.html#Double_t">Double_t</a>&gt; &amp;vector,
			<a href="../ListOfTypes.html#Double_t">Double_t</a> defval,
			const <a href="../ListOfTypes.html#char">char</a>* block,
			const HTRange&lt;<a href="../ListOfTypes.html#Double_t">Double_t</a>&gt; &amp;range)
{ 
    <a href=".././TColumn.html">TColumn</a>* colp = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(label);
    if(colp) {
<b>	// Column exists,fill corresponding memory location with value:</b>
	colp-&gt;SetValue(&amp;vector);
	colp-&gt;SetUseDefValue(kFALSE);
    }
    else {
<b>	// Create a new Column:</b>
	colp = new DoubleArrColumn(label,vector,defval,<a href=".././TTuple.html#TTuple:fTree">fTree</a>);
	<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;Add(colp);
    }
    
    
}

<b>// Make/fill Column-array. Length is variable and is taken from </b>
<b>// another Column.</b>
<a name="TTuple:Column"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>(const <a href="../ListOfTypes.html#char">char</a>* label,
			const HTAbsValVector&lt;<a href="../ListOfTypes.html#Double_t">Double_t</a>&gt; &amp;vector,
			const <a href="../ListOfTypes.html#char">char</a> *ilab,
			<a href="../ListOfTypes.html#Double_t">Double_t</a> defval,
			const <a href="../ListOfTypes.html#char">char</a>* block,
			const HTRange&lt;<a href="../ListOfTypes.html#Double_t">Double_t</a>&gt; &amp;range)
{
    <a href=".././TColumn.html">TColumn</a>* colp = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(label);
    if(colp) {
<b>	// Column exists,fill corresponding memory location with value:</b>
	colp-&gt;SetValue(&amp;vector,(<a href=".././TColumn.html">TColumn</a>*)<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(ilab));
	colp-&gt;SetUseDefValue(kFALSE);
    }
    else {
<b>	// Create a new branch:</b>
	<a href=".././TColumn.html">TColumn</a>* indexPtr = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(ilab);
	colp = new DoubleDynArrColumn(label,vector,defval,indexPtr,<a href=".././TTuple.html#TTuple:fTree">fTree</a>);
	<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;Add(colp);
    }
    
}

<b>// ===== = string Columns ======</b>
<b>// Can actually be variable length in ROOT,N is ignored:</b>
<a name="TTuple:Column"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>(const <a href="../ListOfTypes.html#char">char</a>* label,
			const <a href="../ListOfTypes.html#char">char</a>* value,
			<a href="../ListOfTypes.html#Int_t">Int_t</a> N,
			const <a href="../ListOfTypes.html#char">char</a>* defval,
			const <a href="../ListOfTypes.html#char">char</a>* block)
{
    <a href=".././TColumn.html">TColumn</a>* colp = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(label);
    if(colp) {
<b>	// Branch exists,fill corresponding memory location with value:</b>
	<a href="#TTuple:Column">Column</a>(label,value);
    }
    else {
<b>	// Create a new branch:</b>
	colp = new StringColumn(label,value,defval,<a href=".././TTuple.html#TTuple:fTree">fTree</a>);
	<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;Add(colp);
    }
    
}

<a name="TTuple:Column"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>(const <a href="../ListOfTypes.html#char">char</a>* label,const <a href="../ListOfTypes.html#char">char</a>* value)
{    
    <a href=".././TColumn.html">TColumn</a>* colp = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;FindObject(label);
    if(colp) {
	colp-&gt;SetValue(value);
	colp-&gt;SetUseDefValue(0);
    }
    else {
	cerr &lt;&lt; "<a href=".././TTuple.html#TTuple:Column">TTuple::Column</a>: Column "&lt;&lt; label &lt;&lt; " does not exist" &lt;&lt; endl;
    }
    
}


<b>// Dump all the data into the ntuple and then clear</b>
<a name="TTuple:DumpData"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:DumpData">TTuple::DumpData</a>()
{    
    for (<a href="../ListOfTypes.html#Int_t">Int_t</a> i=0;i&lt;<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;GetSize();i++)
    {
	<a href=".././TColumn.html">TColumn</a> *col = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;At(i);
	if(col-&gt;GetUseDefValue()) col-&gt;SetDefValue();
	col-&gt;SetUseDefValue(1);
    }
    <a href=".././TTuple.html#TTuple:fTree">fTree</a>-&gt;Fill(); 
    
}

<b>// Set all the data to their default values:</b>
<a name="TTuple:ClearData"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:ClearData">TTuple::ClearData</a>() 
{   
    for (<a href="../ListOfTypes.html#Int_t">Int_t</a> i=0;i&lt;<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;GetSize();i++)
    {
	<a href=".././TColumn.html">TColumn</a> *col = (<a href=".././TColumn.html">TColumn</a>*) <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;At(i);
	col-&gt;SetDefValue();
	col-&gt;SetUseDefValue(1);
    }
    return; 
    
}

<b>// Return title of ntuple:</b>
<a name="TTuple:Title"> </a>const <a href="../ListOfTypes.html#char">char</a>* <a href=".././TTuple.html#TTuple:Title">TTuple::Title</a>() const 
{
    return <a href=".././TTuple.html#TTuple:fTree">fTree</a>-&gt;GetTitle();
}

<b>// number of Columns</b>
<a name="TTuple:NColumns"> </a><a href="../ListOfTypes.html#Int_t">Int_t</a> <a href=".././TTuple.html#TTuple:NColumns">TTuple::NColumns</a>() const 
{
    return <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;GetSize();    
}

<b>// Return label for a particular Column with index i:</b>
<a name="TTuple:Label"> </a>const <a href="../ListOfTypes.html#char">char</a>* <a href=".././TTuple.html#TTuple:Label">TTuple::Label</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> i) const 
{
    TString str;
    if(i &gt;= 0 &amp;&amp; i &lt; <a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;GetSize()) str = ((<a href=".././TColumn.html">TColumn</a>*)<a href=".././TTuple.html#TTuple:fMap">fMap</a>-&gt;At(i))-&gt;GetLabel();
    else str = "unknown Column index";
    return str.Data();
    
}

<b>// Print info about ntuple:</b>
<a name="TTuple:PrintOn"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TTuple.html#TTuple:PrintOn">TTuple::PrintOn</a>(std::ostream &amp; o)  const 
{  
    cout &lt;&lt; "<a href=".././TTuple.html">TTuple</a>: ntuple " &lt;&lt; <a href="#TTuple:Title">Title</a>() &lt;&lt; " has " &lt;&lt; <a href="#TTuple:NColumns">NColumns</a>() 
	&lt;&lt; " Columns." &lt;&lt; endl;
    cout &lt;&lt; "Complete printout follows: " &lt;&lt; endl;
    <a href=".././TTuple.html#TTuple:fTree">fTree</a>-&gt;Print(); 
}
</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
