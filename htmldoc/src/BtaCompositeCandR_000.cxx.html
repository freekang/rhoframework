<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:01:58 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>BtaCompositeCandR_000 - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//--------------------------------------------------------------------------</b>
<b>// File and Version Information:</b>
<b>// 	$Id: BtaCompositeCandR_000.cxx.html,v 1.1.1.1 2002-12-20 15:05:30 marcel Exp $</b>
<b>//</b>
<b>// Description:</b>
<b>//</b>
<b>// Environment:</b>
<b>//	Software developed for the BaBar Detector at the SLAC B-Factory.</b>
<b>//</b>
<b>// Author List:</b>
<b>//      Rolf Dubitzky</b>
<b>//</b>
<b>// Copyright Information:</b>
<b>//	Copyright (C) 2000	TU-Dresden</b>
<b>//</b>
<b>//------------------------------------------------------------------------</b>
#include "RhoBase/TRho.h"
#include "RhoBase/TFactory.h"
#include "RhoBase/TCandidate.h"
#include "RhoBase/VAbsVertex.h"
#include "TDatabasePDG.h"

<b>//-----------------------</b>
<b>// This Class's Header --</b>
<b>//-----------------------</b>

#include "KangaSchema/BtaCompositeCandR_000.h"
#include "KangaSchema/BtaAbsVertexR.h"

<b>//-----------------------------------------------------------------------</b>
<b>// Local Macros, Typedefs, Structures, Unions and Forward Declarations --</b>
<b>//-----------------------------------------------------------------------</b>
ClassImp(<a href=".././BtaCompositeCandR_000.html">BtaCompositeCandR_000</a>)


<b>//		-----------------------------------------------</b>
<b>// 		-- Static Data &amp; Function Member Definitions --</b>
<b>//		-----------------------------------------------</b>

<b>//		----------------------------------------</b>
<b>// 		-- Public Function Member Definitions --</b>
<b>//		----------------------------------------</b>

<b>//----------------</b>
<b>// Constructors --</b>
<b>//----------------</b>

<a name="BtaCompositeCandR_000:BtaCompositeCandR_000"> </a><a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:BtaCompositeCandR_000">BtaCompositeCandR_000::BtaCompositeCandR_000</a>()
: <a href=".././BtaCandidateR.html">BtaCandidateR</a>(),
<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_fitParams">_fitParams</a>(),
<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_decayVtx">_decayVtx</a>( 0 ),
<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_pdtEntryPdgId">_pdtEntryPdgId</a>( 0 ),
<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_isAResonance">_isAResonance</a>( kFALSE ),
<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_daughters">_daughters</a>( )
{
<b>    //    cout &lt;&lt; "<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:BtaCompositeCandR_000">BtaCompositeCandR_000::BtaCompositeCandR_000</a>()" &lt;&lt; endl;</b>
}
/*
<a name="BtaCompositeCandR_000:BtaCompositeCandR_000"> </a><a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:BtaCompositeCandR_000">BtaCompositeCandR_000::BtaCompositeCandR_000</a>( const BtaCandidate* transCand ,
RooEvtObjLocReg&amp; aRegistry )
: <a href=".././BtaCandidateR.html">BtaCandidateR</a>(),
<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_fitParams">_fitParams</a>( transCand-&gt;content()-&gt;fitParams() ),
<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_decayVtx">_decayVtx</a>( 0 ),
<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_pdtEntryPdgId">_pdtEntryPdgId</a>( 0 ),
<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_isAResonance">_isAResonance</a>( transCand-&gt;isAResonance() ),
<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_daughters">_daughters</a>( )
{
<b>// Store the location of this object, and the appropriate BtaCandBase,</b>
<b>//    into the registry.</b>
<b>//    cout &lt;&lt; "<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:BtaCompositeCandR_000">BtaCompositeCandR_000::BtaCompositeCandR_000</a>(cand,reg)" &lt;&lt; endl;</b>
assert( transCand==transCand-&gt;thisCandidate() );
registerThis( transCand, aRegistry );
<b>//    cout &lt;&lt; "      registered"&lt;&lt; "  RefToMe: "&lt;&lt;refToMe().id() &lt;&lt; endl;</b>

<b>  // Even if we have a vertex, we only store it if</b>
<b>  //      i) we are not a resonance</b>
<b>  // OR  ii) we are a resonance, and the mother has NOT been persisted</b>
  
    <a href=".././BtaAbsVertexR.html">BtaAbsVertexR</a> *vertex( 0 );
    const BtaAbsVertex *toBePersisted( 0 );
    if ( !transCand-&gt;isAResonance() ) 
    {
    toBePersisted = transCand-&gt;decayVtx();
    } else {
<b>    //        cout &lt;&lt; " CompositeCand is a resonace : " &lt;&lt; transCand-&gt;pdtEntry()-&gt;name()&lt;&lt;endl;</b>
    const BtaCandidate *x= transCand-&gt;theMother();
    if ( x==0 || aRegistry.find( x-&gt;thisCandidate() )==0 ) 
    {
    toBePersisted=transCand-&gt;decayVtx();
    }
    }
    
      if ( toBePersisted!=0 ) 
      {
      <a href=".././RooRef.html">RooRef</a> aVtxRef = aRegistry.find( toBePersisted );
      if ( aVtxRef.id() == 0 ) 
      {
      BtaVertexRooPersister p;
      p.setRegistry( aRegistry );
      toBePersisted-&gt;persist( p );
      vertex = p.getCreation();
<b>      //            cout &lt;&lt; "    persisted Vertex " &lt;&lt; vertex &lt;&lt; endl;</b>
      } else {
<b>      //            cout &lt;&lt; "    Already persisted this Vtx   "&lt;&lt; aVtxRef.ref() &lt;&lt;endl;</b>
      vertex = const_cast&lt;<a href=".././BtaAbsVertexR.html">BtaAbsVertexR</a>*&gt;(static_cast&lt;const <a href=".././BtaAbsVertexR.html">BtaAbsVertexR</a>*&gt;(  aVtxRef.ref() ) );
      }
      }
      
	<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_decayVtx">_decayVtx</a> = vertex;
	}
*/

<b>//--------------</b>
<b>// Destructor --</b>
<b>//--------------</b>

<a name="BtaCompositeCandR_000:~BtaCompositeCandR_000"> </a><a href=".././BtaCompositeCandR_000.html">BtaCompositeCandR_000</a>::~<a href=".././BtaCompositeCandR_000.html">BtaCompositeCandR_000</a>()
{
}

<b>//-------------</b>
<b>// Operators --</b>
<b>//-------------</b>

<b>//-------------</b>
<b>// Selectors --</b>
<b>//-------------</b>

TCandidate*
<a name="BtaCompositeCandR_000:Transient"> </a><a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:Transient">BtaCompositeCandR_000::Transient</a>() const
{
    const TFitParams *fitParams = <a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_fitParams">_fitParams</a>.<a href=".././BtaFitParamsR.html#BtaFitParamsR:Transient">Transient</a>();
    TCandidate* transient = TFactory::NewCandidate(*fitParams,refToMe().id());
    delete fitParams;
    if ( <a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_pdtEntryPdgId">_pdtEntryPdgId</a> != 0) {
	static TDatabasePDG *pdt = TRho::Instance()-&gt;GetPDG();
	transient-&gt;SetType(pdt-&gt;GetParticle(<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_pdtEntryPdgId">_pdtEntryPdgId</a>));
    }

/*
<b>    // Id</b>
    cout &lt;&lt; "<a href=".././BtaCompositeCandR_000.html">BtaCompositeCandR_000</a> RefToMe: "&lt;&lt;refToMe().id() &lt;&lt; endl;
    
<b>    // Daughters</b>
    <a href="../ListOfTypes.html#int">int</a> i;
    for (i=0;i&lt;<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_daughters">_daughters</a>.<a href=".././RooValArray.html#RooValArray:length">length</a>();++i)
    {
	cout &lt;&lt; " daughter["&lt;&lt;i&lt;&lt;"] = "&lt;&lt; <a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_daughters">_daughters</a>[i]&lt;&lt;endl;
    }

<b>    //Vertex</b>
    if (<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_decayVtx">_decayVtx</a> != 0)
       cout &lt;&lt; "<a href=".././BtaCompositeCandR_000.html">BtaCompositeCandR_000</a> Vertex: "&lt;&lt;<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_decayVtx">_decayVtx</a>-&gt;refToMe().id() &lt;&lt; endl;
*/    
    return transient;
    
}
/*
<a href="../ListOfTypes.html#bool">bool</a>
<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:fillPointers">BtaCompositeCandR_000::fillPointers</a>( BtaCandidate* transCand,
const RooEvtObjLocReg&amp; aRegistry ) const
{
<b>//    cout &lt;&lt; "<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:fillPointers">BtaCompositeCandR_000::fillPointers</a> " &lt;&lt; endl;</b>

<b>  //     cout &lt;&lt; "    my OID: " &lt;&lt; refToMe().id() </b>
<b>  //          &lt;&lt; "  trans UID: " &lt;&lt;  transCand-&gt;uid()</b>
<b>  //          &lt;&lt; "  pdt: " &lt;&lt; (transCand-&gt;pdtEntry()?transCand-&gt;pdtEntry()-&gt;name():" none")</b>
<b>  //          &lt;&lt; endl;</b>
  
    if ( ( <a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_daughters">_daughters</a>.<a href=".././RooValArray.html#RooValArray:length">length</a>()&gt;0 ) &amp;&amp;
    ( transCand-&gt;nDaughters()==0 ) ) // protect against <a href="../ListOfTypes.html#double">double</a> filling
    {
<b>    //        cout &lt;&lt; "   adding daughters: " &lt;&lt; endl;</b>
<b>    // If the persistent object has daughters and the transient object</b>
<b>    //   has none, then set the daughters using the registry.</b>
    <a href="../ListOfTypes.html#int">int</a> i;
    for (i=0;i&lt;<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_daughters">_daughters</a>.<a href=".././RooValArray.html#RooValArray:length">length</a>();++i)
    {
<b>    //            cout &lt;&lt; " daughter["&lt;&lt;i&lt;&lt;"] = "&lt;&lt; <a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_daughters">_daughters</a>[i]&lt;&lt;endl;</b>
    <a href=".././RooRef.html">RooRef</a> childLocation( <a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_daughters">_daughters</a>[i] );
    BtaCandidate* transDaughter = const_cast&lt; BtaCandidate* &gt;(
    static_cast&lt;const BtaCandidate*&gt;( aRegistry.find( childLocation ) ));
    if ( transDaughter==0 ) 
    {
    ErrMsg(fatal) &lt;&lt; " a persistent BtaCand (oid=" &lt;&lt; <a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_daughters">_daughters</a>[i] 
    &lt;&lt; ") doesn't have a transient in registryn " 
    &lt;&lt; " Please make sure all needed lists are read back... " &lt;&lt; endmsg;
    } else {
    transCand-&gt;addDaughterLink( transDaughter );
    }
    }
    }
    
<b>      //  need to set Vertex _AFTER_ daughtes, so that daughters can become outgoings</b>
      if ( <a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_decayVtx">_decayVtx</a> != 0 &amp;&amp; 
      transCand-&gt;decayVtx()==0 ) // protect against <a href="../ListOfTypes.html#double">double</a> filling
      {
      BtaAbsVertex* transientVertex = const_cast&lt;BtaAbsVertex*&gt;(
      static_cast&lt; const BtaAbsVertex* &gt;( aRegistry.find( <a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_decayVtx">_decayVtx</a>-&gt;refToMe() ) ) );
      if ( !transientVertex )
      {
      RooEvtObjLocReg&amp; non_const_Registry = const_cast&lt; RooEvtObjLocReg&amp; &gt;( aRegistry );
      transientVertex = <a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_decayVtx">_decayVtx</a>-&gt;transient( non_const_Registry );
      }
      transCand-&gt;setDecayVtx( transientVertex );
      }
      
	return ( true ) ;
	}
	
<b>	  //-------------</b>
<b>	  // Modifiers --</b>
<b>	  //-------------</b>
	  
	    <a href="../ListOfTypes.html#bool">bool</a>
	    <a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:fillRefs">BtaCompositeCandR_000::fillRefs</a>( const BtaCandidate* transCand ,
	    const RooEvtObjLocReg&amp; aRegistry)
	    {
<b>	    //    cout &lt;&lt; "<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:fillRefs">BtaCompositeCandR_000::fillRefs</a>"&lt;&lt;endl;</b>
	    
<b>	      //////////////////////////</b>
<b>	      // Particle ID information</b>
	      const PdtEntry* pdtEntry( transCand-&gt;pdtEntry() ) ;
	      if ( 0 != pdtEntry ) {
	      
<b>		//         cout &lt;&lt; "    my OID: " &lt;&lt; refToMe().id() </b>
<b>		//              &lt;&lt; "  trans UID: " &lt;&lt;  transCand-&gt;uid()</b>
<b>		//              &lt;&lt; "  pdt: " &lt;&lt; pdtEntry-&gt;name()</b>
<b>		//              &lt;&lt; endl;</b>
<b>		// If there is a valid PDT entry set the PGD</b>
		<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_pdtEntryPdgId">_pdtEntryPdgId</a> = (<a href="../ListOfTypes.html#int">int</a>)pdtEntry-&gt;pdgId() ;
		}
<b>		// !!RD debug  -- exxhange with above</b>
<b>		//  <a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_pdtEntryPdgId">_pdtEntryPdgId</a> = transCand-&gt;dtEntry() ? (<a href="../ListOfTypes.html#int">int</a>)transCand-&gt;pdtEntry()-&gt;pdgId() : 0;</b>
		
<b>		  /////////////////////////////////////////////////////////</b>
<b>		  // loop over all daughters and add references to the list</b>
<b>		  //      of daughter references</b>
		  if ( <a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_daughters">_daughters</a>.<a href=".././RooValArray.html#RooValArray:length">length</a>() &gt; 0 &amp;&amp; <a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_daughters">_daughters</a>.<a href=".././RooValArray.html#RooValArray:length">length</a>() != transCand-&gt;nDaughters() )
		  cout &lt;&lt; "<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:fillRefs">BtaCompositeCandR_000::fillRefs</a> :: filled already with different "
		  &lt;&lt; "Ndaughters ... something is fishy"&lt;&lt;endl;
		  
		    if ( 0 != transCand-&gt;nDaughters() &amp;&amp;
		    <a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_daughters">_daughters</a>.<a href=".././RooValArray.html#RooValArray:length">length</a>() != transCand-&gt;nDaughters() ) {
		    
<b>		      // If BtaCandCand has daughters the link up <a href=".././BtaCompositeCandR_000.html">BtaCompositeCandR_000</a> objects</b>
		      HepAListIterator&lt; BtaCandidate &gt; children( transCand-&gt;daughterIterator() ) ;
		      const BtaCandidate* child;
		      while ( child = children() ) {
		      
<b>			// For each daughter look up Location.</b>
			<a href=".././RooRef.html">RooRef</a> childLocation = aRegistry.find( child-&gt;thisCandidate() );
			if( 0 != childLocation.id() ) {
			<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:_daughters">_daughters</a>.<a href=".././RooValArray.html#RooValArray:append">append</a>( childLocation.id() );
<b>			//                 cout &lt;&lt; " adding daughter: OID: "&lt;&lt;childLocation.id()</b>
<b>			//                      &lt;&lt; "  pdt: " &lt;&lt; child-&gt;pdtEntry()-&gt;name()</b>
<b>			//                      &lt;&lt;endl;</b>
			} else {
			ErrMsg( fatal ) &lt;&lt; "  daughter has not been persisted! " &lt;&lt; endmsg;
			continue;
			}
			}
			} else {
<b>			//        cout &lt;&lt; "    no daughters"&lt;&lt;endl;</b>
			}
			
			  return ( true ) ;
			  }
			  
<b>			    // Operators</b>
			    const <a href=".././BtaCompositeCandR_000.html">BtaCompositeCandR_000</a>&amp; 
			    <a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:operator">BtaCompositeCandR_000::operator</a>= ( const <a href=".././BtaCompositeCandR_000.html">BtaCompositeCandR_000</a>&amp; o ) 
			    {
<b>			    //    cout &lt;&lt; "<a href=".././BtaCompositeCandR_000.html#BtaCompositeCandR_000:operator">BtaCompositeCandR_000::operator</a>=   do I need this?!"&lt;&lt;endl;</b>
			    abort(); // let's see
			    return (*this);
			    }
</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
