<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:03:11 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TPerceptron - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//////////////////////////////////////////////////////////////////////////</b>
<b>//									//</b>
<b>// <a href=".././TPerceptron.html">TPerceptron</a>								//</b>
<b>//									//</b>
<b>// Implementation of the perceptron (Supervised Learning)		//</b>
<b>// Part of the Neural Network Objects package (NNO)			//</b>
<b>//									//</b>
<b>// Author List:								//</b>
<b>// Johannes Steffens, Bochum University					//</b>
<b>// M.Kunze, Bochum University						//</b>
<b>// (C) Copyright Johannes Steffens 1995, Ruhr-University Bochum.	//</b>
<b>//									//	 </b>
<b>//////////////////////////////////////////////////////////////////////////	 </b>

#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

#include "RhoNNO/TPerceptron.h"

ClassImp(TPerceptron)

<b>// Transferfunctions</b>
<a href="../ListOfTypes.html#void">void</a> TransferFermi(<a href="../ListOfTypes.html#Double_t">Double_t</a> in,<a href="../ListOfTypes.html#Double_t">Double_t</a>* out,<a href="../ListOfTypes.html#Double_t">Double_t</a>* deriv) 
{
    if (in &lt; -10.0) in = -10.0;
    if (in &gt;  10.0) in =  10.0;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> O = 1. / (1. + exp(-in));
    *out   = O;
    *deriv = O * (1. - O);
}

<a href="../ListOfTypes.html#void">void</a> TransferSigmoid(<a href="../ListOfTypes.html#Double_t">Double_t</a> in,<a href="../ListOfTypes.html#Double_t">Double_t</a>* out,<a href="../ListOfTypes.html#Double_t">Double_t</a>* deriv) 
{
    if (in &lt; -10.0) in = -10.0;
    if (in &gt;  10.0) in =  10.0;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> O = 1. - 2. / (1. + exp(-in));
    *out   = O;
    *deriv = 2. * O * (1. - O);
}

<a href="../ListOfTypes.html#void">void</a> TransferLinear(<a href="../ListOfTypes.html#Double_t">Double_t</a> in,<a href="../ListOfTypes.html#Double_t">Double_t</a>* out,<a href="../ListOfTypes.html#Double_t">Double_t</a>* deriv) 
{
    *out = in;
    *deriv = 1.0;
}

<a href="../ListOfTypes.html#void">void</a> TransferLinearBend(<a href="../ListOfTypes.html#Double_t">Double_t</a> in,<a href="../ListOfTypes.html#Double_t">Double_t</a>* out,<a href="../ListOfTypes.html#Double_t">Double_t</a>* deriv) 
{
    if (in &lt; -1.0) {
	*out = -0.9 + in * 0.1;
	*deriv = 0.1;
    } else
	if (in &gt; 1.0) {
	    *out = 0.9 + in * 0.1;
	    *deriv = 0.1;
	} else {
	    *out = in;
	    *deriv = 1.0;
	}
}

<a name="TPerceptron:TPerceptron"> </a><a href=".././TPerceptron.html#TPerceptron:TPerceptron">TPerceptron::TPerceptron</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> inNodes,
			 <a href="../ListOfTypes.html#Int_t">Int_t</a> outNodes,
			 <a href="../ListOfTypes.html#Double_t">Double_t</a> learnStep,
			 <a href=".././TNeuralNetParameters.html#TNeuralNetParameters:TRANSFER">TNeuralNetParameters::TRANSFER</a> transferId,
			 <a href="../ListOfTypes.html#Int_t">Int_t</a> perceptronId) 
{
    
    <a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes      = inNodes;
    <a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes     = outNodes;
    <a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fLearnStep    = learnStep;
    <a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fTransferId   = transferId;
    <a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fPerceptronId = perceptronId;
    <a href=".././TPerceptron.html#TPerceptron:fPrev">fPrev</a>     = 0;
    <a href="#TPerceptron:AllocNet">AllocNet</a>();
    <a href="#TPerceptron:InitNet">InitNet</a>();
}

<a name="TPerceptron:TPerceptron"> </a><a href=".././TPerceptron.html#TPerceptron:TPerceptron">TPerceptron::TPerceptron</a>(<a href=".././TPerceptron.html">TPerceptron</a>* prev,
			 <a href="../ListOfTypes.html#Int_t">Int_t</a> outNodes,
			 <a href="../ListOfTypes.html#Double_t">Double_t</a> learnStep,
			 <a href=".././TNeuralNetParameters.html#TNeuralNetParameters:TRANSFER">TNeuralNetParameters::TRANSFER</a> transferId,
			 <a href="../ListOfTypes.html#Int_t">Int_t</a> perceptronId) 
{
    
    <a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes      = prev-&gt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes;
    <a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes     = outNodes;
    <a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fLearnStep    = learnStep;
    <a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fTransferId   = transferId;
    <a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fPerceptronId = perceptronId;
    <a href=".././TPerceptron.html#TPerceptron:fPrev">fPrev</a>             = prev;
    <a href="#TPerceptron:AllocNet">AllocNet</a>();
    <a href="#TPerceptron:InitNet">InitNet</a>();
}

<a name="TPerceptron:TPerceptron"> </a><a href=".././TPerceptron.html#TPerceptron:TPerceptron">TPerceptron::TPerceptron</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././TPerceptron.html#TPerceptron:fPrev">fPrev</a> = 0;
}

<a name="TPerceptron:TPerceptron"> </a><a href=".././TPerceptron.html#TPerceptron:TPerceptron">TPerceptron::TPerceptron</a>(<a href=".././TPerceptron.html">TPerceptron</a>* prev) 
{
    <a href=".././TPerceptron.html#TPerceptron:fPrev">fPrev</a> = prev;
}

<a name="TPerceptron:AllocNet"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TPerceptron.html#TPerceptron:AllocNet">TPerceptron::AllocNet</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href="../ListOfTypes.html#int">int</a> I;
    <a href=".././TPerceptron.html#TPerceptron:fU">fU</a>       = new PerceptronUnit[<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes]; TestPointer(<a href=".././TPerceptron.html#TPerceptron:fU">fU</a>);
    <a href=".././TPerceptron.html#TPerceptron:fOut">fOut</a>     = new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes]; TestPointer(<a href=".././TPerceptron.html#TPerceptron:fOut">fOut</a>);
    <a href=".././TPerceptron.html#TPerceptron:fDiffSrc">fDiffSrc</a> = new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes]; TestPointer(<a href=".././TPerceptron.html#TPerceptron:fDiffSrc">fDiffSrc</a>);
    if (<a href=".././TPerceptron.html#TPerceptron:fPrev">fPrev</a> == 0) {
	<a href=".././TPerceptron.html#TPerceptron:fIn">fIn</a>      = new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes]; TestPointer(<a href=".././TPerceptron.html#TPerceptron:fIn">fIn</a>);
	<a href=".././TPerceptron.html#TPerceptron:fDiffDst">fDiffDst</a> = 0;
    } else {
	<a href=".././TPerceptron.html#TPerceptron:fIn">fIn</a>      = <a href=".././TPerceptron.html#TPerceptron:fPrev">fPrev</a>-&gt;<a href=".././TPerceptron.html#TPerceptron:fOut">fOut</a>;
	<a href=".././TPerceptron.html#TPerceptron:fDiffDst">fDiffDst</a> = <a href=".././TPerceptron.html#TPerceptron:fPrev">fPrev</a>-&gt;<a href=".././TPerceptron.html#TPerceptron:fDiffSrc">fDiffSrc</a>;
    }
    <a href=".././TPerceptron.html#TPerceptron:fUbound">fUbound</a> = &amp;<a href=".././TPerceptron.html#TPerceptron:fU">fU</a>[<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes];
    PerceptronUnit* up = <a href=".././TPerceptron.html#TPerceptron:fU">fU</a>;
    for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes;++I) {
	up-&gt;fVector = new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes]; 
	TestPointer(up-&gt;fVector);
	up-&gt;fDelta = new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes]; 
	TestPointer(up-&gt;fDelta);
	up-&gt;fThreshold = 0;
	up-&gt;fID = I;
	++up;
    }
    switch (<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fTransferId) {
    case <a href=".././TNeuralNetParameters.html#TNeuralNetParameters:TR_FERMI">TNeuralNetParameters::TR_FERMI</a>  :      <a href=".././TPerceptron.html#TPerceptron:Transfer">Transfer</a>=TransferFermi;      break;
    case <a href=".././TNeuralNetParameters.html#TNeuralNetParameters:TR_SIGMOID">TNeuralNetParameters::TR_SIGMOID</a>:      <a href=".././TPerceptron.html#TPerceptron:Transfer">Transfer</a>=TransferSigmoid;      break;
    case <a href=".././TNeuralNetParameters.html#TNeuralNetParameters:TR_LINEAR">TNeuralNetParameters::TR_LINEAR</a> :      <a href=".././TPerceptron.html#TPerceptron:Transfer">Transfer</a>=TransferLinear;     break;
    case <a href=".././TNeuralNetParameters.html#TNeuralNetParameters:TR_LINEAR_BEND">TNeuralNetParameters::TR_LINEAR_BEND</a>:  <a href=".././TPerceptron.html#TPerceptron:Transfer">Transfer</a>=TransferLinearBend; break;
    default:             <a href=".././TPerceptron.html#TPerceptron:Transfer">Transfer</a>=0;
    }
}

<a name="TPerceptron:InitNet"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TPerceptron.html#TPerceptron:InitNet">TPerceptron::InitNet</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    PerceptronUnit* up;
    <a href="../ListOfTypes.html#int">int</a> J;
    for(up=<a href=".././TPerceptron.html#TPerceptron:fU">fU</a>;up&lt;<a href=".././TPerceptron.html#TPerceptron:fUbound">fUbound</a>;++up) {
	for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++J) {
	    up-&gt;fVector[J] = Random();
	    up-&gt;fDelta[J]  = 0.0;
	}
	up-&gt;fThreshold = Random();
    }
}


<a href=".././TPerceptron.html">TPerceptron</a> ::~<a href=".././TPerceptron.html">TPerceptron</a>() 
{
    PerceptronUnit* up = <a href=".././TPerceptron.html#TPerceptron:fU">fU</a>;
    if (<a href=".././TPerceptron.html#TPerceptron:fU">fU</a>!=0)  {
	for(up=<a href=".././TPerceptron.html#TPerceptron:fU">fU</a>;up&lt;<a href=".././TPerceptron.html#TPerceptron:fUbound">fUbound</a>;++up) {
	    delete[] up-&gt;fVector;
	    delete[] up-&gt;fDelta;
	}
	delete[] <a href=".././TPerceptron.html#TPerceptron:fU">fU</a>;
    }
    delete[] <a href=".././TPerceptron.html#TPerceptron:fOut">fOut</a>;
    delete[] <a href=".././TPerceptron.html#TPerceptron:fDiffSrc">fDiffSrc</a>;
    if (<a href=".././TPerceptron.html#TPerceptron:fPrev">fPrev</a>==0) delete[] <a href=".././TPerceptron.html#TPerceptron:fIn">fIn</a>;
}


<a name="TPerceptron:WriteBinary"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TPerceptron.html#TPerceptron:WriteBinary">TPerceptron::WriteBinary</a>() 
{
    PerceptronUnit* up;
    fwrite(&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>,sizeof(PerceptronBase),1,<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>);
    for(up=<a href=".././TPerceptron.html#TPerceptron:fU">fU</a>;up&lt;<a href=".././TPerceptron.html#TPerceptron:fUbound">fUbound</a>;++up) {
	fwrite(up-&gt;fVector,sizeof(<a href="../ListOfTypes.html#Double_t">Double_t</a>),<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes,<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>);
	fwritevar(up-&gt;fThreshold);
	fwritevar(up-&gt;fID);
    }
}

<a name="TPerceptron:ReadBinary"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TPerceptron.html#TPerceptron:ReadBinary">TPerceptron::ReadBinary</a>() 
{
    PerceptronUnit* up;
    fread(&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>,sizeof(PerceptronBase),1,<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>);
    <a href="#TPerceptron:AllocNet">AllocNet</a>();
    for(up=<a href=".././TPerceptron.html#TPerceptron:fU">fU</a>;up&lt;<a href=".././TPerceptron.html#TPerceptron:fUbound">fUbound</a>;++up) {
	fread(up-&gt;fVector,sizeof(<a href="../ListOfTypes.html#Double_t">Double_t</a>),<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes,<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>);
	freadvar(up-&gt;fThreshold);
	freadvar(up-&gt;fID);
    }
}

<a name="TPerceptron:WriteText"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TPerceptron.html#TPerceptron:WriteText">TPerceptron::WriteText</a>() 
{
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nPerceptron ID %in",<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fPerceptronId);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"innodes     %in",<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"outnodes    %in",<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"learn_step  %len",<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fLearnStep);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"transfer_id %in",<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fTransferId);
    PerceptronUnit* up;
    <a href="../ListOfTypes.html#int">int</a> I;
    for(up=<a href=".././TPerceptron.html#TPerceptron:fU">fU</a>;up&lt;<a href=".././TPerceptron.html#TPerceptron:fUbound">fUbound</a>;++up) {
	fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"n");
	fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"unit number      %in",up-&gt;fID);
	fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"threshold        %len",up-&gt;fThreshold);
	fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"weightsn");
	for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++I) fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"%len",up-&gt;fVector[I]);
	fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"n");
    }
}

<a name="TPerceptron:ReadText"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TPerceptron.html#TPerceptron:ReadText">TPerceptron::ReadText</a>() 
{
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nPerceptron ID %in",&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fPerceptronId);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"innodes     %in",&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"outnodes    %in",&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"learn_step  %len",&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fLearnStep);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"transfer_id %in",&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fTransferId);
    <a href="#TPerceptron:AllocNet">AllocNet</a>();
    PerceptronUnit* up;
    <a href="../ListOfTypes.html#int">int</a> I;
    for(up=<a href=".././TPerceptron.html#TPerceptron:fU">fU</a>;up&lt;<a href=".././TPerceptron.html#TPerceptron:fUbound">fUbound</a>;++up) {
	fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"n");
	fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"unit number      %in",&amp;up-&gt;fID);
	fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"threshold        %len",&amp;up-&gt;fThreshold);
	fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"weightsn");
	for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++I) fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"%len",&amp;up-&gt;fVector[I]);
	fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"n");
    }
}

<a name="TPerceptron:Recall"> </a><a href="../ListOfTypes.html#Double_t">Double_t</a>* <a href=".././TPerceptron.html#TPerceptron:Recall">TPerceptron::Recall</a>(<a href="../ListOfTypes.html#NNO_INTYPE">NNO_INTYPE</a>* in,<a href="../ListOfTypes.html#NNO_OUTTYPE">NNO_OUTTYPE</a>* out) 
{
    <a href="../ListOfTypes.html#int">int</a> I;
    PerceptronUnit* up;
    <a href="../ListOfTypes.html#Double_t">Double_t</a>* o = <a href=".././TPerceptron.html#TPerceptron:fOut">fOut</a>;
    <a href="../ListOfTypes.html#Double_t">Double_t</a>* ds = <a href=".././TPerceptron.html#TPerceptron:fDiffSrc">fDiffSrc</a>;
    if (<a href=".././TPerceptron.html#TPerceptron:Transfer">Transfer</a>==0) Errorf("(<a href=".././TPerceptron.html">TPerceptron</a>) undefined transferfunction");
    for(up=<a href=".././TPerceptron.html#TPerceptron:fU">fU</a>;up&lt;<a href=".././TPerceptron.html#TPerceptron:fUbound">fUbound</a>;++up) {
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* v = up-&gt;fVector;
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* i = <a href=".././TPerceptron.html#TPerceptron:fIn">fIn</a>;
	<a href="../ListOfTypes.html#Double_t">Double_t</a>  sum = 0.0;
	for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++I) sum += *i++ * *v++;
	sum -= up-&gt;fThreshold;
	<a href=".././TPerceptron.html#TPerceptron:Transfer">Transfer</a>(sum,o++,ds++);
    }

    return o;
}

<a name="TPerceptron:Train"> </a><a href="../ListOfTypes.html#Double_t">Double_t</a> <a href=".././TPerceptron.html#TPerceptron:Train">TPerceptron::Train</a>(<a href="../ListOfTypes.html#NNO_INTYPE">NNO_INTYPE</a>* in,<a href="../ListOfTypes.html#NNO_OUTTYPE">NNO_OUTTYPE</a>* out) 
{
    <a href="../ListOfTypes.html#int">int</a> I;
    PerceptronUnit* up;
    <a href="../ListOfTypes.html#Double_t">Double_t</a>* ds;
    
<b>    // modify weights</b>
    ds = <a href=".././TPerceptron.html#TPerceptron:fDiffSrc">fDiffSrc</a>;
    for(up=<a href=".././TPerceptron.html#TPerceptron:fU">fU</a>;up&lt;<a href=".././TPerceptron.html#TPerceptron:fUbound">fUbound</a>;++up) {
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* i = <a href=".././TPerceptron.html#TPerceptron:fIn">fIn</a>;
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* v = up-&gt;fVector;
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* m = up-&gt;fDelta;
	for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++I) {
	    <a href="../ListOfTypes.html#Double_t">Double_t</a> delta = *i++ * *ds;
	    *v++ += (delta + (*m * <a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fMu)) * <a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fLearnStep;
	    *m++ = delta;
	}
	up-&gt;fThreshold -= *ds * <a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fLearnStep;
	++ds;
    }
    
<b>    // propagate derivation backward if previous perceptron exists</b>
    if (<a href=".././TPerceptron.html#TPerceptron:fDiffDst">fDiffDst</a>!=0) {
	<a href="../ListOfTypes.html#Double_t">Double_t</a> diff;
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* dd = <a href=".././TPerceptron.html#TPerceptron:fDiffDst">fDiffDst</a>;
	for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++I) {
	    diff = 0.0;
	    ds = <a href=".././TPerceptron.html#TPerceptron:fDiffSrc">fDiffSrc</a>;
	    for(up=<a href=".././TPerceptron.html#TPerceptron:fU">fU</a>;up&lt;<a href=".././TPerceptron.html#TPerceptron:fUbound">fUbound</a>;++up) diff += up-&gt;fVector[I] * *ds++;
	    *dd++ *= diff;
	}
    }
    
    return 0.0;
}


</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
