<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:02:56 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TGCS - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//////////////////////////////////////////////////////////////////////////</b>
<b>//									//</b>
<b>// <a href=".././TGCS.html">TGCS</a>									//</b>
<b>//									//</b>
<b>// Implementation of the GROWING-CELL-STRUCTURE (GCS)			//</b>
<b>// Part of the Neural Network Objects package (NNO)			//</b>
<b>//									//</b>
<b>// Author List:								//</b>
<b>// Johannes Steffens, Bochum University					//</b>
<b>// M.Kunze, Bochum University						//</b>
<b>// (C) Copyright Johannes Steffens 1995, Ruhr-University Bochum.	//</b>
<b>//									//</b>
<b>//////////////////////////////////////////////////////////////////////////</b>

#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;float.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;
#include "RhoNNO/TGCS.h"
#include "RhoNNO/VNeuralNetPlotter.h"

ClassImp(TGCS)

<b>//cell states</b>
#define REMOVE 1

<a name="TGCS:TGCS"> </a>TGCS::TGCS (Int_t innodes,Int_t cells,Int_t maxCells,Double_t winStep,Double_t neiStep,
	    Double_t aWinCount,Int_t connectors,
	    Long_t insertStep,Long_t deleteStep,const char* netFile)
	    : VUnsupervisedNet("GCS",innodes,maxCells,netFile) 
{
    fXB.fCells       = cells;
    fXB.fMinCells    = cells;
    fXB.fWinStep     = winStep;
    fXB.fNeiStep     = neiStep;
    fXB.fWinCount    = aWinCount;
    fXB.fConnectors  = connectors;
    fXB.fInsertStep  = insertStep;
    fXB.fDeleteStep  = deleteStep;
    fXB.fInsertCount = 0;
    fXB.fDeleteCount = 0;
    fU               = 0;
    AllocNet();
    InitNet();
}

<b>// copy constructor</b>
<a name="TGCS:TGCS"> </a><a href=".././TGCS.html#TGCS:TGCS">TGCS::TGCS</a>(const <a href=".././TGCS.html">TGCS</a>&amp; gcs,const <a href="../ListOfTypes.html#char">char</a>* netFile)
: <a href=".././VUnsupervisedNet.html">VUnsupervisedNet</a>("GCS",gcs.<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes,gcs.<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes,netFile) 
{
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a> = gcs.<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>;
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>  = 0;
    <a href="#TGCS:AllocNet">AllocNet</a>();
    <a href="#TGCS:InitNet">InitNet</a>();
    <a href="#TGCS:CopyData">CopyData</a>(gcs);
}

<a name="TGCS:~TGCS"> </a><a href=".././TGCS.html">TGCS</a>::~<a href=".././TGCS.html">TGCS</a>() 
{
    <a href="#TGCS:Deviation">Deviation</a>();
    if (<a href=".././VNeuralNet.html#VNeuralNet:fFilename">fFilename</a>!="") if (<a href=".././VNeuralNet.html#VNeuralNet:fShouldSave">fShouldSave</a>) Save();
    if (<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a> != 0) {
	<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
	for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGCS.html#TGCS:fUbound">fUbound</a>;++up) {
	    delete[] up-&gt;fVector;
	    delete[] up-&gt;fDiff;
	    delete[] up-&gt;fC;
	}
	delete[] <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;
    }
}

<a name="TGCS:ReadBinary"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGCS.html#TGCS:ReadBinary">TGCS::ReadBinary</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a> = 0;
    fread(&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>,sizeof(<a href=".././TNeuralNetCellParameters.html">TNeuralNetCellParameters</a>),1,<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>);
    <a href="#TGCS:AllocNet">AllocNet</a>();
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGCS.html#TGCS:fUbound">fUbound</a>;++up) {
	<a href=".././TNeuralNetCell.html#TNeuralNetCell:ReadUnitBinary">TNeuralNetCell::ReadUnitBinary</a>(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
	freadvar(up-&gt;fClass);
	for (I=0;I&lt;up-&gt;fNc;++I) up-&gt;fC[I].fPtr=&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>[up-&gt;fC[I].fID];
    }
}

<a name="TGCS:ReadText"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGCS.html#TGCS:ReadText">TGCS::ReadText</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a> = 0;
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"win_step    %len",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fWinStep);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"new_step    %len",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fNeiStep);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"a_win_count %len",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fWinCount);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"cells       %in",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"min_cells   %in",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMinCells);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"connectors  %in",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fConnectors);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"insert_step %lin",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fInsertStep);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"delete_step %lin",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fDeleteStep);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"ins_count   %lin",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fInsertCount);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"del_count   %lin",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fDeleteCount);
    
    <a href="#TGCS:AllocNet">AllocNet</a>();
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGCS.html#TGCS:fUbound">fUbound</a>;++up) {
	<a href=".././TNeuralNetCell.html#TNeuralNetCell:ReadUnitText">TNeuralNetCell::ReadUnitText</a>(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
	fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nclass            %in",&amp;up-&gt;fClass);
	for (I=0;I&lt;up-&gt;fNc;++I) 
	    up-&gt;fC[I].fPtr = &amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>[up-&gt;fC[I].fID];
    }
}

<a name="TGCS:WriteBinary"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGCS.html#TGCS:WriteBinary">TGCS::WriteBinary</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    fwrite(&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>,sizeof(<a href=".././TNeuralNetCellParameters.html">TNeuralNetCellParameters</a>),1,<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>);
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGCS.html#TGCS:fUbound">fUbound</a>;++up) {
	<a href=".././TNeuralNetCell.html#TNeuralNetCell:WriteUnitBinary">TNeuralNetCell::WriteUnitBinary</a>(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
	fwritevar(up-&gt;fClass);
    }
}

<a name="TGCS:WriteText"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGCS.html#TGCS:WriteText">TGCS::WriteText</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"win_step    %len",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fWinStep);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nei_step    %len",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fNeiStep);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"a_win_count %len",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fWinCount);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"cells       %in",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"min_cells   %in",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMinCells);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"connectors  %in",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fConnectors);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"insert_step %lin",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fInsertStep);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"delete_step %lin",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fDeleteStep);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"ins_count   %lin",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fInsertCount);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"del_count   %lin",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fDeleteCount);
    
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGCS.html#TGCS:fUbound">fUbound</a>;++up) {
	<a href=".././TNeuralNetCell.html#TNeuralNetCell:WriteUnitText">TNeuralNetCell::WriteUnitText</a>(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
	fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nclass            %in",up-&gt;fClass);
    }
}

<a name="TGCS:AllocNet"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGCS.html#TGCS:AllocNet">TGCS::AllocNet</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a> = new <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>[<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes]; TestPointer(<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>);
    <a href=".././TGCS.html#TGCS:fUbound">fUbound</a> = &amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>[<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells];
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up = <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;
    for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes;++I) {
	up-&gt;fVector = new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes]; TestPointer(up-&gt;fVector);
	up-&gt;fDiff   = new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes]; TestPointer(up-&gt;fDiff);
	up-&gt;fC      = new connector[<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fConnectors]; TestPointer(up-&gt;fC);
	up-&gt;fNc     = 0;
	up-&gt;fCount  = 0;
	up-&gt;fID     = I;
	up-&gt;fState  = 0;
	++up;
    }
}

<a name="TGCS:InitNet"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGCS.html#TGCS:InitNet">TGCS::InitNet</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGCS.html#TGCS:fUbound">fUbound</a>;++up) {
	for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++J) up-&gt;fVector[J] = Random();
	up-&gt;fNc = 0;
	for (J=0;J&lt;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells;++J) 
	    if (&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>[J]!=up) up-&gt;fC[up-&gt;fNc++].fPtr = &amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>[J];
    }
    for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes;++I) <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>[I].fClass = 0;
}

<a name="TGCS:CopyData"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGCS.html#TGCS:CopyData">TGCS::CopyData</a>(const <a href=".././TGCS.html">TGCS</a>&amp; gcs) 
{
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* thisup = <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* fromup = gcs.<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
    
<b>    //check integrity</b>
    if (<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes    !=gcs.<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes)     Errorf("cannot copy data: fInNodes not identical");
    if (<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes   !=gcs.<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes)    Errorf("cannot copy data: fOutNodes not identical");
    if (<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fConnectors&lt;gcs.<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fConnectors)  Errorf("cannot copy data: max fConnectors too low");
    
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a> = gcs.<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>;
    <a href=".././TGCS.html#TGCS:fUbound">fUbound</a>=&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>[<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells];
    for (I=0;I&lt;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells;++I) {
	memcpy(thisup-&gt;fVector,fromup-&gt;fVector,sizeof(<a href="../ListOfTypes.html#Double_t">Double_t</a>)*<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes);
	thisup-&gt;fNc = fromup-&gt;fNc;
	for (J=0;J&lt;thisup-&gt;fNc;++J) thisup-&gt;fC[J].fPtr = &amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>[((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)(fromup-&gt;fC[J].fPtr))-&gt;fID];
	thisup-&gt;fCount = fromup-&gt;fCount;
	thisup-&gt;fClass = fromup-&gt;fClass;
	++thisup;
	++fromup;
    }
}

<a name="TGCS:GetWinnerCell"> </a><a href="../ListOfTypes.html#Int_t">Int_t</a> <a href=".././TGCS.html#TGCS:GetWinnerCell">TGCS::GetWinnerCell</a>(<a href="../ListOfTypes.html#NNO_INTYPE">NNO_INTYPE</a>* in) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
<b>    //get distance of all cells: performed in the learnstep before</b>
<b>    //compute deviation for all cells: dito</b>
    
<b>    //make output of all cells and get the winner</b>
    <a href="../ListOfTypes.html#Double_t">Double_t</a> s_dist;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> min_s_dist = DBL_MAX;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    J=0;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGCS.html#TGCS:fUbound">fUbound</a>;++up) {
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* v = up-&gt;fVector;
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* d = up-&gt;fDiff;
	<a href="../ListOfTypes.html#NNO_INTYPE">NNO_INTYPE</a>* i = in;

	s_dist = 0.0;
	for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++I) {
	    *d = *i++ - *v++; 
	    s_dist += *d * *d; 
	    ++d;
	}

	<a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a>[J++] = s_dist;

	if (s_dist&lt;min_s_dist) {
	    min_s_dist = s_dist; 
	    <a href=".././TGCS.html#TGCS:fUwin">fUwin</a> = up; 
	}
    }
    
    if (<a href=".././VNeuralNet.html#VNeuralNet:fPlotter">fPlotter</a>) <a href=".././VNeuralNet.html#VNeuralNet:fPlotter">fPlotter</a>-&gt;<a href=".././VNeuralNetPlotter.html#VNeuralNetPlotter:AddTestSample">AddTestSample</a>(min_s_dist);
    
    return <a href=".././TGCS.html#TGCS:fUwin">fUwin</a>-&gt;fID;
}

<a name="TGCS:Train"> </a><a href="../ListOfTypes.html#Double_t">Double_t</a> <a href=".././TGCS.html#TGCS:Train">TGCS::Train</a>(<a href="../ListOfTypes.html#NNO_INTYPE">NNO_INTYPE</a>* in,<a href="../ListOfTypes.html#NNO_OUTTYPE">NNO_OUTTYPE</a>*) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
    <a href="#TGCS:Recall">Recall</a>(in);  //make output of all cells and neurons find the winner
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* unei;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href="../ListOfTypes.html#Double_t">Double_t</a>* vwin = <a href=".././TGCS.html#TGCS:fUwin">fUwin</a>-&gt;fVector;
    <a href="../ListOfTypes.html#Double_t">Double_t</a>* dwin = <a href=".././TGCS.html#TGCS:fUwin">fUwin</a>-&gt;fDiff;
    for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++J) *vwin++ += *dwin++ * <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fWinStep;
    for (I=0;I&lt;<a href=".././TGCS.html#TGCS:fUwin">fUwin</a>-&gt;fNc;++I) {
	unei = (<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)<a href=".././TGCS.html#TGCS:fUwin">fUwin</a>-&gt;fC[I].fPtr;
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* v = unei-&gt;fVector;
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* d = unei-&gt;fDiff;
	for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++J) *v++ += *d++ * <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fNeiStep;
    }
    
    ++<a href=".././TGCS.html#TGCS:fUwin">fUwin</a>-&gt;fCount;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> m_win_count = 1.0 - <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fWinCount;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGCS.html#TGCS:fUbound">fUbound</a>;++up) {
	up-&gt;fCount *= m_win_count;
    }
    
    if (<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fInsertStep&gt;0) 
	if (<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fInsertCount++==<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fInsertStep) 
	{
	    <a href="#TGCS:Insert">Insert</a>(); 
	    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fInsertCount = 0;
	}
	
    if (<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fDeleteStep&gt;0) 
	if (<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fDeleteCount++==<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fDeleteStep) {
	    <a href="#TGCS:Prune">Prune</a>(); 
	    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fDeleteCount = 0;
	}
	
    <a href=".././VNeuralNet.html#VNeuralNet:fShouldSave">fShouldSave</a> = kTRUE;
    
    return <a href=".././TGCS.html#TGCS:fUwin">fUwin</a>-&gt;fID;
}

<a name="TGCS:Deviation"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGCS.html#TGCS:Deviation">TGCS::Deviation</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGCS.html#TGCS:fUbound">fUbound</a>;++up) <a href=".././TNeuralNetCell.html#TNeuralNetCell:GetSDev">TNeuralNetCell::GetSDev</a>((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
}


<a name="TGCS:Insert"> </a><a href="../ListOfTypes.html#Int_t">Int_t</a> <a href=".././TGCS.html#TGCS:Insert">TGCS::Insert</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* umax;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* udst;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* unew;
    
    if (<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells==<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes) return 0; //break if there are no cells availiable
<b>    //find cell with most win_count</b>
    <a href="../ListOfTypes.html#Double_t">Double_t</a> win_count = -1;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGCS.html#TGCS:fUbound">fUbound</a>;++up) 
	if (up-&gt;fCount&gt;win_count) {
	    win_count = up-&gt;fCount; 
	    umax = up;
	}
	
<b>	//create new cell</b>
	unew = <a href=".././TGCS.html#TGCS:fUbound">fUbound</a>++;
	++<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells;
	unew-&gt;fNc = 0;
	unew-&gt;fState = 0;
	
<b>	//find cell with highest distance to MaxCount</b>
	<a href="../ListOfTypes.html#Double_t">Double_t</a> s_dist;
	<a href="../ListOfTypes.html#Double_t">Double_t</a> max_s_dist = -1;
	<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* unei;
	for (I=0;I&lt;umax-&gt;fNc;++I) {
	    s_dist = 0.0;
	    unei=(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax-&gt;fC[I].fPtr;
	    for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++J) {
		<a href="../ListOfTypes.html#Double_t">Double_t</a> diff = umax-&gt;fVector[J] - unei-&gt;fVector[J];
		s_dist += diff*diff;
	    }
	    
	    if (s_dist&gt;max_s_dist) {
		max_s_dist = s_dist; 
		udst = unei;
	    }
	}
	
	<a href=".././TNeuralNetCell.html#TNeuralNetCell:ConnectNew">TNeuralNetCell::ConnectNew</a>((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)unew,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)udst,(<a href=".././TNeuralNetCellParameters.html">TNeuralNetCellParameters</a>*)&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>);
<b>	//    <a href=".././TNeuralNetCell.html#TNeuralNetCell:InitVector">TNeuralNetCell::InitVector</a>((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)unew,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);</b>
	<a href=".././TNeuralNetCell.html#TNeuralNetCell:InitVector">TNeuralNetCell::InitVector</a>((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)unew,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)udst,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
	<a href=".././TNeuralNetCell.html#TNeuralNetCell:InitCount">TNeuralNetCell::InitCount</a> ((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)unew);
	
	for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGCS.html#TGCS:fUbound">fUbound</a>;++up) <a href=".././TNeuralNetCell.html#TNeuralNetCell:CheckConnections">TNeuralNetCell::CheckConnections</a>((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up);
	return 1;  //insertion was successful
}

<a name="TGCS:Remove"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGCS.html#TGCS:Remove">TGCS::Remove</a>(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* urem) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* ulast = --<a href=".././TGCS.html#TGCS:fUbound">fUbound</a>;
    --<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells;
    while(urem-&gt;fNc)  <a href=".././TNeuralNetCell.html#TNeuralNetCell:Disconnect">TNeuralNetCell::Disconnect</a>((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)urem-&gt;fC[0].fPtr,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)urem); //disconnect all neighbours of urem from urem    //copy ulast into urem
    memmove(urem-&gt;fVector,ulast-&gt;fVector,<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes*sizeof(<a href="../ListOfTypes.html#Double_t">Double_t</a>));
    memmove(urem-&gt;fC,ulast-&gt;fC,<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fConnectors*sizeof(connector));
    urem-&gt;fNc = ulast-&gt;fNc;
    urem-&gt;fCount = ulast-&gt;fCount;
    urem-&gt;fState = ulast-&gt;fState;
    while(ulast-&gt;fNc) <a href=".././TNeuralNetCell.html#TNeuralNetCell:Disconnect">TNeuralNetCell::Disconnect</a>((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)ulast-&gt;fC[0].fPtr,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)ulast); //disconnect all neighbours of ulast from ulast
<b>    //Connect all former neigbours of ulast to urem</b>
    for (I=0;I&lt;urem-&gt;fNc;++I) {
	<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* unei = (<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)urem-&gt;fC[I].fPtr;
	unei-&gt;fC[unei-&gt;fNc++].fPtr = urem;
    }
}

<a name="TGCS:Prune"> </a><a href="../ListOfTypes.html#Int_t">Int_t</a> <a href=".././TGCS.html#TGCS:Prune">TGCS::Prune</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* umax;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* unei;
    
<b>    //find cell with maximal fChi2</b>
    <a href="#TGCS:Deviation">Deviation</a>();
    <a href="../ListOfTypes.html#Double_t">Double_t</a> max_s_dev = -1;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGCS.html#TGCS:fUbound">fUbound</a>;++up) {
	if (up-&gt;fChi2&gt;max_s_dev) { 
	    max_s_dev = up-&gt;fChi2; 
	    umax=up; 
	}
    }
    
    <a href="../ListOfTypes.html#Int_t">Int_t</a> RemoveCount = 1;
    umax-&gt;fState |= REMOVE;
    for (I=0;I&lt;umax-&gt;fNc;++I) {
	unei = (<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax-&gt;fC[I].fPtr;
	<a href="../ListOfTypes.html#Int_t">Int_t</a> xnei = 0;
	for (J=0;J&lt;unei-&gt;fNc;++J) {
	    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
	    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* uneinei = (<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)unei-&gt;fC[J].fPtr;
	    if (uneinei!=umax) {
		for (I=0;I&lt;umax-&gt;fNc;++I) 
		    if (uneinei==(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax-&gt;fC[I].fPtr) break;
		    if (I==umax-&gt;fNc) ++xnei;
	    }
	}
	
<b>	//if unei has no neigbour outside, set REMOVE-flag</b>
	if (xnei==0) {
	    unei-&gt;fState |= REMOVE; 
	    ++RemoveCount; 
	}
    }
    
    if (<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells-RemoveCount&lt;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMinCells) {
	for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGCS.html#TGCS:fUbound">fUbound</a>;++up) up-&gt;fState&amp;=~REMOVE; //clear REMOVE-flag on all cells if network would be shrinking to zero
    } 
    else {
	up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;
	while(up&lt;<a href=".././TGCS.html#TGCS:fUbound">fUbound</a>) { 
	    if (up-&gt;fState&amp;REMOVE) 
		<a href="#TGCS:Remove">Remove</a>(up); 
	    else ++up; 
	}
    }
    
    return 1;
}
</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
