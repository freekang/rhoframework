<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:03:05 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TMomTensor - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>// ROOT Version by Marcel Kunze, RUB</b>
<b>//-------------</b>
<b>// C Headers --</b>
<b>//-------------</b>
#include &lt;math.h&gt;
#include &lt;assert.h&gt;
<b>//-----------------------</b>
<b>// This Class's Header --</b>
<b>//-----------------------</b>
#include "RhoTools/TMomTensor.h"
<b>//-------------------------------</b>
<b>// Collaborating Class Headers --</b>
<b>//-------------------------------</b>
#include "RhoBase/TCandList.h"
#include "RhoBase/TCandListIterator.h"
#include "TLorentzVector.h"
#include "TMatrixD.h"
#include "RhoTools/TBooster.h"
#include "RhoBase/TCandidate.h"

<b>//-----------------------------------------------------------------------</b>
<b>// Local Macros, Typedefs, Structures, Unions and Forward Declarations --</b>
<b>//-----------------------------------------------------------------------</b>

ClassImp(<a href=".././TMomTensor.html">TMomTensor</a>)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, <a href=".././TMomTensor.html">TMomTensor</a> *&amp;obj)
{
   obj = (<a href=".././TMomTensor.html">TMomTensor</a> *) buf.ReadObject(<a href=".././TMomTensor.html#TMomTensor:Class">TMomTensor::Class</a>());
   return buf;
}

static <a href="../ListOfTypes.html#void">void</a> jacobi( TMatrixD Source, 
		    TMatrixD &amp; RotationMatrix, 
		    TVector &amp; EigenValues );

inline <a href="../ListOfTypes.html#void">void</a> swap(<a href="../ListOfTypes.html#int">int</a>&amp; v1, <a href="../ListOfTypes.html#int">int</a>&amp; v2) 
{
    <a href="../ListOfTypes.html#int">int</a> temp = v1;
    v1 = v2;
    v2 = temp;
}

<a name="TMomTensor:TMomTensor"> </a><a href=".././TMomTensor.html#TMomTensor:TMomTensor">TMomTensor::TMomTensor</a>()
  : <a href=".././TMomTensor.html#TMomTensor:_sph">_sph</a>(0), <a href=".././TMomTensor.html#TMomTensor:_apl">_apl</a>(0), <a href=".././TMomTensor.html#TMomTensor:_pla">_pla</a>(0), <a href=".././TMomTensor.html#TMomTensor:_E">_E</a>(3)
{
}

<a href="../ListOfTypes.html#void">void</a>
<a name="TMomTensor:BoostAndCompute"> </a><a href=".././TMomTensor.html#TMomTensor:BoostAndCompute">TMomTensor::BoostAndCompute</a>( TCandList&amp; list,
			       <a href=".././TBooster.html">TBooster</a>* booster )
{
  assert( booster!=0 );
  TCandList boostedList;
  booster-&gt;BoostTo( list, boostedList );
  <a href="#TMomTensor:Compute">Compute</a>( boostedList );
  boostedList.Cleanup();
}

<a href="../ListOfTypes.html#void">void</a>
<a name="TMomTensor:Compute"> </a><a href=".././TMomTensor.html#TMomTensor:Compute">TMomTensor::Compute</a>( TCandList&amp; list )
{
<b>  // initialize</b>
  <a href="#TMomTensor:Reset">Reset</a>();

<b>  //</b>
  TMatrixD sph_mtrx(3,3);
  TMatrixD Rot(3,3);
  TVector E(3); 
  <a href="../ListOfTypes.html#double">double</a> stot=0, sxx=0, syy=0, szz=0, sxy=0, sxz=0, syz=0;
  
  if( list.GetNumberOfCandidates()==0 ) return;
 
  TCandListIterator iter(list);
  TCandidate* trkptr;
<b>  // start a loop over the all tracks</b>
  while ( trkptr = iter.Next() ) {
    TLorentzVector cmList(trkptr-&gt;P4());

    TVector3 tmp(cmList.X(),cmList.Y(),cmList.Z());
    stot += (tmp.Mag())*(tmp.Mag());
    sxx += (tmp.X())*(tmp.X());
    sxy += (tmp.X())*(tmp.Y());
    sxz += (tmp.X())*(tmp.Z());
    syy += (tmp.Y())*(tmp.Y());
    syz += (tmp.Y())*(tmp.Z());
    szz += (tmp.Z())*(tmp.Z());
  }

  if( stot==0. ) return;

<b>  //obtain sphericity tensor explicitly</b>
  sph_mtrx(0,0) = sxx / stot ;
  sph_mtrx(1,0) = sxy / stot ;
  sph_mtrx(2,0) = sxz / stot ;
  sph_mtrx(0,1) = sxy / stot ;
  sph_mtrx(1,1) = syy / stot ;
  sph_mtrx(2,1) = syz / stot ;
  sph_mtrx(0,2) = sxz / stot ;
  sph_mtrx(1,2) = syz / stot ;
  sph_mtrx(2,2) = szz / stot ;
     
  jacobi(sph_mtrx,Rot,E);

  <a href=".././TMomTensor.html#TMomTensor:_E">_E</a> = E;

  <a href="../ListOfTypes.html#double">double</a> Emax = E(0);
  <a href="../ListOfTypes.html#double">double</a> Emin = E(0);
  <a href="../ListOfTypes.html#int">int</a> j = 0, k = 0;
  for ( <a href="../ListOfTypes.html#int">int</a> i = 0; i &lt;= 2 ; ++i ) {
    if ( E(i) &gt; Emax ) {Emax = E(i); j = i;}
    if ( E(i) &lt; Emin ) {Emin = E(i); k = i;}
  }

  <a href="../ListOfTypes.html#int">int</a> l = 3-j-k;
  <a href=".././TMomTensor.html#TMomTensor:_sph">_sph</a> = Emax;

  <a href=".././TMomTensor.html#TMomTensor:_sph">_sph</a> = 3 * ( E(k) + E(l) ) / 2;
  <a href=".././TMomTensor.html#TMomTensor:_apl">_apl</a> = 3 * E(k) / 2;
  <a href=".././TMomTensor.html#TMomTensor:_pla">_pla</a> = E(l) - E(k);

<b>  // sort the eignevalues into increasing order; rather than rearranging</b>
<b>  // the values themselves, sort an array of indices so that the</b>
<b>  // correspondence with eigenvectors may be retained</b>

  <a href="../ListOfTypes.html#int">int</a> ei[3] = { 0, 1, 2 };
  if(E(ei[1]) &lt; E(ei[0])) swap(ei[0], ei[1]);
  if(E(ei[2]) &lt; E(ei[1])) swap(ei[1], ei[2]);
  if(E(ei[1]) &lt; E(ei[0])) swap(ei[0], ei[1]);

  <a href=".././TMomTensor.html#TMomTensor:_sph">_sph</a> = 1.5 * (E(ei[0]) + E(ei[1]));
  <a href=".././TMomTensor.html#TMomTensor:_apl">_apl</a> = 1.5 * E(ei[0]);
  <a href=".././TMomTensor.html#TMomTensor:_pla">_pla</a> = E(ei[1]) - E(ei[0]);

  <a href=".././TMomTensor.html#TMomTensor:_sphAx">_sphAx</a> = TVector3 ( Rot(0,ei[2]), Rot(1,ei[2]), Rot(2,ei[2]) ) ;
  <a href=".././TMomTensor.html#TMomTensor:_secAx">_secAx</a> = TVector3 ( Rot(0,ei[1]), Rot(1,ei[1]), Rot(2,ei[1]) ) ;
  <a href=".././TMomTensor.html#TMomTensor:_thrAx">_thrAx</a> = TVector3 ( Rot(0,ei[0]), Rot(1,ei[0]), Rot(2,ei[0]) ) ;

}

<a href="../ListOfTypes.html#void">void</a>
<a name="TMomTensor:Reset"> </a><a href=".././TMomTensor.html#TMomTensor:Reset">TMomTensor::Reset</a>() 
{
  <a href=".././TMomTensor.html#TMomTensor:_sph">_sph</a>=0;
  <a href=".././TMomTensor.html#TMomTensor:_apl">_apl</a>=0;
  <a href=".././TMomTensor.html#TMomTensor:_pla">_pla</a>=0;
}

<a name="TMomTensor:~TMomTensor"> </a><a href=".././TMomTensor.html">TMomTensor</a>::~<a href=".././TMomTensor.html">TMomTensor</a>() {}


/*-------------------------------------------------*/
/*         Jacobi                                  */
/* Template function jacobi computes eigenvalues   */
/* and eigenvectors of a <a href="../ListOfTypes.html#real">real</a> symmetric matrix     */
/* The output consists of the linear tranformation */
/* to the principal axes and a vector containing   */
/* the matrice's eigenvalues.                      */
/*-------------------------------------------------*/

#define JACOBI_ROTATION(A,i,j,k,l) g=A(i,j); h=A(k,l); A(i,j) = g-s*(h+g*tau); A(k,l) = h + s*(g-h*tau);

static void jacobi(TMatrixD Source, TMatrixD &amp; RotationMatrix, TVector &amp; EigenValues) {

<b>//  AS IN NUMERICAL RECIPES IN C, PAGE 467</b>

    <a href="../ListOfTypes.html#int">int</a> irow,icol;
    <a href="../ListOfTypes.html#double">double</a> Threshold;

    <a href="../ListOfTypes.html#int">int</a> mtrxSize=Source.GetNrows();
    RotationMatrix =TMatrixD(mtrxSize,mtrxSize);
    <a href="../ListOfTypes.html#int">int</a> i,j;
    for (i = RotationMatrix.GetRowLwb(); i &lt;= RotationMatrix.GetRowUpb(); i++)
      for(j = RotationMatrix.GetColLwb(); j &lt;= RotationMatrix.GetColUpb(); j++)
        RotationMatrix(i,j) = 1.0;
    for (irow=0;irow&lt;mtrxSize;irow++) EigenValues(irow)=Source(irow,irow);
      TVector Z(mtrxSize),B(mtrxSize);
      B=EigenValues;
      <a href="../ListOfTypes.html#int">int</a> NumberRotations = 0;
      for (<a href="../ListOfTypes.html#int">int</a> Iteration=0;Iteration&lt;50;Iteration++) {
        <a href="../ListOfTypes.html#double">double</a> SumOffDiagonal=0.0;     
        for (irow=0;irow&lt;mtrxSize;irow++) {
            for (icol=irow+1;icol&lt;mtrxSize;icol++) {
                SumOffDiagonal+= fabs(Source(irow,icol));
            }
        }
        if (SumOffDiagonal==0.0) break;
        if (Iteration&lt;4) 
            Threshold = 0.2*SumOffDiagonal/(mtrxSize*mtrxSize);
        else
            Threshold = 0.0;
        for (irow=0;irow&lt;mtrxSize;irow++) {
            for (icol=irow+1;icol&lt;mtrxSize;icol++) {
                <a href="../ListOfTypes.html#double">double</a> t,g;
                g = 100.0*fabs(Source(irow,icol));
                if (Iteration&gt;4 &amp;&amp; (<a href="../ListOfTypes.html#double">double</a>) (fabs(EigenValues(irow))+g) == (<a href="../ListOfTypes.html#double">double</a>) fabs(EigenValues(irow)) &amp;&amp; (<a href="../ListOfTypes.html#double">double</a>) (fabs(EigenValues(icol))+g) == (<a href="../ListOfTypes.html#double">double</a>) fabs(EigenValues(icol))) {
                    Source(irow,icol)=0.0;
                }
                else if (fabs(Source(irow,icol))&gt;Threshold) {
                    <a href="../ListOfTypes.html#double">double</a> h = EigenValues(icol) - EigenValues(irow);
                    if ((<a href="../ListOfTypes.html#double">double</a>) (fabs(h) + g) == (<a href="../ListOfTypes.html#double">double</a>) fabs(h)) {
                        t = Source(irow,icol)/h;
                    }
                    else {
                        <a href="../ListOfTypes.html#double">double</a> Theta = 0.5*h/Source(irow,icol);
                        t = 1.0/(fabs(Theta) + sqrt(1.0 + Theta*Theta));
                        if (Theta&lt;0) t = -t; 
                    }
                    <a href="../ListOfTypes.html#double">double</a> c = 1.0/sqrt(1.0+t*t);
                    <a href="../ListOfTypes.html#double">double</a> s = t*c;
                    <a href="../ListOfTypes.html#double">double</a> tau = s/(1.0 + c);
                    h = t*Source(irow,icol);
                    Z(irow) -= h;
                    Z(icol) += h;
                    EigenValues(irow) -= h;
                    EigenValues(icol) += h;
                    Source(irow,icol) = 0.0;

                    <a href="../ListOfTypes.html#int">int</a> j;
                    for (j=0;j&lt;irow;j++) {
                        JACOBI_ROTATION(Source,j,irow,j,icol)
                    }
                    for (j=irow+1;j&lt;icol;j++) {
                        JACOBI_ROTATION(Source,irow,j,j,icol)
                    }
                    for (j=icol+1;j&lt;mtrxSize;j++) {
                        JACOBI_ROTATION(Source,irow,j,icol,j)
                    }
                    for (j=0;j&lt;mtrxSize;j++) {
                        JACOBI_ROTATION(RotationMatrix,j,irow,j,icol)
                    }
                    NumberRotations++;
                }
          }            
    }    
    B+=Z;
    EigenValues=B;
    Z=TVector(mtrxSize);
  }
<b>//Sort not needed in this application and it is buggy</b>
/*  HepMatrix ColJ(1,mtrxSize);
  for (<a href="../ListOfTypes.html#int">int</a> i=1;i&lt;=mtrxSize;i++) {
      for (<a href="../ListOfTypes.html#int">int</a> j=i+1;j&lt;=mtrxSize;j++) {
          if (EigenValues[j]&gt;EigenValues[i]) {
	    ColJ=RotationMatrix.sub(1,mtrxSize,i,i);
              RotationMatrix.sub(1,i,RotationMatrix.sub(1,mtrxSize,j,j));
              RotationMatrix.sub(1,j,ColJ);
              <a href="../ListOfTypes.html#double">double</a> fI = EigenValues[i], fJ=EigenValues[j];
              EigenValues[i] = fJ; EigenValues[j] = fI;
          }
      }
      }*/
}
</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
