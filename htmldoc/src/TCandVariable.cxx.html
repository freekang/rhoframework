<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:02:42 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TCandVariable - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//--------------------------------------------------------------------------</b>
<b>// Class library to read the BABAR KanGA data</b>
<b>// Author: Leif Wilden, TUD, 1999</b>
<b>//------------------------------------------------------------------------</b>
#include "KangaSchema/kanga.h"

#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;

#include "TROOT.h"
#include "TClass.h"
#include "TRealData.h"
#include "TDataMember.h"
#include "TDataType.h"
#include "TTree.h"
#include "TLeaf.h"
#include "TString.h"

#include "KangaSchema/TBtaMicroCandR.h"
#include "RhoBase/TSmartPointer.h"

ClassImp(TCandVariable);
ClassImp(TCandDirectory);
ClassImp(TBtaMicroCandRDir);

#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

<b>//------------------------------------------------------------</b>

<a name="TCandVariable:TCandVariable"> </a><a href=".././TCandVariable.html#TCandVariable:TCandVariable">TCandVariable::TCandVariable</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> AnId, const <a href="../ListOfTypes.html#char">char</a>* AName, 
			     const <a href="../ListOfTypes.html#char">char</a>* AnAlias):
  TNamed(AnAlias,AName),
  <a href=".././TCandVariable.html#TCandVariable:fVarID">fVarID</a>(AnId),
  <a href=".././TCandVariable.html#TCandVariable:fBranch">fBranch</a>(0),
  <a href=".././TCandVariable.html#TCandVariable:fOffset">fOffset</a>(0)
{}

<a name="TCandVariable:~TCandVariable"> </a><a href=".././TCandVariable.html">TCandVariable</a>::~<a href=".././TCandVariable.html">TCandVariable</a>() { delete <a href=".././TCandVariable.html#TCandVariable:fBranch">fBranch</a>; }

<b>//------------------------------------------------------------</b>

<a href=".././TCandDirectory.html#TCandDirectory:TCandDirectory">TCandDirectory::TCandDirectory</a>(): fMaxid(0)
{
    fVarsByAlias = new THashList(kBranches);

    for (<a href="../ListOfTypes.html#int">int</a> i=0;i&lt;kBranches;i++) {
      fDoNotProcess[i] = kTRUE;
      fCandArray[i] = 0;
    }
}

<a href=".././TCandDirectory.html#TCandDirectory:TCandDirectory">TCandDirectory::TCandDirectory</a>(const <a href="../ListOfTypes.html#char">char</a>* AFileName): fMaxid(0)
{
    fVarsByAlias = new THashList(kBranches);

    for (<a href="../ListOfTypes.html#int">int</a> i=0;i&lt;kBranches;i++) {
      fDoNotProcess[i] = kTRUE;
      fCandArray[i] = 0;
    }

    ReadAliases(AFileName);
}

<a href=".././TCandDirectory.html">TCandDirectory</a>::~<a href=".././TCandDirectory.html">TCandDirectory</a>() 
{
    fVarsByAlias-&gt;Delete(); // Remove the TCandVariables
    delete fVarsByAlias;
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././TCandDirectory.html#TCandDirectory:Reset">TCandDirectory::Reset</a>()
{
    fVarsByAlias-&gt;Delete(); // Remove the TCandVariables
    fMaxid = 0;
    for (<a href="../ListOfTypes.html#int">int</a> i=0;i&lt;kBranches;i++) {
      fDoNotProcess[i] = kTRUE;
      fCandArray[i] = 0;
    }
}

const <a href="../ListOfTypes.html#char">char</a>* <a href=".././TCandDirectory.html#TCandDirectory:GetClassName">TCandDirectory::GetClassName</a>(const TBranchClones* bc)
{
  TClass *cl = gROOT-&gt;GetClass("TBranchClones");
  if (!cl-&gt;GetListOfRealData()) cl-&gt;BuildRealData();
  TIter next(cl-&gt;GetListOfRealData());
  TRealData *rd;
  <a href="../ListOfTypes.html#char">char</a>* bcc;

  while ((rd = (TRealData*) next())) {
    if (!strcmp(rd-&gt;GetName(),"fClassName.*fData")) {
      bcc= (<a href="../ListOfTypes.html#char">char</a>*)bc;
      <a href="../ListOfTypes.html#char">char</a> *pointer = (<a href="../ListOfTypes.html#char">char</a>*)(bcc + rd-&gt;GetThisOffset());
      <a href="../ListOfTypes.html#char">char</a> **ppointer = (<a href="../ListOfTypes.html#char">char</a>**)(pointer);
      return *ppointer;
    }
  }
  return "unknown";
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././TCandDirectory.html#TCandDirectory:AssignVars">TCandDirectory::AssignVars</a>(TBranchClones* bc, const TObject* o)
{

<b>  // check if ROOT knows about the given class o:</b>

  TClass *cl = gROOT-&gt;GetClass(o-&gt;ClassName());
  if (!cl) {
    cout &lt;&lt; "Kanga::AssignVars: The class " &lt;&lt; o-&gt;ClassName() &lt;&lt; " is unknown to ROOT?!";
    assert(cl);
  }

<b>  // now loop over all data members of class o and try to find</b>
<b>  // a corresponding branch. If successfull set the leaf's memory</b>
<b>  // offset:</b>

  if (!cl-&gt;GetListOfRealData()) cl-&gt;BuildRealData();
<b>  //<a href="../ListOfTypes.html#char">char</a> branchname[80];</b>
  TRealData     *rd;
  <a href=".././TCandVariable.html">TCandVariable</a> *var;
  TBranch       *branch;
  TLeaf         *leaf;
  <a href="../ListOfTypes.html#Int_t">Int_t</a>         n=0;
  TIter         next(cl-&gt;GetListOfRealData());

  while ((rd = (TRealData *) next())) {

    TDataMember *member = rd-&gt;GetDataMember();
    if (!member-&gt;IsBasic())      continue;
    if (!member-&gt;IsPersistent()) continue;
    TDataType *membertype = member-&gt;GetDataType();
    if (membertype-&gt;GetType() == 0) continue;

    var= GetVarByAlias(rd-&gt;GetName());

    if (!var) {
      var= new <a href=".././TCandVariable.html">TCandVariable</a>(++fMaxid,rd-&gt;GetName(),rd-&gt;GetName());
      fVarsByAlias-&gt;Add(var);
      if (fMaxid&gt;kBranches) {
	  cerr &lt;&lt; "<a href=".././TCandDirectory.html#TCandDirectory:AssignVars">TCandDirectory::AssignVars</a>: kBranches cache too small." &lt;&lt; endl;
      }
      else {
          fCandArray[fMaxid] = var;
      }
    }

    if (!strcmp(var-&gt;GetTitle(),"none")) continue;

<b>    //sprintf(branchname,"%s.%s",bc-&gt;GetName(),var-&gt;fVarName.Data());</b>
    TString branchname(bc-&gt;GetName());
    branchname.Append(".");
    branchname.Append(var-&gt;GetTitle());
    branch= (TBranch*)bc-&gt;GetListOfBranches()-&gt;FindObject(branchname);
    if (!branch) {
<b>      //cout &lt;&lt; "Kanga::AssignVars: No branch found for member " &lt;&lt; rd-&gt;GetName() &lt;&lt; </b>
<b>      //     " (" &lt;&lt; branchname &lt;&lt;")." &lt;&lt; endl;</b>
      continue;
    }

    TObjArray *leaves = branch-&gt;GetListOfLeaves();
    leaf = (TLeaf*)leaves-&gt;UncheckedAt(0);
    leaf-&gt;SetOffset(rd-&gt;GetThisOffset());
    branch-&gt;GetTree()-&gt;GetBranch(branchname)-&gt;SetBit(kDoNotProcess);
    var-&gt;<a href=".././TCandVariable.html#TCandVariable:fOffset">fOffset</a>= rd-&gt;GetThisOffset();
    var-&gt;<a href=".././TCandVariable.html#TCandVariable:fBranch">fBranch</a>= new TSmartPointer(branch);
    n++;
  }
  cout &lt;&lt; "Kanga::AssignVars:  " &lt;&lt; n &lt;&lt; " data members of object " &lt;&lt; o-&gt;GetName() &lt;&lt; 
          " have been assigned to a branch." &lt;&lt; endl;
}

<a href=".././TCandVariable.html">TCandVariable</a>* <a href=".././TCandDirectory.html#TCandDirectory:GetVarByAlias">TCandDirectory::GetVarByAlias</a>(const <a href="../ListOfTypes.html#char">char</a>* AVarAlias) const
{
  <a href=".././TCandVariable.html">TCandVariable</a>* v= (<a href=".././TCandVariable.html">TCandVariable</a>*) fVarsByAlias-&gt;FindObject(AVarAlias);
  return v;
}

<a href=".././TCandVariable.html">TCandVariable</a>* <a href=".././TCandDirectory.html#TCandDirectory:GetVarByID">TCandDirectory::GetVarByID</a>(const <a href="../ListOfTypes.html#Int_t">Int_t</a> AVarID) const
{
  if (AVarID&gt;=kBranches) return 0;
  return fCandArray[AVarID];
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././TCandDirectory.html#TCandDirectory:ReadAliases">TCandDirectory::ReadAliases</a>(const <a href="../ListOfTypes.html#char">char</a>* AFileName)
{
  <a href="../ListOfTypes.html#Int_t">Int_t</a>     id,n=0;
  <a href="../ListOfTypes.html#Char_t">Char_t</a>    name[80],alias[80];
  ifstream  s;
  <a href=".././TCandVariable.html">TCandVariable</a>* var;

  s.open(AFileName);
  if (!s) {
    cout &lt;&lt; "Kanga::ReadAliases: File " &lt;&lt; AFileName &lt;&lt; " does not exist!" &lt;&lt; endl;
    assert(0);
  };
  while (!s.eof()) {
    s &gt;&gt; name;
    s &gt;&gt; alias;
    id= 0;
    s &gt;&gt; id;
    if (id&gt;0) {
      if (id&gt;kBranches) {
	cerr &lt;&lt; "<a href=".././TCandDirectory.html#TCandDirectory:ReadAliases">TCandDirectory::ReadAliases</a>: kBranches cache too small. Requesting entry " &lt;&lt; id &lt;&lt; endl;
	continue;
      }
      var= new <a href=".././TCandVariable.html">TCandVariable</a>(id,name,alias);
      fVarsByAlias-&gt;Add(var);
      fCandArray[id] = var;
      if (id&gt;fMaxid) fMaxid= id;
      n++;
    }
  }
  s.close();
  cout &lt;&lt; "Kanga::ReadAliases: " &lt;&lt; n &lt;&lt; " aliases read from " &lt;&lt; AFileName &lt;&lt; "." &lt;&lt; endl;  
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././TCandDirectory.html#TCandDirectory:ReadBranch">TCandDirectory::ReadBranch</a>(const <a href="../ListOfTypes.html#Int_t">Int_t</a> AVarID)
{
<b>  //if (fDoNotProcess[AVarID]) return; // We do not have this variable on file</b>

  <a href=".././TCandVariable.html">TCandVariable</a>* v= GetVarByID(AVarID);
  if (!v) { 
    cout &lt;&lt; "Kanga::ReadBranch: Can not read variable with ID=" &lt;&lt; AVarID &lt;&lt; " (Schema evolution ?). " &lt;&lt; endl;
    InvalidateBranch(AVarID);
    return;
  }

  if (v-&gt;<a href=".././TCandVariable.html#TCandVariable:fBranch">fBranch</a> == 0) {
    cout &lt;&lt; "Kanga::ReadBranch: Try to access non-existant branch " &lt;&lt; v-&gt;GetTitle() &lt;&lt; endl;
    return;
  }

  v-&gt;<a href=".././TCandVariable.html#TCandVariable:fBranch">fBranch</a>-&gt;CheckBranch();
}

<b>//------------------------------------------------------------</b>

<a href=".././TBtaMicroCandRDir.html">TBtaMicroCandRDir</a>::~<a href=".././TBtaMicroCandRDir.html">TBtaMicroCandRDir</a>()
{
    delete fInstance;
    fInstance = 0;
}

<a href="../ListOfTypes.html#Int_t">Int_t</a> <a href=".././TBtaMicroCandRDir.html#TBtaMicroCandRDir:fSchema">TBtaMicroCandRDir::fSchema</a> = 0;

<a href=".././TBtaMicroCandRDir.html">TBtaMicroCandRDir</a>* <a href=".././TBtaMicroCandRDir.html#TBtaMicroCandRDir:fInstance">TBtaMicroCandRDir::fInstance</a>;

<a href=".././TBtaMicroCandRDir.html">TBtaMicroCandRDir</a>* <a href=".././TBtaMicroCandRDir.html#TBtaMicroCandRDir:Instance">TBtaMicroCandRDir::Instance</a>()
{
  if (!fInstance) fInstance= new <a href=".././TBtaMicroCandRDir.html">TBtaMicroCandRDir</a>();
  return fInstance;
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././TBtaMicroCandRDir.html#TBtaMicroCandRDir:Init">TBtaMicroCandRDir::Init</a>(TTree *t, TClonesArray** c, const <a href="../ListOfTypes.html#char">char</a>* SchemaDir)
{
  TBranch* aodBranch = t-&gt;GetBranch("BtaAod");
  assert(aodBranch);
  TIterator* aodIter = aodBranch-&gt;GetListOfBranches()-&gt;MakeIterator();
  TBranchClones *bc = 0;
  TObject* p = 0;
  while ( (p=aodIter-&gt;Next()) &amp;&amp; !bc ) {
    if ( !strcmp(static_cast&lt;TBranch*&gt;(p)-&gt;GetName(),"_array") ) {
      bc=static_cast&lt;TBranchClones*&gt;(p);
    }
  }

  if (!bc) { cout &lt;&lt; "Kanga::Init: The tree t does not contain a branch with name _array?!" &lt;&lt; endl; }
  assert(bc);
  if (c) bc-&gt;SetAddress(c);

  TString schema(GetClassName(bc));

  if (schema=="<a href=".././BtaMicroCandR_001.html">BtaMicroCandR_001</a>") fSchema = 1;
  if (schema=="<a href=".././BtaMicroCandR_002.html">BtaMicroCandR_002</a>") fSchema = 2;
  if (schema=="<a href=".././BtaMicroCandR_003.html">BtaMicroCandR_003</a>") fSchema = 3;
  if (schema=="<a href=".././BtaMicroCandR_004.html">BtaMicroCandR_004</a>") fSchema = 4;
  if (schema=="<a href=".././BtaMicroCandR_005.html">BtaMicroCandR_005</a>") fSchema = 5;

  cout &lt;&lt; "Loading schema #" &lt;&lt; fSchema &lt;&lt; " for " &lt;&lt; schema &lt;&lt; endl;

  TString s(SchemaDir);
  if (!SchemaDir) s+=".";
  s+= "/";
  s+= schema;
  s+= ".sdf";
  Reset();
  ReadAliases(s.Data());
  <a href=".././TBtaMicroCandR.html">TBtaMicroCandR</a> bmc;
  AssignVars(bc,&amp;bmc);
}

<a href="../ListOfTypes.html#Int_t">Int_t</a> <a href=".././TBtaMicroCandRDir.html#TBtaMicroCandRDir:GetSchema">TBtaMicroCandRDir::GetSchema</a>() { return fSchema; }
<a href="../ListOfTypes.html#void">void</a> <a href=".././TBtaMicroCandRDir.html#TBtaMicroCandRDir:SetSchema">TBtaMicroCandRDir::SetSchema</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> s) { fSchema = s; }

<b>//------------------------------------------------------------</b>




</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
