#ifndef ROOCLONESVECTORR_CC
#define ROOCLONESVECTORR_CC
//
// Implementation of RooClonesVectorR<T>:
//
// C++ headers:


// This class header:
#include "KangaSchema/RooClonesVectorR.h"


// Collaborating class headers:
#include "TBuffer.h"
#include "TClass.h"


// Special ROOT definitions:
ClassImpT(RooClonesVectorR,T)


// Static data members:


// Static member functions:


// Constructors:
// For some reason TClonesArray ctor has non-const args
template <class T> 
RooClonesVectorR<T>::RooClonesVectorR( const unsigned & capacity ) :
  RooClonesVectorI()

{

  if( _theArray == 0 ) {
    int tmpI= capacity;
    _array= new TClonesArray( (Text_t*)(T::Class()->GetName()), tmpI );
  }
  else {
    _array= _theArray;
    _ownArray= kFALSE;
  }

  _array->BypassStreamer(kFALSE);
}


// Destructor:
template <class T> RooClonesVectorR<T>::~RooClonesVectorR() {

  _array->Clear();
  if( _ownArray ) delete _array;

}


// Reset the object:
template <class T> void RooClonesVectorR<T>::clear() { 

  _array->Clear(); 
  _nent= 0; 

}


// Stream an object of class RooClonesVectorR<T>:
template <class T> void RooClonesVectorR<T>::Streamer( TBuffer & R__b ) {

  if( R__b.IsReading() ) {
    Version_t R__v= R__b.ReadVersion();
    // if (R__v) { }
    RooClonesVectorI::Streamer( R__b );
  } 
  else {
    R__b.WriteVersion( RooClonesVectorR<T>::IsA() );
    RooClonesVectorI::Streamer( R__b );
  }

}


// Read a pointer to an object of class RooClonesVectorR<BtaMicroCandR>.
// Give template definition here, because template specialisation through
// code generated by rootcint doesn't work on SUN (don't you just love
// the SUN C++ compiler?)
template <class T> TBuffer & operator >> ( TBuffer & buf,
					   RooClonesVectorR<T>* & obj ) {

  obj= (RooClonesVectorR<T>*) buf.ReadObject( RooClonesVectorR<T>::Class() );
  return buf;

}
#endif

