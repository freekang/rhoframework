<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:03:31 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TTreeNavigator - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//--------------------------------------------------------------------------</b>
<b>// File and Version Information:</b>
<b>// 	$Id: TTreeNavigator.cxx.html,v 1.1.1.1 2002-12-20 15:05:30 marcel Exp $</b>
<b>//</b>
<b>// Description:</b>
<b>//	Class <a href=".././TTreeNavigator.html">TTreeNavigator</a></b>
<b>//</b>
<b>// Environment:</b>
<b>//	Software developed for the BaBar Detector at the SLAC B-Factory.</b>
<b>//</b>
<b>// Author List:</b>
<b>//	Gautier Hamel de Monchenault - CEN Saclay &amp; Lawrence Berkeley Lab</b>
<b>//</b>
<b>// History (add to end):</b>
<b>//      Gautier   Oct, 1998  - creation</b>
<b>//</b>
<b>// Copyright Information:</b>
<b>//	Copyright (C) 1998	       CEA - Centre d'Etude de Saclay</b>
<b>//</b>
<b>// ROOT Version by Marcel Kunze, RUB</b>
<b>//------------------------------------------------------------------------</b>

#include "RhoTools/TTreeNavigator.h"
#include "RhoTools/TPrintTree.h"
#include "RhoBase/TCandList.h"
#include "RhoBase/TCandListIterator.h"

ClassImp(TTreeNavigator)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, TTreeNavigator *&amp;obj)
{
   obj = (TTreeNavigator *) buf.ReadObject(TTreeNavigator::Class());
   return buf;
}

#include &lt;iostream&gt;
using namespace std;

<b>//</b>
<b>//  Constructor</b>
<b>//</b>
<a name="TTreeNavigator:TTreeNavigator"> </a><a href=".././TTreeNavigator.html#TTreeNavigator:TTreeNavigator">TTreeNavigator::TTreeNavigator</a>(TCandidate&amp; tree )
{
    <a href=".././TTreeNavigator.html#TTreeNavigator:_theTree">_theTree</a> = &amp;tree;
    <a href="#TTreeNavigator:fillLists">fillLists</a>(*<a href=".././TTreeNavigator.html#TTreeNavigator:_theTree">_theTree</a>);
}


<b>//</b>
<b>// Recursive functions</b>
<b>//</b>

<a href="../ListOfTypes.html#void">void</a>
<a name="TTreeNavigator:fillLists"> </a><a href=".././TTreeNavigator.html#TTreeNavigator:fillLists">TTreeNavigator::fillLists</a>( const TCandidate&amp; c ) 
{
    const VAbsVertex* decayVtx=0;
    if( c.NDaughters()!=0)
    {
	<a href=".././TTreeNavigator.html#TTreeNavigator:_unstableCands">_unstableCands</a>.Add( (TObject*)&amp;c );
	if (decayVtx=c.DecayVtx()) {
	    if( !<a href=".././TTreeNavigator.html#TTreeNavigator:_vertices">_vertices</a>.Contains( (TObject*)decayVtx ) )
		<a href=".././TTreeNavigator.html#TTreeNavigator:_vertices">_vertices</a>.Add( (TObject*)decayVtx );
	}
	TCandidate* dau=0;
	TCandListIterator iterDau=c.DaughterIterator();
	while( dau=iterDau.Next() )
	{
	    <a href="#TTreeNavigator:fillLists">fillLists</a>( *dau );
	}
    }
    else
    {
	<a href=".././TTreeNavigator.html#TTreeNavigator:_finalCands">_finalCands</a>.Add( (TObject*)&amp;c );
    }
}

<a href="../ListOfTypes.html#void">void</a> 
<a name="TTreeNavigator:PrintCand"> </a><a href=".././TTreeNavigator.html#TTreeNavigator:PrintCand">TTreeNavigator::PrintCand</a>( const TCandidate&amp; c )
{
    <a href=".././TPrintTree.html">TPrintTree</a> prtTree;
    cout &lt;&lt; (prtTree.Print(c)).Data();
    cout &lt;&lt;  ( (c.IsComposite() ) ? "Tree UID:" : "Cand UID:" );
    cout &lt;&lt; c.Uid(); //  &lt;&lt; " local cand:" &lt;&lt; c.thisCandidate();
    cout &lt;&lt; " mass: " &lt;&lt; c.Mass() &lt;&lt; " p: " &lt;&lt; c.P() &lt;&lt; " pv " ;
    cout &lt;&lt; " th/ph " &lt;&lt; c.P3().Theta() &lt;&lt; "/" &lt;&lt; c.P3().Phi() ;
    
    if (c.ProductionVtx()!=0)
	cout &lt;&lt; *(c.ProductionVtx());
    else 
	cout &lt;&lt; "(none)";
    
    cout &lt;&lt; " mom UID: " &lt;&lt; (c.TheMother() ? c.TheMother()-&gt;Uid() : 0 );
    const TParticlePDG* pdt;
    if( pdt=c.PdtEntry() ) cout &lt;&lt; " " &lt;&lt; pdt-&gt;GetName();
    cout &lt;&lt; endl;
    if( c.DecayVtx()!=0 ) {
	cout &lt;&lt; "    Decay ";
	<a href="#TTreeNavigator:PrintVertex">PrintVertex</a>( *c.DecayVtx() );
    }
}

<a href="../ListOfTypes.html#void">void</a> 
<a name="TTreeNavigator:PrintTree"> </a><a href=".././TTreeNavigator.html#TTreeNavigator:PrintTree">TTreeNavigator::PrintTree</a>( const TCandidate&amp; c )
{
    <a href="#TTreeNavigator:PrintCand">PrintCand</a>( c );
    TCandidate* dau=0;
    TCandListIterator iterDau=c.DaughterIterator();
    while( dau=iterDau.Next() )       
	<a href="#TTreeNavigator:PrintTree">PrintTree</a>( *dau );
}

<a href="../ListOfTypes.html#void">void</a> 
<a name="TTreeNavigator:PrintVertex"> </a><a href=".././TTreeNavigator.html#TTreeNavigator:PrintVertex">TTreeNavigator::PrintVertex</a>( const VAbsVertex&amp; v )
{
    if (&amp;v==0) return;
    TLorentzVector pos = v.V4();
    cout &lt;&lt; "Vtx at (" &lt;&lt; pos.X() &lt;&lt; "," &lt;&lt; pos.Y() &lt;&lt; "," &lt;&lt; pos.Z() &lt;&lt; ";" &lt;&lt; pos.T()  &lt;&lt; ") incoming ";
    const TCandidate* inComing = v.InComingCand();
    if ( inComing!=0 ) 
    {
	cout &lt;&lt; (v.InComingCand()-&gt;Uid());
	cout &lt;&lt; " M " &lt;&lt; v.Mass() &lt;&lt; " p " &lt;&lt; v.P();
    }
    else cout &lt;&lt; 0 ;
    cout &lt;&lt; " nout " &lt;&lt; v.NOutGoing();
    cout &lt;&lt; " res " &lt;&lt; v.NResonance();
    cout &lt;&lt; endl;
}

<a href="../ListOfTypes.html#void">void</a> 
<a name="TTreeNavigator:PrintOn"> </a><a href=".././TTreeNavigator.html#TTreeNavigator:PrintOn">TTreeNavigator::PrintOn</a>( std::ostream&amp; o ) const
{
    <a href="../ListOfTypes.html#size_t">size_t</a> i;
    o &lt;&lt; "Number of vertices : " &lt;&lt; <a href="#TTreeNavigator:NVertex">NVertex</a>() &lt;&lt; endl;
    o &lt;&lt; "Number of final stable candidates : " &lt;&lt; <a href="#TTreeNavigator:NFinalCand">NFinalCand</a>();
    for( i=0; i&lt;<a href=".././TTreeNavigator.html#TTreeNavigator:_finalCands">_finalCands</a>.GetSize(); i++ )
    {
	const TCandidate* c = (TCandidate*)<a href=".././TTreeNavigator.html#TTreeNavigator:_finalCands">_finalCands</a>.At(i);
	const TParticlePDG* pdt=0;
	o &lt;&lt; " | ";
	if( pdt=c-&gt;PdtEntry() )
	    o &lt;&lt; pdt-&gt;GetName();
	else
	    o &lt;&lt; pdt-&gt;Mass();
    }
    o &lt;&lt; " | " &lt;&lt; endl;
    o &lt;&lt; "Number of intermediate candidates : " &lt;&lt; <a href="#TTreeNavigator:NUnstableCand">NUnstableCand</a>();
    for( i=0; i&lt;<a href=".././TTreeNavigator.html#TTreeNavigator:_unstableCands">_unstableCands</a>.GetSize(); i++ )
    {
	const TCandidate* c = (TCandidate*)<a href=".././TTreeNavigator.html#TTreeNavigator:_unstableCands">_unstableCands</a>.At(i);
	const TParticlePDG* pdt=0;
	o &lt;&lt; " | ";
	if( pdt=c-&gt;PdtEntry() )
	    o &lt;&lt; pdt-&gt;GetName();
	else
	    o &lt;&lt; pdt-&gt;Mass();
    }
    o &lt;&lt; " | " &lt;&lt; endl;
<b>    //  printTree( <a href=".././TTreeNavigator.html#TTreeNavigator:_theTree">_theTree</a>, o );</b>
}


<a href="../ListOfTypes.html#Bool_t">Bool_t</a>
<a name="TTreeNavigator:IsCloneOf"> </a><a href=".././TTreeNavigator.html#TTreeNavigator:IsCloneOf">TTreeNavigator::IsCloneOf</a>(const TCandidate&amp; theOtherTree, <a href="../ListOfTypes.html#Bool_t">Bool_t</a> checkType)
{
    return <a href=".././TTreeNavigator.html#TTreeNavigator:_theTree">_theTree</a>-&gt;IsCloneOf(theOtherTree,checkType);
}

  
<b>//</b>
<b>// inline functions</b>
<b>//</b>
<a href="../ListOfTypes.html#int">int</a> 
<a name="TTreeNavigator:NVertex"> </a><a href=".././TTreeNavigator.html#TTreeNavigator:NVertex">TTreeNavigator::NVertex</a>() const
{
    return <a href=".././TTreeNavigator.html#TTreeNavigator:_vertices">_vertices</a>.GetSize();
}

TIterator&amp;
<a name="TTreeNavigator:VertexIterator"> </a><a href=".././TTreeNavigator.html#TTreeNavigator:VertexIterator">TTreeNavigator::VertexIterator</a>()
{
    return *<a href=".././TTreeNavigator.html#TTreeNavigator:_vertices">_vertices</a>.MakeIterator();
}

<a href="../ListOfTypes.html#int">int</a> 
<a name="TTreeNavigator:NFinalCand"> </a><a href=".././TTreeNavigator.html#TTreeNavigator:NFinalCand">TTreeNavigator::NFinalCand</a>() const
{
    return <a href=".././TTreeNavigator.html#TTreeNavigator:_finalCands">_finalCands</a>.GetSize();
}

TIterator&amp;
<a name="TTreeNavigator:FinalCandIterator"> </a><a href=".././TTreeNavigator.html#TTreeNavigator:FinalCandIterator">TTreeNavigator::FinalCandIterator</a>()
{
    return *<a href=".././TTreeNavigator.html#TTreeNavigator:_finalCands">_finalCands</a>.MakeIterator();
}

<a href="../ListOfTypes.html#int">int</a> 
<a name="TTreeNavigator:NUnstableCand"> </a><a href=".././TTreeNavigator.html#TTreeNavigator:NUnstableCand">TTreeNavigator::NUnstableCand</a>() const
{
    return <a href=".././TTreeNavigator.html#TTreeNavigator:_unstableCands">_unstableCands</a>.GetSize();
}

TIterator&amp; 
<a name="TTreeNavigator:UnstableCandIterator"> </a><a href=".././TTreeNavigator.html#TTreeNavigator:UnstableCandIterator">TTreeNavigator::UnstableCandIterator</a>() 
{
    return *<a href=".././TTreeNavigator.html#TTreeNavigator:_unstableCands">_unstableCands</a>.MakeIterator();
}




</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
