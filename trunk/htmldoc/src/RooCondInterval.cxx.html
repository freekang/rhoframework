<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:02:27 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>RooCondInterval - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//////////////////////////////////////////////////////////////////////////</b>
<b>//                                                                      //</b>
<b>// <a href=".././TConditions.html">TConditions</a>	    							//</b>
<b>//                                                                      //</b>
<b>// Conditions database class						//</b>
<b>//                                                                      //</b>
<b>// Author: Marcel Kunze, RUB, Nov. 99					//</b>
<b>// Copyright (C) 1999-2001, Ruhr-University Bochum.			//</b>
<b>//                                                                      //</b>
<b>//////////////////////////////////////////////////////////////////////////</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include "TString.h"
#include "TBtree.h"
#include "TTree.h"
#include "TKey.h"
#include "TNetFile.h"
#include "TAuthenticate.h"

#include "RhoConditions/TConditions.h"
#include "RhoConditions/TBeams.h"
#include "RhoConditions/TDchCond.h"
#include "RhoConditions/TSvtPidCalib.h"

ClassImp(TConditions)

#include &lt;iostream&gt;
using namespace std;

<b>// Constructor</b>

<b>// The default location of the conditions database is expected</b>
<b>// at $TROOT/BaBarConditions.root</b>
<b>// Network access is supported via TNetFile</b>

<a href=".././TConditions.html#TConditions:TConditions">TConditions::TConditions</a>(const <a href="../ListOfTypes.html#char">char</a> *db, const <a href="../ListOfTypes.html#char">char</a> *calibration, const <a href="../ListOfTypes.html#char">char</a> *bcalibration) :
fBeam(0),fPepEnergies(0),fPepBeamSpotCal(0),fPepFillPattern(0),fDchCond(0),fSvtPidCalib(0),
fCurrentTime(0), fReadBeams(kFALSE), fReadDchCond(kFALSE),
fReadPepEnergies(kFALSE), fReadPepBeamSpotCal(kFALSE), fReadPepFillPattern(kFALSE),
fReadPepBoostCal(kFALSE), fReadSvtPidCalib(kFALSE)
{
    TString baseDir = "";
    if (getenv("BFROOT")!=0) baseDir = TString(getenv("BFROOT"))+"/kanga";
    if (getenv("RHOROOT")!=0) baseDir = getenv("RHOROOT");
    
    if (baseDir.Index("root:")&gt;=0) Authorize();

    TString name(db);

<b>    // Special treatment of BFROOT</b>
    if (name.Index("BFROOT")&gt;=0) {
	if (getenv("BFROOT")) {
	    if (name.Index("$env(BFROOT)")&gt;=0) name = getenv("BFROOT") + name(12,name.Length()-12);
	    if (name.Index("$BFROOT")&gt;=0) name = getenv("BFROOT") + name(7,name.Length()-7);
	}
	else {
	    name = "CondDB/BaBarConditions.root";
	    cerr &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: BFROOT not set. Try to open " &lt;&lt; name &lt;&lt; endl;

	}
    }

    if (name == "") name = "CondDB/BaBarConditions.root";
    if (name.Data()[0] != '/' &amp;&amp; name.Data()[0] != '$' &amp;&amp; name.Data()[1] != ':') 
	name = baseDir + "/" + name;

    fFile = TFile::Open(name, "READ","BaBar Conditions Data",1);
    if (fFile == 0)
	cerr &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Error opening conditions file " &lt;&lt; name.Data() &lt;&lt; endl;
    else
	cout &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Opening conditions file " &lt;&lt; name.Data() &lt;&lt; endl;
    
    if (fFile != 0) {
	
	fBeam = new <a href=".././TBeams.html">TBeams</a>();

<b>	// Browse the conditions file to see what containers it has, and create</b>
<b>	// appropriate proxies for each one</b>
	TList *keys= fFile-&gt;GetListOfKeys();
	<a href="../ListOfTypes.html#int">int</a> nContainers= keys-&gt;GetSize()/2;
	for(<a href="../ListOfTypes.html#int">int</a> index= 0; index &lt; nContainers; index++) {
	    TKey *key= (TKey*)(keys-&gt;At(2*index+1));
	    const <a href="../ListOfTypes.html#char">char</a> *className= key-&gt;GetTitle();
	    TString keyName = key-&gt;GetName();
	    if(strcmp(className,"<a href=".././PepBeamsR.html">PepBeamsR</a>") == 0) {
<b>		// Setup the PepBeams interface</b>
		
		fBeamIndex= (TBtree*)fFile-&gt;Get("PepBeamsRIndex");
		fBeamTree= (TTree*)fFile-&gt;Get("<a href=".././PepBeamsR.html">PepBeamsR</a>");
		if (fBeamTree != 0) {
		    fBeamTree-&gt;SetBranchAddress("data", &amp;fBeam);
		    cout &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Setting TTree for " &lt;&lt; className &lt;&lt; endl;
		    fReadBeams = kTRUE;
		}
		else {
		    cerr &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Error setting TTree for " &lt;&lt; className &lt;&lt; endl;
		    fReadBeams = kFALSE;
		}
	    }
	    else if(strcmp(className, "<a href=".././PepEnergiesR.html">PepEnergiesR</a>") == 0) {
<b>		// Setup the <a href=".././PepEnergiesR.html">PepEnergiesR</a> interface</b>
		
		fPepEnergies = new <a href=".././PepEnergiesR.html">PepEnergiesR</a>();
		fPepEnergiesIndex= (TBtree*)fFile-&gt;Get("PepEnergies_PEPIIIndex");
		fPepEnergiesTree= (TTree*)fFile-&gt;Get("PepEnergies_PEPII");
		if (fPepEnergiesTree != 0) {
		    fPepEnergiesTree-&gt;SetBranchAddress("data", &amp;fPepEnergies);
		    cout &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Setting TTree for " &lt;&lt; className &lt;&lt; endl;
		    fReadPepEnergies = kTRUE;
		}
		else {
		    cerr &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Error setting TTree for " &lt;&lt; className &lt;&lt; endl;
		    fReadPepEnergies = kFALSE;
		}
	    }
	    else if(strcmp(className, "<a href=".././PepBeamSpotCalR.html">PepBeamSpotCalR</a>") == 0) {
	      TString calName = TString("PepBeamSpotCal_") + TString(calibration);
	      if (keyName == calName) {
		fPepBeamSpotCal = new <a href=".././PepBeamSpotCalR.html">PepBeamSpotCalR</a>();
		TString index = calName + "Index";
		fPepBeamSpotCalIndex= (TBtree*)fFile-&gt;Get(index);
		fPepBeamSpotCalTree= (TTree*)fFile-&gt;Get(calName);
		if (fPepBeamSpotCalTree != 0) {
		    fPepBeamSpotCalTree-&gt;SetBranchAddress("data", &amp;fPepBeamSpotCal);
		    cout &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Setting TTree for " &lt;&lt; calName.Data() &lt;&lt; endl;
		    fReadPepBeamSpotCal = kTRUE;
		}
		else {
		    cerr &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Error setting TTree for " &lt;&lt; className &lt;&lt; endl;
		    fReadPepBeamSpotCal = kFALSE;
		}
	      }
	    }
	    else if(strcmp(className, "<a href=".././PepFillPatternR.html">PepFillPatternR</a>") == 0) {
<b>		// Setup the <a href=".././PepFillPatternR.html">PepFillPatternR</a> interface</b>
		
		fPepFillPattern = new <a href=".././PepFillPatternR.html">PepFillPatternR</a>();
		fPepFillPatternIndex= (TBtree*)fFile-&gt;Get("PepFillPatternRIndex");
		fPepFillPatternTree= (TTree*)fFile-&gt;Get("<a href=".././PepFillPatternR.html">PepFillPatternR</a>");
		if (fPepFillPatternTree != 0) {
		    fPepFillPatternTree-&gt;SetBranchAddress("data", &amp;fPepFillPattern);
		    cout &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Setting TTree for " &lt;&lt; className &lt;&lt; endl;
		}
		else {
		    cerr &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Error setting TTree for " &lt;&lt; className &lt;&lt; endl;
		    fReadPepFillPattern = kFALSE;
		}
	    }
	    else if(strcmp(className, "<a href=".././PepBoostCalR.html">PepBoostCalR</a>") == 0) {
	      TString calName = TString("PepBoostCal_") + TString(bcalibration);
	      if (keyName == calName) {
		fPepBoostCal = new <a href=".././PepBoostCalR.html">PepBoostCalR</a>();
		TString index = calName + "Index";
		fPepBoostCalIndex= (TBtree*)fFile-&gt;Get(index);
		fPepBoostCalTree= (TTree*)fFile-&gt;Get(calName);
		fReadPepBoostCal = kTRUE;
		if (fPepBoostCalTree != 0) {
		    fPepBoostCalTree-&gt;SetBranchAddress("data", &amp;fPepBoostCal);
		    cout &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Setting TTree for " &lt;&lt; calName.Data() &lt;&lt; endl;
		}
		else {
		    cerr &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Error setting TTree for " &lt;&lt; className &lt;&lt; endl;
		    fReadPepBoostCal = kFALSE;
		}
	      }
	    }
	    else if(strcmp(className, "<a href=".././DchBetheBlochR.html">DchBetheBlochR</a>") == 0) {
<b>		// Setup the DchCond interface</b>
		
		fDchCond = new <a href=".././TDchCond.html">TDchCond</a>();
		fDchCondIndex= (TBtree*)fFile-&gt;Get("DchBetheBlochRIndex");
		fDchCondTree= (TTree*)fFile-&gt;Get("<a href=".././DchBetheBlochR.html">DchBetheBlochR</a>");
		if (fDchCondTree != 0) {
		    fDchCondTree-&gt;SetBranchAddress("data", &amp;fDchCond);
		    cout &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Setting TTree for " &lt;&lt; className &lt;&lt; endl;
		    fReadDchCond = kTRUE;
		}
		else {
		    cerr &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Error setting TTree for " &lt;&lt; className &lt;&lt; endl;
		    fReadDchCond = kFALSE;
		}
	    }
	    else if(strcmp(className, "<a href=".././SvtPidSimpleTMCalibR.html">SvtPidSimpleTMCalibR</a>") == 0) {		
	      if (keyName == "SvtPidCalibP:HitTwoSide") {
		fSvtPidCalib = new <a href=".././TSvtPidCalib.html">TSvtPidCalib</a>();
		TString index = TString(keyName) + "Index";
		fSvtPidCalibIndex= (TBtree*)fFile-&gt;Get(index);
		fSvtPidCalibTree= (TTree*)fFile-&gt;Get(keyName);
		fReadSvtPidCalib = kTRUE;
		if (fSvtPidCalibTree != 0) {
		    fSvtPidCalibTree-&gt;SetBranchAddress("data", &amp;fSvtPidCalib);
		    cout &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Setting TTree for " &lt;&lt; keyName.Data() &lt;&lt; endl;
		}
		else {
		    cerr &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Error setting TTree for " &lt;&lt; className &lt;&lt; endl;
		    fReadSvtPidCalib = kFALSE;
		}
	      }
	    }
	}
    }
    
}

<a href=".././TConditions.html">TConditions</a>::~<a href=".././TConditions.html">TConditions</a>() 
{
    delete fBeam;
    delete fPepEnergies;
    delete fPepBeamSpotCal;
    delete fPepFillPattern;
    delete fPepBoostCal;
    delete fDchCond;
    delete fSvtPidCalib;
    fFile-&gt;Close(); 
}

<b>// Trigger the input of a suiting beam info object</b>
<b>// Time is given in seconds since 1/1/1901</b>

<a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href=".././TConditions.html#TConditions:At">TConditions::At</a>(<a href=".././TRhoTime.html">TRhoTime</a> t)
{
    return At(t.Seconds());
}

<a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href=".././TConditions.html#TConditions:At">TConditions::At</a>(<a href="../ListOfTypes.html#ULong_t">ULong_t</a> when) {
    
    <a href="../ListOfTypes.html#Bool_t">Bool_t</a> valid = kFALSE;
    
    TCondKey key(when);
    
<b>    // Read beam info</b>
    
    if (fReadPepEnergies) {
	const <a href=".././RooCondInterval.html">RooCondInterval</a>* entry= (const <a href=".././RooCondInterval.html">RooCondInterval</a>*)(fPepEnergiesIndex-&gt;FindObject(&amp;key));
	if(entry!=0) {
	    <a href="../ListOfTypes.html#int">int</a> index = entry-&gt;<a href="#RooCondInterval:index">index</a>();
	    fPepEnergiesTree-&gt;GetEntry(index);
	    valid = kTRUE;
	    fCurrentTime = when;
	}
	else
	    cerr &lt;&lt; "Error in reading PepEnergies index at (UTC)" &lt;&lt; <a href=".././TRhoTime.html">TRhoTime</a>(when) &lt;&lt; endl;
    }
    
    if (fReadPepBeamSpotCal) {
	const <a href=".././RooCondInterval.html">RooCondInterval</a>* entry= (const <a href=".././RooCondInterval.html">RooCondInterval</a>*)(fPepBeamSpotCalIndex-&gt;FindObject(&amp;key));
	if(entry!=0) {
	    <a href="../ListOfTypes.html#int">int</a> index = entry-&gt;<a href="#RooCondInterval:index">index</a>();
	    fPepBeamSpotCalTree-&gt;GetEntry(index);
	    valid = kTRUE;
	    fCurrentTime = when;
	}
	else
	    cerr &lt;&lt; "Error in reading PepBeamSpotCal index at (UTC)" &lt;&lt; <a href=".././TRhoTime.html">TRhoTime</a>(when) &lt;&lt; endl;
    }
    
    if (fReadPepFillPattern) {
	const <a href=".././RooCondInterval.html">RooCondInterval</a>* entry= (const <a href=".././RooCondInterval.html">RooCondInterval</a>*)(fPepFillPatternIndex-&gt;FindObject(&amp;key));
	if(entry!=0) {
	    <a href="../ListOfTypes.html#int">int</a> index = entry-&gt;<a href="#RooCondInterval:index">index</a>();
	    fPepFillPatternTree-&gt;GetEntry(index);
	    valid = kTRUE;
	    fCurrentTime = when;
	}
	else
	    cerr &lt;&lt; "Error in reading PepFillPattern index  at (UTC)" &lt;&lt; <a href=".././TRhoTime.html">TRhoTime</a>(when) &lt;&lt; endl;
    }
    
    if (fReadPepBoostCal) {
	const <a href=".././RooCondInterval.html">RooCondInterval</a>* entry= (const <a href=".././RooCondInterval.html">RooCondInterval</a>*)(fPepBoostCalIndex-&gt;FindObject(&amp;key));
	if(entry!=0) {
	    <a href="../ListOfTypes.html#int">int</a> index = entry-&gt;<a href="#RooCondInterval:index">index</a>();
	    fPepBoostCalTree-&gt;GetEntry(index);
	    valid = kTRUE;
	    fCurrentTime = when;
	}
	else
	    cerr &lt;&lt; "Error in reading PepBoostCal index at (UTC)" &lt;&lt; <a href=".././TRhoTime.html">TRhoTime</a>(when) &lt;&lt; endl;
    }
    
    if (fReadBeams) {
	const <a href=".././RooCondInterval.html">RooCondInterval</a>* entry= (const <a href=".././RooCondInterval.html">RooCondInterval</a>*)(fBeamIndex-&gt;FindObject(&amp;key));
	if(entry!=0) {
	    <a href="../ListOfTypes.html#int">int</a> index = entry-&gt;<a href="#RooCondInterval:index">index</a>();
	    fBeamTree-&gt;GetEntry(index);
	    valid = kTRUE;
	    fCurrentTime = when;
	}
	else
	    cerr &lt;&lt; "Error in reading beam index at (UTC)" &lt;&lt; <a href=".././TRhoTime.html">TRhoTime</a>(when) &lt;&lt; endl;
    }
    else {
<b>	// The new conditions data holds energy and calibration</b>
	if (fPepEnergies!=0 &amp;&amp; fPepBeamSpotCal!=0)
	  fBeam-&gt;Update(*fPepEnergies,*fPepBeamSpotCal);
	else
	  cerr &lt;&lt; "<a href=".././TConditions.html">TConditions</a>: Could not update <a href=".././TBeams.html">TBeams</a>" &lt;&lt; endl;
    }

    
<b>    // Read Dch info</b>
    
    if (fReadDchCond) {
	const <a href=".././RooCondInterval.html">RooCondInterval</a>* entry= (const <a href=".././RooCondInterval.html">RooCondInterval</a>*)(fDchCondIndex-&gt;FindObject(&amp;key));
	if(entry!=0) {
	    <a href="../ListOfTypes.html#int">int</a> index = entry-&gt;<a href="#RooCondInterval:index">index</a>();
	    fDchCondTree-&gt;GetEntry(index);
	    valid = kTRUE;
	    fCurrentTime = when;
	}
	else
	    cerr &lt;&lt; "Error in reading DchCond index at (UTC)" &lt;&lt; <a href=".././TRhoTime.html">TRhoTime</a>(when) &lt;&lt; endl;
    }
    
    
<b>    // Read SVT info</b>
    
    if (fReadSvtPidCalib) {
	const <a href=".././RooCondInterval.html">RooCondInterval</a>* entry= (const <a href=".././RooCondInterval.html">RooCondInterval</a>*)(fSvtPidCalibIndex-&gt;FindObject(&amp;key));
	if(entry!=0) {
	    <a href="../ListOfTypes.html#int">int</a> index = entry-&gt;<a href="#RooCondInterval:index">index</a>();
	    fSvtPidCalibTree-&gt;GetEntry(index);
	    valid = kTRUE;
	    fCurrentTime = when;
	}
	else
	    cerr &lt;&lt; "Error in reading SvtPidCalib index at (UTC)" &lt;&lt; <a href=".././TRhoTime.html">TRhoTime</a>(when) &lt;&lt; endl;
    }
    
    
    return valid;
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././TConditions.html#TConditions:Authorize">TConditions::Authorize</a>(const <a href="../ListOfTypes.html#char">char</a> *u, const <a href="../ListOfTypes.html#char">char</a> *p)
{
<b>// Authorization for ROOTD might be explicit or by use of environment variables</b>

    TString user,passwd;

    if (u != 0)
       user = u;
    else
       if (getenv("RHOUSER")!=0)  user = getenv("RHOUSER");

    if (p != 0)
       passwd = p;
    else
       if (getenv("RHOPASSWD")!=0) passwd = getenv("RHOPASSWD");

    cout &lt;&lt; "<a href=".././TConditions.html#TConditions:Authorize">TConditions::Authorize</a> " &lt;&lt; user.Data() &lt;&lt; " for ROOTD access" &lt;&lt; endl;

    TAuthenticate::SetGlobalUser(user); 
    TAuthenticate::SetGlobalPasswd(passwd);
}

<b>// Print the conditions data</b>

<a href="../ListOfTypes.html#void">void</a> <a href=".././TConditions.html#TConditions:PrintOn">TConditions::PrintOn</a>(std::ostream&amp; o) const
{
    o &lt;&lt; endl;
    o &lt;&lt; "Conditions info at (UTC): " &lt;&lt; <a href=".././TRhoTime.html">TRhoTime</a>(fCurrentTime) &lt;&lt; endl;
    if (fBeam!=0) o &lt;&lt; *fBeam &lt;&lt; endl;
    if (fReadPepEnergies &amp;&amp; fPepEnergies!=0) o &lt;&lt; *fPepEnergies &lt;&lt; endl;
    if (fReadPepBeamSpotCal &amp;&amp; fPepBeamSpotCal!=0) o &lt;&lt; *fPepBeamSpotCal &lt;&lt; endl;
    if (fReadPepFillPattern &amp;&amp; fPepFillPattern!=0) o &lt;&lt; *fPepFillPattern &lt;&lt; endl;
    if (fReadPepBoostCal &amp;&amp; fPepBoostCal!=0) o &lt;&lt; *fPepBoostCal &lt;&lt; endl;
    if (fReadDchCond &amp;&amp; fDchCond!=0) o &lt;&lt; *fDchCond &lt;&lt; endl;
    if (fReadSvtPidCalib &amp;&amp; fSvtPidCalib!=0) o &lt;&lt; *fSvtPidCalib &lt;&lt; endl;
}


<b>// --------------------</b>
<b>// non-member functions</b>
<b>// --------------------</b>

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././TConditions.html">TConditions</a>&amp; a) {a.PrintOn(o); return o;}


ClassImp(<a href=".././RooCondInterval.html">RooCondInterval</a>)

<a name="RooCondInterval:RooCondInterval"> </a><a href=".././RooCondInterval.html#RooCondInterval:RooCondInterval">RooCondInterval::RooCondInterval</a>()
{
<b>    // don't set valid bit in the default ctor</b>
}

<a name="RooCondInterval:~RooCondInterval"> </a><a href=".././RooCondInterval.html">RooCondInterval</a>::~<a href=".././RooCondInterval.html">RooCondInterval</a>() { }

<a name="RooCondInterval:IsSortable"> </a><a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href=".././RooCondInterval.html#RooCondInterval:IsSortable">RooCondInterval::IsSortable</a>() const {
    return kTRUE;
}

<a name="RooCondInterval:Compare"> </a><a href="../ListOfTypes.html#Int_t">Int_t</a> <a href=".././RooCondInterval.html#RooCondInterval:Compare">RooCondInterval::Compare</a>(const TObject* other) const {
    <a href="../ListOfTypes.html#UInt_t">UInt_t</a> key= other-&gt;GetUniqueID();
    if(key &lt; GetUniqueID()) return +1; // we are "larger" than the other object
    if(key &gt;= <a href=".././RooCondInterval.html#RooCondInterval:_end">_end</a>) return -1;  // we are "smaller" than the other object
    return 0; // we are "equal" to the other object
}


ClassImp(<a href=".././RooCondData.html">RooCondData</a>)

<a href=".././RooCondData.html#RooCondData:RooCondData">RooCondData::RooCondData</a>() { }

<a href=".././RooCondData.html">RooCondData</a>::~<a href=".././RooCondData.html">RooCondData</a>() { }

<a href="../ListOfTypes.html#Stat_t">Stat_t</a> <a href=".././RooCondData.html#RooCondData:Store">RooCondData::Store</a>(TBranch&amp; where) const {
    <a href="../ListOfTypes.html#Stat_t">Stat_t</a> index= where.GetEntries();
    where.Fill();
    return index;
}

</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
