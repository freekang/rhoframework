<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:02:42 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TCandReader - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//===================================================================</b>
<b>// File and Version Information:</b>
<b>// 	$Id: TCandReader.cxx.html,v 1.1.1.1 2002-12-20 15:05:30 marcel Exp $</b>
<b>//</b>
<b>//-----------------------------------------------------------------</b>
<b>// Description:</b>
<b>//	See <a href=".././TCandReader.html">TCandReader</a>.h</b>
<b>//</b>
<b>//-------------------------------------------------------------------</b>
<b>// Sample User Code:</b>
<b>//</b>
<b>//------------------------------------------------------------------</b>
<b>// Environment:</b>
<b>//	Software developed for the BaBar Detector at the SLAC B-Factory.</b>
<b>//</b>
<b>//------------------------------------------------------------------</b>
<b>// Author List:</b>
<b>//	Abi Soffer              (Original author)</b>
<b>//</b>
<b>//--------------------------------------------------------------------------</b>
<b>// Copyright Information:</b>
<b>//	Copyright (C) 1998	Colorado State University</b>
<b>//</b>
<b>// ROOT Version by Marcel Kunze, RUB</b>
<b>//==========================================================================</b>

<b>//---------------</b>
<b>// C++ Headers --</b>
<b>//---------------</b>
#include &lt;strstream&gt;
#include &lt;ctype.h&gt;

<b>//-----------------------</b>
<b>// This Class's Header --</b>
<b>//-----------------------</b>

#include "RhoTools/TCandReader.h"

<b>//-------------------------------</b>
<b>// Collaborating Class Headers --</b>
<b>//-------------------------------</b>
#include "TVector3.h"
#include "RhoBase/TRho.h"
#include "RhoBase/TFactory.h"
#include "RhoBase/TCandidate.h"
#include "RhoTools/TOpAdd4.h"
#include "RhoTools/TOpMakeTree.h"
#include "RhoTools/TAdd4Vertexer.h"

<b>//-----------------------------------------------------------------------</b>
<b>// Local Macros, Typedefs, Structures, Unions and Forward Declarations --</b>
<b>//-----------------------------------------------------------------------</b>

ClassImp(<a href=".././TCandReader.html">TCandReader</a>)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, <a href=".././TCandReader.html">TCandReader</a> *&amp;obj)
{
   obj = (<a href=".././TCandReader.html">TCandReader</a> *) buf.ReadObject(<a href=".././TCandReader.html#TCandReader:Class">TCandReader::Class</a>());
   return buf;
}

#include &lt;iostream&gt;
using namespace std;

<b>//---------------------------</b>
<b>//-- Static Data definitions:</b>
<b>//---------------------------</b>
<b>// This is how subclasses of <a href=".././TCandReader.html">TCandReader</a> register their instances with the </b>
<b>// static registry:</b>


<a href="../ListOfTypes.html#Bool_t">Bool_t</a> TCandReaderName::_registered = kFALSE;
<a href="../ListOfTypes.html#Bool_t">Bool_t</a> TCandReaderNameMom::_registered = kFALSE;
<a href="../ListOfTypes.html#Bool_t">Bool_t</a> TCandReaderNameVtx::_registered = kFALSE;
<a href="../ListOfTypes.html#Bool_t">Bool_t</a> TCandReaderNameMomVtx::_registered = kFALSE;

<b>//------------------------------------------------</b>
<b>// Class <a href=".././TCandReader.html">TCandReader</a> Static Function Definitions:</b>
<b>//------------------------------------------------</b>

<a href="../ListOfTypes.html#Bool_t">Bool_t</a> 
<a name="TCandReader:IsDelimiter"> </a><a href=".././TCandReader.html#TCandReader:IsDelimiter">TCandReader::IsDelimiter</a>(<a href="../ListOfTypes.html#char">char</a> c) const {
    return (c == <a href="#TCandReader:Open">Open</a>() || c == <a href="#TCandReader:Separate">Separate</a>() || c == <a href="#TCandReader:Close">Close</a>());
}

<b>//-------------------------------------------------------------------</b>
const <a href=".././TCandReader.html">TCandReader</a> * 
<a name="TCandReader:Find"> </a><a href=".././TCandReader.html#TCandReader:Find">TCandReader::Find</a>(const <a href="../ListOfTypes.html#char">char</a> * name) {
    return <a href="#TCandReader:modifyRegistry">modifyRegistry</a>().<a href="#TCandReader:Find">Find</a>(name);
}

<b>//----------------------------------------------------------------------</b>
<a href="../ListOfTypes.html#Bool_t">Bool_t</a> 
<a name="TCandReader:Book"> </a><a href=".././TCandReader.html#TCandReader:Book">TCandReader::Book</a>(<a href=".././TCandReader.html">TCandReader</a> * instance, const <a href="../ListOfTypes.html#char">char</a> * file, <a href="../ListOfTypes.html#int">int</a> line) {
    <a href="../ListOfTypes.html#Bool_t">Bool_t</a> result = <a href="#TCandReader:modifyRegistry">modifyRegistry</a>().<a href="#TCandReader:Book">Book</a>(instance, file, line);
    if (kFALSE == result){
	const <a href=".././TCandReader.html">TCandReader</a> * otherReader = <a href="#TCandReader:registry">registry</a>().<a href="#TCandReader:Find">Find</a>(instance-&gt;<a href="#TCandReader:Name">Name</a>());
	<a href="../ListOfTypes.html#int">int</a> otherLine = <a href="#TCandReader:registry">registry</a>().Line(otherReader);
	const <a href="../ListOfTypes.html#char">char</a> * otherFile = <a href="#TCandReader:registry">registry</a>().File(otherReader);
	
	if (instance != otherReader){
	    cerr 
		&lt;&lt; "ERROR: <a href=".././TCandReader.html">TCandReader</a>: Attempt to book a <a href=".././TCandReader.html">TCandReader</a> named ""
		&lt;&lt; instance-&gt;<a href="#TCandReader:Name">Name</a>() &lt;&lt; """ &lt;&lt; endl
		&lt;&lt; "       in line " &lt;&lt; line &lt;&lt; " of " &lt;&lt; file &lt;&lt; endl
		&lt;&lt; "       when a <a href=".././TCandReader.html">TCandReader</a> with this name was already booked in "
		&lt;&lt; "line " &lt;&lt; otherLine &lt;&lt; " of" &lt;&lt; endl
		&lt;&lt; "       " &lt;&lt; otherFile &lt;&lt; "." &lt;&lt; endl
		&lt;&lt; "       The second <a href=".././TCandReader.html">TCandReader</a> is deleted and not registered."
		&lt;&lt; endl;
	    
	    delete instance;
	    instance = 0;      
	}
	else { 
	    cerr
		&lt;&lt; "ERROR: <a href=".././TCandReader.html">TCandReader</a>: Attempt to book the <a href=".././TCandReader.html">TCandReader</a> named ""
		&lt;&lt; instance-&gt;<a href="#TCandReader:Name">Name</a>() &lt;&lt; """ &lt;&lt; endl
		&lt;&lt; "       in line " &lt;&lt; line &lt;&lt; " of " &lt;&lt; file &lt;&lt; endl
		&lt;&lt; "       when it was already booked in line " &lt;&lt; otherLine
		&lt;&lt; " of" &lt;&lt; endl
		&lt;&lt; "       " &lt;&lt; otherFile &lt;&lt; "." &lt;&lt; endl
		&lt;&lt; "       Booking attempt ignored."
		&lt;&lt; endl;
	}
    }
    return result;
}

<b>//----------------------------------------------------------------------</b>
TCandReaderRegistry &amp; 
<a name="TCandReader:modifyRegistry"> </a><a href=".././TCandReader.html#TCandReader:modifyRegistry">TCandReader::modifyRegistry</a>() {
    static TCandReaderRegistry result;
    return result;
}

<b>//----------------------------------------------------------------------</b>
const TCandReaderRegistry &amp; 
<a name="TCandReader:registry"> </a><a href=".././TCandReader.html#TCandReader:registry">TCandReader::registry</a>() {
    return <a href="#TCandReader:modifyRegistry">modifyRegistry</a>();
}

<b>//---------------------------------------------------------------</b>
<b>// Class TCandReaderRegistry Public Member Function Definitions:</b>
<b>//---------------------------------------------------------------</b>
TCandReaderRegistry::~TCandReaderRegistry() {
    _items.Delete();
}

<b>//-----------------------------------------------------------------------</b>
<a href="../ListOfTypes.html#Bool_t">Bool_t</a> 
TCandReaderRegistry::<a href="#TCandReader:Book">Book</a>(<a href=".././TCandReader.html">TCandReader</a> * reader, 
			  const <a href="../ListOfTypes.html#char">char</a> * file, <a href="../ListOfTypes.html#int">int</a> line) {
<b>    // First, make sure no other instance of name exists:</b>
    if (0 != <a href="#TCandReader:Find">Find</a>(reader-&gt;<a href="#TCandReader:Name">Name</a>())){
	return kFALSE;
    }
    else{
	_items.Add((TObject*)new Item(reader, reader-&gt;<a href="#TCandReader:Name">Name</a>(), file, line));
	return kTRUE;
    }
}

<b>//----------------------------------------------------------------------</b>
const <a href=".././TCandReader.html">TCandReader</a> * 
TCandReaderRegistry::<a href="#TCandReader:Find">Find</a>(const <a href="../ListOfTypes.html#char">char</a> * name) const {
    for (<a href="../ListOfTypes.html#int">int</a> item = 0; item &lt; _items.GetSize(); ++item){
	if (name == ((Item*)_items.At(item))-&gt;_name){
	    return ((Item*)_items.At(item))-&gt;_reader;
	}
    }
    return 0;
}

<b>//----------------------------------------------------------------------</b>
const <a href="../ListOfTypes.html#char">char</a> * 
TCandReaderRegistry::File(const <a href=".././TCandReader.html">TCandReader</a> * reader) const {
    const Item * it = item(reader);
    if (0 != it){
	return it-&gt;_file;
    }
    else {
	return 0;
    }
}

<b>//----------------------------------------------------------------------</b>
<a href="../ListOfTypes.html#int">int</a> 
TCandReaderRegistry::Line(const <a href=".././TCandReader.html">TCandReader</a> * reader) const {
    const Item * it = item(reader);
    if (0 != it){
	return it-&gt;_line;
    }
    else {
	return -1;
    }
}

<b>//-----------------------------------------------------------</b>
<b>// Class TCandReaderName Public Member Function Definitions:</b>
<b>//-----------------------------------------------------------</b>
<b>// This function expects str to contain the name of the candidate:</b>
TCandidate *
TCandReaderName::<a href="#TCandReader:Read">Read</a>(<a href=".././TCandReader.html#TCandReader:Status">TCandReader::Status</a> &amp; status, 
		      const TString &amp; str,
		      TCandListIterator* input) const {
    TCandidate * result = 0;
    
<b>    // The first substring in str with no white spaces:</b>
    TString strNoWhite = str;//.Car();
    
<b>    // If the iterator is valid, make the candidate from the daughters:</b>
    if (0 != input){
	<a href=".././TOpAdd4.html">TOpAdd4</a> add4;
	result = add4.CreateFromList(*input);
    }
    else {
	result = TFactory::Instance()-&gt;NewCandidate();
    }
    
    const TParticlePDG * pdtEntry = TRho::Instance()-&gt;GetPDG()-&gt;GetParticle(strNoWhite);
    if (0 == pdtEntry){
	status = <a href=".././TCandReader.html#TCandReader:UNKNOWN">UNKNOWN</a>;
    }
    else{
	result-&gt;SetType(pdtEntry);
	status = <a href=".././TCandReader.html#TCandReader:SUCCESS">SUCCESS</a>;
    }
    
    return result;
}

<b>//--------------------------------------------------------------</b>
<b>// Class TCandReaderNameMom Public Member Function Definitions:</b>
<b>//--------------------------------------------------------------</b>
<b>//---------------------------------------------------------------</b>
<b>// This function expects str to contain the name of the particle, followed </b>
<b>// by a 3-momentum in the format "(x,y,z)". Spaces are allowed, and commas</b>
<b>// can be replaced by spaces. Brackets must exist.</b>
TCandidate *
TCandReaderNameMom::<a href="#TCandReader:Read">Read</a>(<a href=".././TCandReader.html#TCandReader:Status">TCandReader::Status</a> &amp; status, 
			 const TString &amp; str,
			 TCandListIterator* input) const {
    TCandidate * result = 0;
    
<b>    // Read the name, up to the '(' of the 3-momentum or another delimiter</b>
<b>    // or space:</b>
    TString name;
    istrstream stream((<a href="../ListOfTypes.html#char">char</a>*)(const <a href="../ListOfTypes.html#char">char</a>*)str);
    <a href="../ListOfTypes.html#char">char</a> c;
    while (EOF != (c = stream.get()) &amp;&amp; stream.good()){
<b>	// If start of vector or delimiter, then end of name, push delimiter back:</b>
	if ('(' == c || <a href="#TCandReader:IsDelimiter">IsDelimiter</a>(c) || (isspace(c) &amp;&amp; !name.IsNull())) {
	    stream.putback(c);
	    break;
	}
	else{
	    if (0 == isspace(c)){
		name += c;
	    }
	}
    }
    
    TVector3 mom3 = <a href="#TCandReader:ReadVector">ReadVector</a>(stream);
<b>    //stream &gt;&gt; mom3;</b>
    TLorentzVector mom(mom3, 0.0);
    
<b>    // If the iterator is valid, make the candidate from the daughters.</b>
<b>    // Don't take the momentum from the string, but from the daughters:</b>
    if (0 != input){
	<a href=".././TOpAdd4.html">TOpAdd4</a> add4;
	result = add4.CreateFromList(*input);
    }
    else { // take the momentum from the string for non-composites:
	result = TFactory::Instance()-&gt;NewCandidate(TCandidate(mom, 0.0));
    }
    
    const TParticlePDG * pdtEntry = TRho::Instance()-&gt;GetPDG()-&gt;GetParticle(name);
    if (0 == pdtEntry){
	status = <a href=".././TCandReader.html#TCandReader:UNKNOWN">UNKNOWN</a>;
    }
    else{
	result-&gt;SetType(pdtEntry);
	status = <a href=".././TCandReader.html#TCandReader:SUCCESS">SUCCESS</a>;
    }
    
    return result;
}


<b>//----------------------------------------------------------------</b>
<b>// Class TCandReaderNameVtx Public Member Function Definitions:</b>
<b>//----------------------------------------------------------------</b>
<b>//---------------------------------------------------------------</b>
<b>// This function expects str to contain the name of the particle, followed </b>
<b>// by a HepPoint in the format "(x,y,z)". Spaces are allowed, and commas</b>
<b>// can be replaced by spaces. Brackets must exist.</b>
TCandidate *
TCandReaderNameVtx::<a href="#TCandReader:Read">Read</a>(<a href=".././TCandReader.html#TCandReader:Status">TCandReader::Status</a> &amp; status, 
			 const TString &amp; str,
			 TCandListIterator* input) const {
    TCandidate * result = 0;
    
<b>    // Read the name, up to the '(' of the point or another delimiter or space:</b>
    TString name;
    istrstream stream((<a href="../ListOfTypes.html#char">char</a>*)(const <a href="../ListOfTypes.html#char">char</a>*)str);
    <a href="../ListOfTypes.html#char">char</a> c;
    while (EOF != (c = stream.get()) &amp;&amp; stream.good()){
<b>	// If start of point or delimiter, then end of name, push delimiter back:</b>
	if ('(' == c || <a href="#TCandReader:IsDelimiter">IsDelimiter</a>(c) || (isspace(c) &amp;&amp; !name.IsNull())) {
	    stream.putback(c);
	    break;
	}
	else{
	    if (0 == isspace(c)){
		name += c;
	    }
	}
    }
    
    TVector3 point = <a href="#TCandReader:ReadVector">ReadVector</a>(stream);;
<b>    //stream &gt;&gt; point;</b>
<b>    //ghm  TSimpleVertex vertex(point);</b>
    <a href=".././TAdd4Vertexer.html">TAdd4Vertexer</a> vertexer(point);
    
<b>    // If the iterator is valid, make the candidate from the daughters.</b>
<b>    // Don't take the momentum from the string, but from the daughters:</b>
    if (0 != input){
<b>	//ghm    TFixedVertexer vertexer(vertex);</b>
	<a href=".././TOpMakeTree.html">TOpMakeTree</a> makeTree(vertexer);
	result = makeTree.CreateFromList(*input);
    }
    else { // take the point from the string for non-composites:
	result = TFactory::Instance()-&gt;NewCandidate(
	    TCandidate(TLorentzVector(), 0.0, 
	    TFactory::Instance()-&gt;NewVertex(TSimpleVertex(point))));
    }
    
    const TParticlePDG * pdtEntry = TRho::Instance()-&gt;GetPDG()-&gt;GetParticle(name);
    if (0 == pdtEntry){
	status = <a href=".././TCandReader.html#TCandReader:UNKNOWN">UNKNOWN</a>;
    }
    else{
	result-&gt;SetType(pdtEntry);
	status = <a href=".././TCandReader.html#TCandReader:SUCCESS">SUCCESS</a>;
    }
    
    return result;
}

<b>//-------------------------------------------------------------------</b>
<b>// Class TCandReaderNameMomVtx Public Member Function Definitions:</b>
<b>//-------------------------------------------------------------------</b>
<b>//---------------------------------------------------------------</b>
<b>// This function expects str to contain the name of the particle, followed </b>
<b>// by a HepPoint in the format "(x,y,z)". Spaces are allowed, and commas</b>
<b>// can be replaced by spaces. Brackets must exist.</b>
TCandidate *
TCandReaderNameMomVtx::<a href="#TCandReader:Read">Read</a>(<a href=".././TCandReader.html#TCandReader:Status">TCandReader::Status</a> &amp; status, 
			    const TString &amp; str,
			    TCandListIterator* input) const {
    TCandidate * result = 0;
    
<b>    // Read the name, up to the '(' of the 3-momentum or another delimiter </b>
<b>    // or space</b>
    TString name;
    istrstream stream((<a href="../ListOfTypes.html#char">char</a>*)(const <a href="../ListOfTypes.html#char">char</a>*)str);
    <a href="../ListOfTypes.html#char">char</a> c;
    while (EOF != (c = stream.get()) &amp;&amp; stream.good()){
<b>	// If start of mom or delimiter, then end of name, push delimiter back:</b>
	if ('(' == c || <a href="#TCandReader:IsDelimiter">IsDelimiter</a>(c) || (isspace(c) &amp;&amp; !name.IsNull())) {
	    stream.putback(c);
	    break;
	}
	else{
	    if (0 == isspace(c)){
		name += c;
	    }
	}
    }
    
    TVector3 mom3 = <a href="#TCandReader:ReadVector">ReadVector</a>(stream);
<b>    //stream &gt;&gt; mom3;</b>
    TLorentzVector mom(mom3, 0.0);
    
    TVector3 point= <a href="#TCandReader:ReadVector">ReadVector</a>(stream);;
<b>    //stream &gt;&gt; point;</b>
<b>    //ghm  TSimpleVertex vertex(point);</b>
    <a href=".././TAdd4Vertexer.html">TAdd4Vertexer</a> vertexer(point);
    
<b>    // If the iterator is valid, make the candidate from the daughters.</b>
<b>    // Don't take the momentum from the string, but from the daughters:</b>
    if (0 != input){
<b>	//ghm    TFixedVertexer vertexer(vertex);</b>
	<a href=".././TOpMakeTree.html">TOpMakeTree</a> makeTree(vertexer);
	result = makeTree.CreateFromList(*input);
    }
    else { // take 3-momentum and point from the string for non-composites:
	result = TFactory::Instance()-&gt;NewCandidate(
	    TCandidate(mom, 0.0, 
	    TFactory::Instance()-&gt;NewVertex(TSimpleVertex(point))));
    }
    
    const TParticlePDG * pdtEntry = TRho::Instance()-&gt;GetPDG()-&gt;GetParticle(name);
    if (0 == pdtEntry){
	status = <a href=".././TCandReader.html#TCandReader:UNKNOWN">UNKNOWN</a>;
    }
    else{
	result-&gt;SetType(pdtEntry);
	status = <a href=".././TCandReader.html#TCandReader:SUCCESS">SUCCESS</a>;
    }
    
    return result;
}

<a name="TCandReader:ReadVector"> </a>			    TVector3 <a href=".././TCandReader.html#TCandReader:ReadVector">TCandReader::ReadVector</a>(std::istream &amp; s) {
    TVector3 q;
<b>    // Parse:</b>
    TString cleanString;
    <a href="../ListOfTypes.html#char">char</a> c;
    <a href="../ListOfTypes.html#int">int</a> numRead = 0;
    <a href="../ListOfTypes.html#Bool_t">Bool_t</a> previosIsSpace = kFALSE;
    
    while(EOF != (c = s.get()) &amp;&amp; c != ')' &amp;&amp; s.good()) {
<b>	// ignore initial bracket or spaces</b>
	if (!cleanString.IsNull() || ('(' != c &amp;&amp; 0 == isspace(c))){            
	    if (',' == c){          // replace ',' with ' '
		c = ' ';
	    }
	    cleanString += c;     // take c
	    if (isspace(c)){      // count # of white spaces (excluding initials)
		if (kFALSE == previosIsSpace) {
		    ++numRead;
		}
		previosIsSpace = kTRUE;
		if (numRead &gt;= 12){  // read enough
		    break;
		}
	    }
	    else {
		previosIsSpace = kFALSE;
	    }
	}
    }
    
    istrstream newStream((<a href="../ListOfTypes.html#char">char</a>*)(const <a href="../ListOfTypes.html#char">char</a>*)cleanString);
    <a href="../ListOfTypes.html#double">double</a> xx(q.X()), yy(q.Y()), zz(q.Z());
    newStream &gt;&gt; xx &gt;&gt; yy &gt;&gt; zz;
    q.SetX(xx);
    q.SetY(yy);
    q.SetZ(zz);
    
    return q;
}

</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
