<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:02:47 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TDimuonAodSelector - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//////////////////////////////////////////////////////////////////////////</b>
<b>//                                                                      //</b>
<b>// <a href=".././TEventSelector.html">TEventSelector</a>							//</b>
<b>//                                                                      //</b>
<b>// Selector classes for event selection                                 //</b>
<b>//                                                                      //</b>
<b>// Author List:                                                         //</b>
<b>// Marcel Kunze,  RUB, Feb. 99                                          //</b>
<b>// Copyright (C) 1999-2001, Ruhr-University Bochum.                     //</b>
<b>//                                                                      //</b>
<b>//////////////////////////////////////////////////////////////////////////</b>

#include &lt;stdlib.h&gt;
#include "RhoBase/TRho.h"
#include "RhoBase/VAbsReader.h"
#include "RhoSelector/TEventSelector.h"
#include "RhoSelector/TPidSelector.h"
#include "RhoBase/TCandidate.h"
#include "RhoConditions/TConditions.h"
#include "RhoConditions/TBeams.h"
#include "RhoBase/VAbsTag.h"
#include "RhoBase/VAbsBit.h"

ClassImp(TEventSelector)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, TEventSelector *&amp;obj)
{
   obj = (TEventSelector *) buf.ReadObject(TEventSelector::Class());
   return buf;
}

#include &lt;iostream&gt;
using namespace std;

void TEventSelector::PrintOn(std::ostream&amp; o) const 
{
    o &lt;&lt; GetName() &lt;&lt; " settings:";
    if (fTight) o &lt;&lt; " Tight mode";
    o &lt;&lt; endl;
    o &lt;&lt; "Number of Tracks        = "  &lt;&lt; fNTracksMin &lt;&lt; " ... " &lt;&lt; fNTracksMax &lt;&lt; endl; 
    if (fDocaMax &lt; 1.E8)  o &lt;&lt; "Primary vertex (d,-z,z) &lt; ("  &lt;&lt; fDocaMax &lt;&lt; ',' &lt;&lt; fZMin &lt;&lt; ',' &lt;&lt; fZMax &lt;&lt; ')' &lt;&lt; endl; 
    if (fTotChar &lt; 65535) o &lt;&lt; "Total charge            &lt; " &lt;&lt; fTotChar &lt;&lt; endl; 
    if (fETotLow &gt; 0.0)   o &lt;&lt; "Total energy            = " &lt;&lt; fETotLow   &lt;&lt; " ... " &lt;&lt; fETotHigh &lt;&lt; " GeV" &lt;&lt; endl; 
    if (fPTotLow &gt; 0.0)   o &lt;&lt; "Total momentum          = " &lt;&lt; fPTotLow &lt;&lt;   " ... " &lt;&lt; fPTotHigh &lt;&lt; " GeV" &lt;&lt; endl; 
    if (fELow &gt; 0.0)      o &lt;&lt; "Track energy            = " &lt;&lt; fELow   &lt;&lt; " ... " &lt;&lt; fEHigh &lt;&lt; " GeV" &lt;&lt; endl; 
    if (fPLow &gt; 0.0)      o &lt;&lt; "Track momentum          = " &lt;&lt; fPLow &lt;&lt;   " ... " &lt;&lt; fPHigh &lt;&lt; " GeV" &lt;&lt; endl; 
    if (fPtLow &gt; 0.0)     o &lt;&lt; "Track Pt                = " &lt;&lt; fPtLow &lt;&lt;   " ... " &lt;&lt; fPtHigh &lt;&lt; " GeV" &lt;&lt; endl; 
    if (fEmcLow &gt; 0.0)    o &lt;&lt; "Track EMC energy        = " &lt;&lt; fEmcLow &lt;&lt; " ... " &lt;&lt; fEmcHigh &lt;&lt; " GeV" &lt;&lt; endl; 
    if (fThetaLow &gt; 0.0)  o &lt;&lt; "Track theta window      = " &lt;&lt; fThetaLow &lt;&lt; " ... " &lt;&lt; fThetaHigh &lt;&lt; " Rad" &lt;&lt; endl; 
    if (fPhiLow &gt; 0.0)    o &lt;&lt; "Track phi window        = " &lt;&lt; fPhiLow &lt;&lt; " ... " &lt;&lt; fPhiHigh &lt;&lt; " Rad" &lt;&lt; endl; 
    o &lt;&lt; endl;    
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const TEventSelector&amp; a) { a.PrintOn(o); return o; }


ClassImp(TTagBaseSelector)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, TTagBaseSelector *&amp;obj)
{
   obj = (TTagBaseSelector *) buf.ReadObject(TTagBaseSelector::Class());
   return buf;
}

void TTagBaseSelector::PrintOn(std::ostream&amp; o) const 
{
    TEventSelector::PrintOn(cout);
    if (fPTotalMass &gt; 0.0)   o &lt;&lt; "Total mass              &gt; " &lt;&lt; fPTotalMass &lt;&lt; " GeV" &lt;&lt; endl; 
    if (fPTotalCosTh &gt; -1.0) o &lt;&lt; "Total CosTheta P        &gt; " &lt;&lt; fPTotalCosTh &lt;&lt; endl; 
    if (fENeutralCosTh &gt; -1.0) o &lt;&lt; "Total CosTheta E        &gt; " &lt;&lt; fENeutralCosTh &lt;&lt; endl; 
    if (fP1MagLow &gt; 0.0) o &lt;&lt; "First particle P        = " &lt;&lt; fP1MagLow &lt;&lt; " ... " &lt;&lt; fP1MagHigh &lt;&lt; " GeV" &lt;&lt; endl; 
    if (fP2MagLow &gt; 0.0) o &lt;&lt; "Secnd particle P        = " &lt;&lt; fP2MagLow &lt;&lt; " ... " &lt;&lt; fP2MagHigh &lt;&lt; " GeV" &lt;&lt; endl; 
    if (fE1MagLow &gt; 0.0) o &lt;&lt; "First particle E        = " &lt;&lt; fE1MagLow &lt;&lt; " ... " &lt;&lt; fE1MagHigh &lt;&lt; " GeV" &lt;&lt; endl; 
    if (fE2MagLow &gt; 0.0) o &lt;&lt; "Secnd particle E        = " &lt;&lt; fE2MagLow &lt;&lt; " ... " &lt;&lt; fE2MagHigh &lt;&lt; " GeV" &lt;&lt; endl; 
    o &lt;&lt; endl;
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const TTagBaseSelector&amp; a) { a.PrintOn(o); return o; }


ClassImp(TAodBaseSelector)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, TAodBaseSelector *&amp;obj)
{
   obj = (TAodBaseSelector *) buf.ReadObject(TAodBaseSelector::Class());
   return buf;
}

TAodBaseSelector::TAodBaseSelector(const char *name) :
TEventSelector(name), 
fSelector(new TGoodTrackSelector("TGoodTrackSelector",20,0.1,0.0,1.0,4.0,-1.0))
{
    fOwnSelector = fSelector; 
}

TAodBaseSelector::~TAodBaseSelector() 
{ 
    delete fOwnSelector; 
}

void TAodBaseSelector::PrintOn(std::ostream&amp; o) const 
{
    TEventSelector::PrintOn(o);
    o &lt;&lt; *fSelector;  // Show the settings of the associated track selector
}
std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const TAodBaseSelector&amp; a) { a.PrintOn(o); return o; }

<b>// <a href=".././TTagSelector.html">TTagSelector</a> is used to define a cut based on a TTreeFormula</b>

ClassImp(<a href=".././TTagSelector.html">TTagSelector</a>)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, <a href=".././TTagSelector.html">TTagSelector</a> *&amp;obj)
{
   obj = (<a href=".././TTagSelector.html">TTagSelector</a> *) buf.ReadObject(<a href=".././TTagSelector.html#TTagSelector:Class">TTagSelector::Class</a>());
   return buf;
}

<a href=".././TTagSelector.html#TTagSelector:TTagSelector">TTagSelector::TTagSelector</a>(const <a href="../ListOfTypes.html#char">char</a> *name, const <a href="../ListOfTypes.html#char">char</a>* formula) :
<a href=".././TTagBaseSelector.html">TTagBaseSelector</a>(name)
{
    SetFormula(formula);
}
 
<a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href=".././TTagSelector.html#TTagSelector:Accept">TTagSelector::Accept</a>(<a href=".././TEventManager.html">TEventManager</a>&amp; e) 
{
/*
    if (fTreeFormula == 0) {
	fTreeFormula = new TTreeFormula(fName,fFormula,e.GetReader()-&gt;GetStream(0)-&gt;GetTree());
	fTreeFormula-&gt;Print();
    }
    fTreeFormula-&gt;SetTree(e.GetReader()-&gt;GetStream(0)-&gt;GetTree());
    <a href="../ListOfTypes.html#Float_t">Float_t</a> result = fTreeFormula-&gt;EvalInstance();
    return (result&gt;0.0);
*/
    return 0.0;
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././TTagSelector.html#TTagSelector:PrintOn">TTagSelector::PrintOn</a>(std::ostream&amp; o) const 
{
    o &lt;&lt; GetName() &lt;&lt; " settings: ";
    o &lt;&lt; fFormula;
    o &lt;&lt; endl;    
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././TTagSelector.html">TTagSelector</a>&amp; a) { a.<a href="#TDimuonAodSelector:PrintOn">PrintOn</a>(o); return o; }


<b>// The <a href=".././TTwoprongTagSelector.html">TTwoprongTagSelector</a> looks for a ninimum number of tracks</b>
<b>// and neutrals. It then make sure that two prongs are opposite</b>
<b>// in the CMS. The selection is based on information stored in the</b>
<b>// TAG.</b>

ClassImp(<a href=".././TTwoprongTagSelector.html">TTwoprongTagSelector</a>)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, <a href=".././TTwoprongTagSelector.html">TTwoprongTagSelector</a> *&amp;obj)
{
   obj = (<a href=".././TTwoprongTagSelector.html">TTwoprongTagSelector</a> *) buf.ReadObject(<a href=".././TTwoprongTagSelector.html#TTwoprongTagSelector:Class">TTwoprongTagSelector::Class</a>());
   return buf;
}

<a href=".././TTwoprongTagSelector.html#TTwoprongTagSelector:TTwoprongTagSelector">TTwoprongTagSelector::TTwoprongTagSelector</a>(const <a href="../ListOfTypes.html#char">char</a> *name) :
<a href=".././TTagBaseSelector.html">TTagBaseSelector</a>(name)
{
    SetLoose(); 
    SetNumberOfTracks(2,2);
    <a href="#TDimuonAodSelector:SetDeltaPhi">SetDeltaPhi</a>(11.);
    <a href="#TDimuonAodSelector:SetDeltaCosTheta">SetDeltaCosTheta</a>(0.1);
}
 
<a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href=".././TTwoprongTagSelector.html#TTwoprongTagSelector:Accept">TTwoprongTagSelector::Accept</a>(<a href=".././TEventManager.html">TEventManager</a>&amp; e) 
{
    VAbsTag &amp;tag = e.GetTag();	    // Shortcut to access TAG

<b>    // Check the number of good tracks</b>

    if (!tight &amp;&amp; tag.GetNumberOfGoodTracksLoose() &lt; <a href=".././TEventSelector.html#TEventSelector:fNTracksMin">fNTracksMin</a>) return kFALSE;
    if ( tight &amp;&amp; tag.GetNumberOfGoodTracksTight() &lt; <a href=".././TEventSelector.html#TEventSelector:fNTracksMin">fNTracksMin</a>) return kFALSE;
    
<b>    // Preselect the interesting events in CMS </b>
<b>    // according to angular constraints</b>

    <a href="../ListOfTypes.html#Double_t">Double_t</a> p1Phi, p2Phi, p1CosTh, p2CosTh;
    TVector3 t1 = tag.GetPrimaryTrackMomentum();    // CosTheta, Phi, Magnitude
    TVector3 t2 = tag.GetSecondaryTrackMomentum();  // CosTheta, Phi, Magnitude

    p1CosTh = t1.X();
    p2CosTh = t2.X();
    <a href="../ListOfTypes.html#Double_t">Double_t</a> dcosth = TMath::Abs(p1CosTh + p2CosTh);	    // Ideally cancels to zero
    if (dcosth &gt; <a href=".././TDimuonAodSelector.html#TDimuonAodSelector:fDCosTh">fDCosTh</a>) return kFALSE;			    // Does it match ?

    p1Phi = t1.Y();
    p2Phi = t2.Y();
    <a href="../ListOfTypes.html#Double_t">Double_t</a> dphi = TMath::Abs(p1Phi - p2Phi);
    dphi = TMath::Abs(dphi - kPI);			    // Those are close to 180 deg.
    if (dphi/kPI*180. &gt; <a href=".././TDimuonAodSelector.html#TDimuonAodSelector:fDPhi">fDPhi</a>) return kFALSE;		    // Does it match ?

    return kTRUE;
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././TTwoprongTagSelector.html#TTwoprongTagSelector:PrintOn">TTwoprongTagSelector::PrintOn</a>(std::ostream&amp; o) const 
{
    <a href=".././TTagBaseSelector.html#TTagBaseSelector:PrintOn">TTagBaseSelector::PrintOn</a>(cout);
    o &lt;&lt; "Delta CosTheta    &lt; "  &lt;&lt; <a href=".././TDimuonAodSelector.html#TDimuonAodSelector:fDCosTh">fDCosTh</a> &lt;&lt; endl;
    o &lt;&lt; "Delta Phi [deg]   &lt; "  &lt;&lt; <a href=".././TDimuonAodSelector.html#TDimuonAodSelector:fDPhi">fDPhi</a> &lt;&lt; endl;
    o &lt;&lt; endl;    
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././TTwoprongTagSelector.html">TTwoprongTagSelector</a>&amp; a) { a.<a href="#TDimuonAodSelector:PrintOn">PrintOn</a>(o); return o; }


<b>// Define rough cuts for dimuon selection to be applied at the TAG level</b>
<b>// See http://www.slac.stanford.edu/~rfaccini/phys/Y4Sscan/selections.html</b>

ClassImp(<a href=".././TDimuonTagSelector.html">TDimuonTagSelector</a>)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, <a href=".././TDimuonTagSelector.html">TDimuonTagSelector</a> *&amp;obj)
{
   obj = (<a href=".././TDimuonTagSelector.html">TDimuonTagSelector</a> *) buf.ReadObject(<a href=".././TDimuonTagSelector.html#TDimuonTagSelector:Class">TDimuonTagSelector::Class</a>());
   return buf;
}

<a href=".././TDimuonTagSelector.html#TDimuonTagSelector:TDimuonTagSelector">TDimuonTagSelector::TDimuonTagSelector</a>(const <a href="../ListOfTypes.html#char">char</a> *name) :
<a href=".././TTagBaseSelector.html">TTagBaseSelector</a>(name)
{
    SetName(name);
    SetPrimaryMomentum(4.0);
    SetSecondaryMomentum(2.0);
    SetTheta(2.8,3.5);
}

<a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href=".././TDimuonTagSelector.html#TDimuonTagSelector:Accept">TDimuonTagSelector::Accept</a>(<a href=".././TEventManager.html">TEventManager</a>&amp; e) 
{
    VAbsTag &amp;tag = e.GetTag();	    // Shortcut to access TAG

    <a href="../ListOfTypes.html#Float_t">Float_t</a> p1Mag, p2Mag, p1CosTheta, p2CosTheta;
    tag.getFloat(p1Mag,"p1Mag"); 
    if (p1Mag &lt;= fP1MagLow) return kFALSE;
    tag.getFloat(p2Mag,"p2Mag");
    if (p2Mag &lt;= fP2MagLow) return kFALSE;
    tag.getFloat(p1CosTheta,"p1CosTheta"); 
    tag.getFloat(p2CosTheta,"p2CosTheta");
    <a href="../ListOfTypes.html#Double_t">Double_t</a> theta1 = TMath::ACos(p1CosTheta);
    <a href="../ListOfTypes.html#Double_t">Double_t</a> theta2 = TMath::ACos(p2CosTheta);
    <a href="../ListOfTypes.html#Double_t">Double_t</a> theta = theta1 + theta2;
    if (theta &lt;= <a href=".././TEventSelector.html#TEventSelector:fThetaLow">fThetaLow</a> || theta &gt;= <a href=".././TEventSelector.html#TEventSelector:fThetaHigh">fThetaHigh</a>) return kFALSE;

    return kTRUE;
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././TDimuonTagSelector.html#TDimuonTagSelector:PrintOn">TDimuonTagSelector::PrintOn</a>(std::ostream&amp; o) const 
{
    <a href=".././TTagBaseSelector.html#TTagBaseSelector:PrintOn">TTagBaseSelector::PrintOn</a>(o);
    o &lt;&lt; endl;
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././TDimuonTagSelector.html">TDimuonTagSelector</a>&amp; a) { a.<a href="#TDimuonAodSelector:PrintOn">PrintOn</a>(o); return o; }

<b>// Define rough cuts for gamma gamma selection to be applied at the TAG level</b>

ClassImp(<a href=".././TGammaGammaTagSelector.html">TGammaGammaTagSelector</a>)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, <a href=".././TGammaGammaTagSelector.html">TGammaGammaTagSelector</a> *&amp;obj)
{
   obj = (<a href=".././TGammaGammaTagSelector.html">TGammaGammaTagSelector</a> *) buf.ReadObject(<a href=".././TGammaGammaTagSelector.html#TGammaGammaTagSelector:Class">TGammaGammaTagSelector::Class</a>());
   return buf;
}

<a href=".././TGammaGammaTagSelector.html#TGammaGammaTagSelector:TGammaGammaTagSelector">TGammaGammaTagSelector::TGammaGammaTagSelector</a>(const <a href="../ListOfTypes.html#char">char</a> *name) :
<a href=".././TTagBaseSelector.html">TTagBaseSelector</a>(name)
{
    SetPrimaryEnergy(4.0);
    SetSecondaryEnergy(2.0);
    SetTheta(2.8,3.5);
}

<a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href=".././TGammaGammaTagSelector.html#TGammaGammaTagSelector:Accept">TGammaGammaTagSelector::Accept</a>(<a href=".././TEventManager.html">TEventManager</a>&amp; e) 
{
    VAbsTag &amp;tag = e.GetTag();	    // Shortcut to access TAG
    <a href="../ListOfTypes.html#Float_t">Float_t</a> e1Mag, e2Mag, e1CosTheta, e2CosTheta;
    tag.getFloat(e1Mag,"e1Mag"); 
    if (e1Mag &lt;= fE1MagLow) return kFALSE;
    tag.getFloat(e2Mag,"e2Mag");
    if (e2Mag &lt;= fE2MagLow) return kFALSE;
    tag.getFloat(e1CosTheta,"e1CosTheta"); 
    tag.getFloat(e2CosTheta,"e2CosTheta");
    <a href="../ListOfTypes.html#Double_t">Double_t</a> theta1 = TMath::ACos(e1CosTheta);
    <a href="../ListOfTypes.html#Double_t">Double_t</a> theta2 = TMath::ACos(e2CosTheta);
    <a href="../ListOfTypes.html#Double_t">Double_t</a> theta = theta1 + theta2;
    if (theta &lt;= <a href=".././TEventSelector.html#TEventSelector:fThetaLow">fThetaLow</a> || theta &gt;= <a href=".././TEventSelector.html#TEventSelector:fThetaHigh">fThetaHigh</a>) return kFALSE;

    return kTRUE;
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././TGammaGammaTagSelector.html#TGammaGammaTagSelector:PrintOn">TGammaGammaTagSelector::PrintOn</a>(std::ostream&amp; o) const 
{
    <a href=".././TTagBaseSelector.html#TTagBaseSelector:PrintOn">TTagBaseSelector::PrintOn</a>(o);
    o &lt;&lt; endl;
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././TGammaGammaTagSelector.html">TGammaGammaTagSelector</a>&amp; a) { a.<a href="#TDimuonAodSelector:PrintOn">PrintOn</a>(o); return o; }


<b>// The <a href=".././TBhabhaRatioTagSelector.html">TBhabhaRatioTagSelector</a> is a specialized TwoprongSelector</b>
<b>// which looks for Bhabha events.</b>

ClassImp(<a href=".././TBhabhaRatioTagSelector.html">TBhabhaRatioTagSelector</a>)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, <a href=".././TBhabhaRatioTagSelector.html">TBhabhaRatioTagSelector</a> *&amp;obj)
{
   obj = (<a href=".././TBhabhaRatioTagSelector.html">TBhabhaRatioTagSelector</a> *) buf.ReadObject(<a href=".././TBhabhaRatioTagSelector.html#TBhabhaRatioTagSelector:Class">TBhabhaRatioTagSelector::Class</a>());
   return buf;
}

<a href=".././TBhabhaRatioTagSelector.html#TBhabhaRatioTagSelector:TBhabhaRatioTagSelector">TBhabhaRatioTagSelector::TBhabhaRatioTagSelector</a>(const <a href="../ListOfTypes.html#char">char</a> *name) :
<a href=".././TTwoprongTagSelector.html">TTwoprongTagSelector</a>(name)
{ 
    SetAngularAcceptance(0.8);
    SetEnergyMomentumRatio(0.7);
}

<a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href=".././TBhabhaRatioTagSelector.html#TBhabhaRatioTagSelector:Accept">TBhabhaRatioTagSelector::Accept</a>(<a href=".././TEventManager.html">TEventManager</a>&amp; e) 
{
    VAbsTag &amp;tag = e.GetTag();	    // Shortcut to access TAG

    if (!<a href=".././TTwoprongTagSelector.html#TTwoprongTagSelector:Accept">TTwoprongTagSelector::Accept</a>(e)) return kFALSE;

<b>    // Now check, whether we hit the calorimeter with E ~ P</b>

    <a href="../ListOfTypes.html#Float_t">Float_t</a> p1CosTheta;
    tag.getFloat(p1CosTheta,"p1CosTheta"); 
    if (TMath::Abs(p1CosTheta) &gt; _costh) return kFALSE;	    // Require angular constraint

    <a href="../ListOfTypes.html#Float_t">Float_t</a> p2CosTheta;
    tag.getFloat(p2CosTheta,"p2CosTheta"); 
    if (TMath::Abs(p2CosTheta) &gt; _costh) return kFALSE;	    // Require angular constraint

    <a href="../ListOfTypes.html#Float_t">Float_t</a> p1Mag;
    tag.getFloat(p1Mag,"p1Mag"); 
    <a href="../ListOfTypes.html#Double_t">Double_t</a> p1EmcCandEnergy = tag.GetPrimaryTrackShowerEnergy();
    if (p1EmcCandEnergy &lt; _epratio * p1Mag) return kFALSE;

    <a href="../ListOfTypes.html#Float_t">Float_t</a> p2Mag;
    tag.getFloat(p2Mag,"p2Mag"); 
    <a href="../ListOfTypes.html#Double_t">Double_t</a> p2EmcCandEnergy = tag.GetSecondaryTrackShowerEnergy();
    if (p2EmcCandEnergy &lt; _epratio * p2Mag) return kFALSE;

    return kTRUE;
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././TBhabhaRatioTagSelector.html#TBhabhaRatioTagSelector:PrintOn">TBhabhaRatioTagSelector::PrintOn</a>(std::ostream&amp; o) const 
{
    <a href=".././TTwoprongTagSelector.html#TTwoprongTagSelector:PrintOn">TTwoprongTagSelector::PrintOn</a>(o);
    o &lt;&lt; "Energy/Momentum ratio = "  &lt;&lt; _epratio &lt;&lt; endl; 
    o &lt;&lt; "Angular Acceptance    = -" &lt;&lt; _costh &lt;&lt; " ... " &lt;&lt; _costh &lt;&lt; endl; 
    o &lt;&lt; endl;
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././TBhabhaRatioTagSelector.html">TBhabhaRatioTagSelector</a>&amp; a) { a.<a href="#TDimuonAodSelector:PrintOn">PrintOn</a>(o); return o; }


<b>// The <a href=".././TBhabhaTagSelector.html">TBhabhaTagSelector</a> looks for Bhabha events.</b>

ClassImp(<a href=".././TBhabhaTagSelector.html">TBhabhaTagSelector</a>)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, <a href=".././TBhabhaTagSelector.html">TBhabhaTagSelector</a> *&amp;obj)
{
   obj = (<a href=".././TBhabhaTagSelector.html">TBhabhaTagSelector</a> *) buf.ReadObject(<a href=".././TBhabhaTagSelector.html#TBhabhaTagSelector:Class">TBhabhaTagSelector::Class</a>());
   return buf;
}

<a href=".././TBhabhaTagSelector.html#TBhabhaTagSelector:TBhabhaTagSelector">TBhabhaTagSelector::TBhabhaTagSelector</a>(const <a href="../ListOfTypes.html#char">char</a> *name) :
<a href=".././TTagBaseSelector.html">TTagBaseSelector</a>(name)
{ 
    SetMomentum(3.0);
    SetTotalEnergy(3.0);
    SetShowerEnergy(2.0);
}

<a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href=".././TBhabhaTagSelector.html#TBhabhaTagSelector:Accept">TBhabhaTagSelector::Accept</a>(<a href=".././TEventManager.html">TEventManager</a>&amp; e) 
{
    VAbsTag &amp;tag = e.GetTag();	    // Shortcut to access TAG

    if (tag.GetTotalEnergy() &lt;= <a href=".././TEventSelector.html#TEventSelector:fETotLow">fETotLow</a>) return kFALSE;

    <a href="../ListOfTypes.html#Float_t">Float_t</a> p1Mag;
    tag.getFloat(p1Mag,"p1Mag"); 
    if (p1Mag &lt;= <a href=".././TEventSelector.html#TEventSelector:fPLow">fPLow</a>) return kFALSE;

    <a href="../ListOfTypes.html#Int_t">Int_t</a> n = 0;

    <a href="../ListOfTypes.html#Double_t">Double_t</a> p1EmcCandEnergy = tag.GetPrimaryTrackShowerEnergy();
    if (p1EmcCandEnergy &gt; <a href=".././TEventSelector.html#TEventSelector:fEmcLow">fEmcLow</a>) n++;

    <a href="../ListOfTypes.html#Double_t">Double_t</a> p2EmcCandEnergy = tag.GetSecondaryTrackShowerEnergy();
    if (p2EmcCandEnergy &gt; <a href=".././TEventSelector.html#TEventSelector:fEmcLow">fEmcLow</a>) n++;

    if (n == 0) return kFALSE; // We require at least one energetic photon 

    return kTRUE;
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././TBhabhaTagSelector.html#TBhabhaTagSelector:PrintOn">TBhabhaTagSelector::PrintOn</a>(std::ostream&amp; o) const 
{
    <a href=".././TTagBaseSelector.html#TTagBaseSelector:PrintOn">TTagBaseSelector::PrintOn</a>(o);
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././TBhabhaTagSelector.html">TBhabhaTagSelector</a>&amp; a) { a.<a href="#TDimuonAodSelector:PrintOn">PrintOn</a>(o); return o; }


<b>// The <a href=".././TRadiativeBhabhaTagSelector.html">TRadiativeBhabhaTagSelector</a> is a specialized TwoprongSelector</b>
<b>// which looks for rediative Bhabha events. Needs completion...</b>

ClassImp(<a href=".././TRadiativeBhabhaTagSelector.html">TRadiativeBhabhaTagSelector</a>)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, <a href=".././TRadiativeBhabhaTagSelector.html">TRadiativeBhabhaTagSelector</a> *&amp;obj)
{
   obj = (<a href=".././TRadiativeBhabhaTagSelector.html">TRadiativeBhabhaTagSelector</a> *) buf.ReadObject(<a href=".././TRadiativeBhabhaTagSelector.html#TRadiativeBhabhaTagSelector:Class">TRadiativeBhabhaTagSelector::Class</a>());
   return buf;
}

<a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href=".././TRadiativeBhabhaTagSelector.html#TRadiativeBhabhaTagSelector:Accept">TRadiativeBhabhaTagSelector::Accept</a>(<a href=".././TEventManager.html">TEventManager</a>&amp; e) 
{
    VAbsBit &amp;bit = e.GetBit();		 // Shortcut to access TAG
    return bit.GetBool("IsRadiativeBhabha");
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././TRadiativeBhabhaTagSelector.html#TRadiativeBhabhaTagSelector:PrintOn">TRadiativeBhabhaTagSelector::PrintOn</a>(std::ostream&amp; o) const 
{
    o &lt;&lt; GetName() &lt;&lt; " settings:" &lt;&lt; endl;
    o &lt;&lt; "Works in tag bit mode." &lt;&lt; endl;
    o &lt;&lt; endl;
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././TRadiativeBhabhaTagSelector.html">TRadiativeBhabhaTagSelector</a>&amp; a) { a.<a href="#TDimuonAodSelector:PrintOn">PrintOn</a>(o); return o; }


<b>// The <a href=".././THadronTagSelector.html">THadronTagSelector</a> looks for hadronic events</b>
<b>// on the TAG level (Require just more than 2 tracks)</b>

ClassImp(<a href=".././THadronTagSelector.html">THadronTagSelector</a>)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, <a href=".././THadronTagSelector.html">THadronTagSelector</a> *&amp;obj)
{
   obj = (<a href=".././THadronTagSelector.html">THadronTagSelector</a> *) buf.ReadObject(<a href=".././THadronTagSelector.html#THadronTagSelector:Class">THadronTagSelector::Class</a>());
   return buf;
}

<a href=".././THadronTagSelector.html#THadronTagSelector:THadronTagSelector">THadronTagSelector::THadronTagSelector</a>(const <a href="../ListOfTypes.html#char">char</a> *name) :
<a href=".././TTagBaseSelector.html">TTagBaseSelector</a>(name)
{
    SetNumberOfTracks(3); 
}

<a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href=".././THadronTagSelector.html#THadronTagSelector:Accept">THadronTagSelector::Accept</a>(<a href=".././TEventManager.html">TEventManager</a>&amp; e) 
{
    VAbsTag &amp;tag = e.GetTag();		 // Shortcut to access TAG

    <a href="../ListOfTypes.html#Int_t">Int_t</a> nGoodTrk;
    if (!tight) nGoodTrk = tag.GetNumberOfGoodTracksLoose();
    if ( tight) nGoodTrk = tag.GetNumberOfGoodTracksTight();
    if (nGoodTrk &lt; <a href=".././TEventSelector.html#TEventSelector:fNTracksMin">fNTracksMin</a>) return kFALSE;

    return kTRUE;
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././THadronTagSelector.html#THadronTagSelector:PrintOn">THadronTagSelector::PrintOn</a>(std::ostream&amp; o) const 
{
    <a href=".././TTagBaseSelector.html#TTagBaseSelector:PrintOn">TTagBaseSelector::PrintOn</a>(o);
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././THadronTagSelector.html">THadronTagSelector</a>&amp; a) { a.<a href="#TDimuonAodSelector:PrintOn">PrintOn</a>(o); return o; }


<b>// The <a href=".././THadronAodSelector.html">THadronAodSelector</a> looks for hadronic events</b>
<b>// on the AOD level</b>

ClassImp(<a href=".././THadronAodSelector.html">THadronAodSelector</a>)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, <a href=".././THadronAodSelector.html">THadronAodSelector</a> *&amp;obj)
{
   obj = (<a href=".././THadronAodSelector.html">THadronAodSelector</a> *) buf.ReadObject(<a href=".././THadronAodSelector.html#THadronAodSelector:Class">THadronAodSelector::Class</a>());
   return buf;
}

<a href=".././THadronAodSelector.html#THadronAodSelector:THadronAodSelector">THadronAodSelector::THadronAodSelector</a>(const <a href="../ListOfTypes.html#char">char</a> *name) :
<a href=".././TAodBaseSelector.html">TAodBaseSelector</a>(name)
{
    SetNumberOfTracks(3);	 // Require more than two tracks
    SetTotalCharge(4);		 // Approx. charge balance
    SetShowerEnergy(0.1,1.E8);   // Matched EMC energy
    SetHighPt(0.5);		 // At least one track with high Pt
    SetPrimaryVertex(1.,-4.,4.); // Within (doca, -z, z)
}

<a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href=".././THadronAodSelector.html#THadronAodSelector:Accept">THadronAodSelector::Accept</a>(<a href=".././TEventManager.html">TEventManager</a>&amp; e) 
{
    <a href="../ListOfTypes.html#Float_t">Float_t</a> energy = 0.0;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> nGoodTrks = 0, nCharge = 0;
    <a href="../ListOfTypes.html#Bool_t">Bool_t</a>  highpt = kFALSE;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> i;
	    	    
<b>    // Check all tracks</b>
	    
    <a href="../ListOfTypes.html#Int_t">Int_t</a> n = e.GetNumberOfChargedTracks();
    for (i=0; i&lt;n; i++) {
		
	VAbsMicroCandidate &amp;cand = e.GetMicroCandidate(i);// Use shortcut to access Micro
		
	<a href="../ListOfTypes.html#Int_t">Int_t</a> charge = cand.GetCharge();		// Get electrical charge
	<a href="../ListOfTypes.html#Double_t">Double_t</a> mom = cand.GetMomentum().Mag();	// Get the momentum
	<a href="../ListOfTypes.html#Float_t">Float_t</a> emc  = cand.GetEmcRawEnergy();		// Get the energy deposit in EMC
		
<b>	// Check the EMC signal and the charge </b>
		
	if (emc &gt; <a href=".././TEventSelector.html#TEventSelector:fEmcLow">fEmcLow</a>) energy += emc;		// Accumulate energy deposit
	if (emc &lt;  <a href=".././TEventSelector.html#TEventSelector:fEmcLow">fEmcLow</a> || emc &gt; <a href=".././TEventSelector.html#TEventSelector:fEmcHigh">fEmcHigh</a>) continue;	// Is the track matched ?
	if (mom &lt;= <a href=".././TEventSelector.html#TEventSelector:fPLow">fPLow</a>   || mom &gt; <a href=".././TEventSelector.html#TEventSelector:fPHigh">fPHigh</a>)   continue;	// Momentum is out of range
		
	TCandidate candidate(cand,i);			// Decide on track quality
	if (!<a href=".././TAodBaseSelector.html#TAodBaseSelector:fSelector">fSelector</a>-&gt;<a href=".././TGoodTrackSelector.html#TGoodTrackSelector:Accept">Accept</a>(candidate)) continue;
		
<b>	// Prepare quantities for the final selection</b>
		
	<a href="../ListOfTypes.html#Double_t">Double_t</a> pt  = cand.GetMomentum().Perp();       // Get the transverse momentum
	if (pt &gt; fHighPt) highpt = kTRUE;                // Check track momentum
		
	nGoodTrks++;                                    // Count the good tracks
	nCharge += charge;                              // Accumulate charge
		
    }

    n = e.GetNumberOfTracks();			// This second loop accumulates
    for (i=0; i&lt;n; i++) {				// the neutral energy
	if (e.GetMicroCandidate(i).GetCharge()!=0) continue;
	<a href="../ListOfTypes.html#Float_t">Float_t</a> emc  = e.GetMicroCandidate(i).GetEmcRawEnergy();
	if (emc &gt; <a href=".././TEventSelector.html#TEventSelector:fEmcLow">fEmcLow</a>) energy += emc;
    }
		

<b>    // Make a final decision on number of tracks, charge and energy balance</b>
	    
    if (energy &lt;= <a href=".././TEventSelector.html#TEventSelector:fELow">fELow</a> || energy &gt;= <a href=".././TEventSelector.html#TEventSelector:fEHigh">fEHigh</a>) return kFALSE; // Require minimum energy deposit
    if (nGoodTrks &lt; <a href=".././TEventSelector.html#TEventSelector:fNTracksMin">fNTracksMin</a>) return kFALSE;             // Require min. number of tracks
    if (!highpt) return kFALSE;                             // Require Pt &gt; HIGHPT (at least one track)
    if (abs(nCharge) &gt;= <a href=".././TEventSelector.html#TEventSelector:fTotChar">fTotChar</a>) return kFALSE;            // Require charge balance
	    
    return kTRUE;
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././THadronAodSelector.html#THadronAodSelector:PrintOn">THadronAodSelector::PrintOn</a>(std::ostream&amp; o) const 
{
    <a href=".././TAodBaseSelector.html#TAodBaseSelector:PrintOn">TAodBaseSelector::PrintOn</a>(o);
    o &lt;&lt; "High Pt required      &gt; " &lt;&lt; fHighPt &lt;&lt; " GeV" &lt;&lt; endl; 
    o &lt;&lt; endl;
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././THadronAodSelector.html">THadronAodSelector</a>&amp; a) { a.<a href="#TDimuonAodSelector:PrintOn">PrintOn</a>(o); return o; }


<b>// The <a href=".././TDimuonAodSelector.html">TDimuonAodSelector</a> looks for dimuon events</b>
<b>// on the AOD level</b>

ClassImp(<a href=".././TDimuonAodSelector.html">TDimuonAodSelector</a>)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, <a href=".././TDimuonAodSelector.html">TDimuonAodSelector</a> *&amp;obj)
{
   obj = (<a href=".././TDimuonAodSelector.html">TDimuonAodSelector</a> *) buf.ReadObject(<a href=".././TDimuonAodSelector.html#TDimuonAodSelector:Class">TDimuonAodSelector::Class</a>());
   return buf;
}

<a name="TDimuonAodSelector:TDimuonAodSelector"> </a><a href=".././TDimuonAodSelector.html#TDimuonAodSelector:TDimuonAodSelector">TDimuonAodSelector::TDimuonAodSelector</a>(const <a href="../ListOfTypes.html#char">char</a> *name) :
<a href=".././TAodBaseSelector.html">TAodBaseSelector</a>(name)
{
    SetNumberOfTracks(2,2);
    SetShowerEnergy(0.05,1.0);
    <a href="#TDimuonAodSelector:SetDeltaPhi">SetDeltaPhi</a>(8.1);
    <a href="#TDimuonAodSelector:SetDeltaCosTheta">SetDeltaCosTheta</a>(0.1);
}

<a name="TDimuonAodSelector:Accept"> </a><a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href=".././TDimuonAodSelector.html#TDimuonAodSelector:Accept">TDimuonAodSelector::Accept</a>(<a href=".././TEventManager.html">TEventManager</a>&amp; e) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> nGoodTrks = 0;

    <a href=".././TDimuonAodSelector.html#TDimuonAodSelector:tracklist">tracklist</a>.Reset();			// This will hold the selected candidates
	    	    
<b>    // Check all tracks</b>
	    
    <a href="../ListOfTypes.html#Int_t">Int_t</a> n = e.GetNumberOfTracks();
    for (<a href="../ListOfTypes.html#Int_t">Int_t</a> i=0; i&lt;n; i++) {
		
	VAbsMicroCandidate &amp;cand = e.GetMicroCandidate(i);// Use shortcut to access Micro
		
	<a href="../ListOfTypes.html#Int_t">Int_t</a> charge = cand.GetCharge();		// Get electrical charge
		
	if (charge == 0) continue;			// Skip neutrals for "Rome" selection              
		
	TCandidate candidate(cand,i);			// Decide on track quality
	if (!<a href=".././TAodBaseSelector.html#TAodBaseSelector:fSelector">fSelector</a>-&gt;<a href=".././TGoodTrackSelector.html#TGoodTrackSelector:Accept">Accept</a>(candidate)) continue;
		
<b>	// Prepare quantities for the final selection</b>
		
	<a href=".././TDimuonAodSelector.html#TDimuonAodSelector:tracklist">tracklist</a>.Put(candidate);			// Put the candidate into a list

	nGoodTrks++;                                    // Count the good tracks
		
    }
	    
<b>    // Make a final decision on number of tracks</b>
	    
    if (nGoodTrks &lt; <a href=".././TEventSelector.html#TEventSelector:fNTracksMin">fNTracksMin</a>) return kFALSE;              // Require 2 tracks
    if (nGoodTrks &gt; <a href=".././TEventSelector.html#TEventSelector:fNTracksMax">fNTracksMax</a>) return kFALSE;              // Require 2 tracks

<b>    // Are the two tracks back-to-back in the CMS (in theta and phi) ?</b>
<b>    // Note, there is also a very small perpendicular boost due to the beam crossing</b>

    TVector3 cmFrame(0.0,0.0,0.486976);
    if (TRho::Instance()-&gt;GetConditions()!=0) {
	<a href=".././TConditions.html">TConditions</a> *theConditions = TRho::Instance()-&gt;GetConditions();
        <a href=".././TRhoTime.html">TRhoTime</a> theTime(e.GetTime());
	theConditions-&gt;At(theTime);		    // Read the beam conditions DB
	<a href=".././TBeams.html">TBeams</a> *beams = theConditions-&gt;GetBeams();
	<a href="../ListOfTypes.html#Double_t">Double_t</a> ecms = beams-&gt;EnergyCM();
	cmFrame = beams-&gt;BoostCMtoLab();
    }

    <a href=".././TDimuonAodSelector.html#TDimuonAodSelector:tracklist">tracklist</a>.Boost(-1.0*cmFrame);			    // Transform into CMS
    TCandidate *c1 = <a href=".././TDimuonAodSelector.html#TDimuonAodSelector:tracklist">tracklist</a>.Get(0);
    TCandidate *c2 = <a href=".././TDimuonAodSelector.html#TDimuonAodSelector:tracklist">tracklist</a>.Get(1);
    <a href="../ListOfTypes.html#Double_t">Double_t</a> phi1 = c1-&gt;P3().Phi();			    // Calculate distance in phi
    <a href="../ListOfTypes.html#Double_t">Double_t</a> phi2 = c2-&gt;P3().Phi();
    <a href="../ListOfTypes.html#Double_t">Double_t</a> dphi = TMath::Abs(phi1 - phi2);
    dphi = TMath::Abs(dphi - kPI);			    // Those are close to 180 deg.
    if (dphi/kPI*180. &gt; <a href=".././TDimuonAodSelector.html#TDimuonAodSelector:fDPhi">fDPhi</a>) return kFALSE;		    // Does it match ?

    <a href="../ListOfTypes.html#Double_t">Double_t</a> cosTh1 = c1-&gt;P3().CosTheta();		    // Calculate cos(theta)
    <a href="../ListOfTypes.html#Double_t">Double_t</a> cosTh2 = c2-&gt;P3().CosTheta();
    <a href="../ListOfTypes.html#Double_t">Double_t</a> dcosth = TMath::Abs(cosTh1 + cosTh2);	    // Ideally cancels to zero
    if (dcosth &gt; <a href=".././TDimuonAodSelector.html#TDimuonAodSelector:fDCosTh">fDCosTh</a>) return kFALSE;			    // Does it match ?

    return kTRUE;
}

<a name="TDimuonAodSelector:PrintOn"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TDimuonAodSelector.html#TDimuonAodSelector:PrintOn">TDimuonAodSelector::PrintOn</a>(std::ostream&amp; o) const 
{
    <a href=".././TAodBaseSelector.html#TAodBaseSelector:PrintOn">TAodBaseSelector::PrintOn</a>(o);
    o &lt;&lt; "Delta CosTheta        &lt; "  &lt;&lt; <a href=".././TDimuonAodSelector.html#TDimuonAodSelector:fDCosTh">fDCosTh</a> &lt;&lt; endl; 
    o &lt;&lt; "Delta Phi [deg]       &lt; "  &lt;&lt; <a href=".././TDimuonAodSelector.html#TDimuonAodSelector:fDPhi">fDPhi</a> &lt;&lt; endl;
    o &lt;&lt; endl;
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././TDimuonAodSelector.html">TDimuonAodSelector</a>&amp; a) { a.<a href="#TDimuonAodSelector:PrintOn">PrintOn</a>(o); return o; }


<b>// The <a href=".././TBhabhaAodSelector.html">TBhabhaAodSelector</a> looks for Bhabha events</b>
<b>// on the AOD level</b>

ClassImp(<a href=".././TBhabhaAodSelector.html">TBhabhaAodSelector</a>)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, <a href=".././TBhabhaAodSelector.html">TBhabhaAodSelector</a> *&amp;obj)
{
   obj = (<a href=".././TBhabhaAodSelector.html">TBhabhaAodSelector</a> *) buf.ReadObject(<a href=".././TBhabhaAodSelector.html#TBhabhaAodSelector:Class">TBhabhaAodSelector::Class</a>());
   return buf;
}

<a href=".././TBhabhaAodSelector.html#TBhabhaAodSelector:TBhabhaAodSelector">TBhabhaAodSelector::TBhabhaAodSelector</a>(const <a href="../ListOfTypes.html#char">char</a> *name) :
<a href=".././TAodBaseSelector.html">TAodBaseSelector</a>(name)
{
    SetTotalEnergy(4.0);
    SetNumberOfTracks(1,2);
    SetShowerEnergy(1.0,1.E8);
}

<a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href=".././TBhabhaAodSelector.html#TBhabhaAodSelector:Accept">TBhabhaAodSelector::Accept</a>(<a href=".././TEventManager.html">TEventManager</a>&amp; e) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a>  nTracks = 0;
    <a href="../ListOfTypes.html#Float_t">Float_t</a> energy = 0.0;
    <a href="../ListOfTypes.html#Bool_t">Bool_t</a>  matched = kFALSE;
    <a href="../ListOfTypes.html#UInt_t">UInt_t</a>  above1 = 0, above2 = 0;

<b>    // Check all tracks</b>
	    
    <a href="../ListOfTypes.html#UInt_t">UInt_t</a> n = e.GetNumberOfChargedTracks();
    for (<a href="../ListOfTypes.html#UInt_t">UInt_t</a> i=0; i&lt;n; i++) {
		
	VAbsMicroCandidate &amp;cand = e.GetMicroCandidate(i);  // Use shortcut to access Micro
		
	<a href="../ListOfTypes.html#Int_t">Int_t</a> charge = cand.GetCharge();	// Get electrical charge
	<a href="../ListOfTypes.html#Float_t">Float_t</a> emc  = cand.GetEmcRawEnergy();	// Get the energy deposit in EMC
	energy += emc;

	if (emc &gt; 2.0) 
	    above2++;				// Count the energetic bumps
	else if (emc &gt; 1.0) 
	    above1++;

	if (charge == 0) continue;		// Skip neutrals

	TCandidate candidate(cand,i);		// Decide on track quality
	if (!<a href=".././TAodBaseSelector.html#TAodBaseSelector:fSelector">fSelector</a>-&gt;<a href=".././TGoodTrackSelector.html#TGoodTrackSelector:Accept">Accept</a>(candidate)) continue;
	nTracks++;

	if (emc &gt; 0.1) matched = kTRUE;		// Is the track matched ?
    }
	    
<b>    // Make a decision</b>

    if (nTracks &lt; <a href=".././TEventSelector.html#TEventSelector:fNTracksMin">fNTracksMin</a>) return kFALSE;    // Require at least 1 track
    if (nTracks &gt; <a href=".././TEventSelector.html#TEventSelector:fNTracksMax">fNTracksMax</a>) return kFALSE;    // Not more than 2 tracks
    if (energy &lt; <a href=".././TEventSelector.html#TEventSelector:fETotLow">fETotLow</a>) return kFALSE;	// Require emc energy
    if (above2 &lt; 1) return kFALSE;		// and bumps above
    if (above1+above2 &lt; 2) return kFALSE;	// a certain threshold
    if (!matched) return kFALSE;			// One track should be matched

    return kTRUE;
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././TBhabhaAodSelector.html#TBhabhaAodSelector:PrintOn">TBhabhaAodSelector::PrintOn</a>(std::ostream&amp; o) const 
{
    <a href=".././TAodBaseSelector.html#TAodBaseSelector:PrintOn">TAodBaseSelector::PrintOn</a>(o);
    o &lt;&lt; endl;
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././TBhabhaAodSelector.html">TBhabhaAodSelector</a>&amp; a) { a.<a href="#TDimuonAodSelector:PrintOn">PrintOn</a>(o); return o; }

</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
