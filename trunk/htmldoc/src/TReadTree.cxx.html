<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:03:23 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TReadTree - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//==========================================================================</b>
<b>// File and Version Information:</b>
<b>// 	$Id: TReadTree.cxx.html,v 1.1.1.1 2002-12-20 15:05:30 marcel Exp $</b>
<b>//</b>
<b>//--------------------------------------------------------------------------</b>
<b>// Description:</b>
<b>//	See <a href=".././TReadTree.html">TReadTree</a>.h</b>
<b>//</b>
<b>//--------------------------------------------------------------------------</b>
<b>// Sample User Code:</b>
<b>//</b>
<b>//--------------------------------------------------------------------------</b>
<b>// Environment:</b>
<b>//	Software developed for the BaBar Detector at the SLAC B-Factory.</b>
<b>//</b>
<b>//--------------------------------------------------------------------------</b>
<b>// Author List:</b>
<b>//	Abi Soffer              (Original author)</b>
<b>//</b>
<b>//--------------------------------------------------------------------------</b>
<b>// Copyright Information:</b>
<b>//	Copyright (C) 1998	Colorado State University</b>
<b>//</b>
<b>// ROOT Version by Marcel Kunze, RUB</b>
<b>//==========================================================================</b>

#include &lt;ctype.h&gt;
#include "RhoTools/TReadTree.h"
#include "RhoTools/TOpAdd4.h"

ClassImp(TReadTree)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, TReadTree *&amp;obj)
{
   obj = (TReadTree *) buf.ReadObject(TReadTree::Class());
   return buf;
}

#include &lt;iostream&gt;
#include &lt;strstream&gt;
#include &lt;string&gt;
using namespace std;


<a name="TReadTree:TReadTree"> </a>TReadTree::TReadTree() :
  _crashOnError(kTRUE)
{
  SetReader(TCandReaderNameMomVtx().Name());
  Initialize();
}

<b>//-------------------------------------------------------------------</b>
<a name="TReadTree:TReadTree"> </a><a href=".././TReadTree.html#TReadTree:TReadTree">TReadTree::TReadTree</a>(const <a href=".././TReadTree.html">TReadTree</a> &amp; original) {
  *this = original;
}

<b>//--------------</b>
<b>// Destructor --</b>
<b>//--------------</b>
<a name="TReadTree:~TReadTree"> </a><a href=".././TReadTree.html">TReadTree</a>::~<a href=".././TReadTree.html">TReadTree</a>() {
}

<b>//-------------</b>
<b>// Operators --</b>
<b>//-------------</b>
<a href=".././TReadTree.html">TReadTree</a> &amp; 
<a href=".././TReadTree.html#TReadTree:operator">TReadTree::operator</a>=(const <a href=".././TReadTree.html">TReadTree</a> &amp; original) {
  <a href="#TReadTree:Initialize">Initialize</a>();
  <a href=".././TReadTree.html#TReadTree:_reader">_reader</a> = original.<a href=".././TReadTree.html#TReadTree:_reader">_reader</a>;
  <a href=".././TReadTree.html#TReadTree:_readerFromInput">_readerFromInput</a> = original.<a href=".././TReadTree.html#TReadTree:_readerFromInput">_readerFromInput</a>;
  <a href=".././TReadTree.html#TReadTree:_crashOnError">_crashOnError</a> = original.<a href=".././TReadTree.html#TReadTree:_crashOnError">_crashOnError</a>;
  return *this;
}

<b>//-------------</b>
<b>// Accessors --</b>
<b>//-------------</b>
    
<b>//-------------</b>
<b>// Modifiers --</b>
<b>//-------------</b>

<a href="../ListOfTypes.html#void">void</a> 
<a name="TReadTree:SetReader"> </a><a href=".././TReadTree.html#TReadTree:SetReader">TReadTree::SetReader</a>(const <a href=".././TCandReader.html">TCandReader</a> * reader) {
  if (0 == reader){
    cerr
      &lt;&lt; "ERROR: <a href=".././TReadTree.html#TReadTree:setReader">TReadTree::setReader</a>(const <a href=".././TCandReader.html">TCandReader</a> * reader):"
      &lt;&lt; endl
      &lt;&lt; "       argument is null. Aborting." &lt;&lt; endl;
    abort();
  }

  <a href=".././TReadTree.html#TReadTree:_readerFromInput">_readerFromInput</a> = kFALSE;  
  <a href=".././TReadTree.html#TReadTree:_reader">_reader</a> = reader;
}

<b>//---------------------------------------------------------------</b>
<a href="../ListOfTypes.html#void">void</a> 
<a name="TReadTree:SetReader"> </a><a href=".././TReadTree.html#TReadTree:SetReader">TReadTree::SetReader</a>(const <a href="../ListOfTypes.html#char">char</a> * readerName) {
  <a href="#TReadTree:SetReader">SetReader</a>(<a href=".././TCandReader.html#TCandReader:Find">TCandReader::Find</a>(readerName));
}

<b>//---------------------------------------------------------------</b>
TCandidate * 
<a name="TReadTree:Read"> </a><a href=".././TReadTree.html#TReadTree:Read">TReadTree::Read</a>(std::istream &amp; stream) {
  TCandidate * result = 0;
/*
<b>  // Clean up first:</b>
  <a href="#TReadTree:Initialize">Initialize</a>();
  
<b>  // See if the <a href=".././TCandReader.html">TCandReader</a> is specified in the input:</b>
  string indicator;
  stream &gt;&gt; indicator;
  if (indicator.IsNull()) {
    return 0;  // nothing to read
  }
  string indicatorNoWhite = indicator;
  indicatorNoWhite.ToLower();

  if (<a href="#TReadTree:ReaderIndicator">ReaderIndicator</a>() != indicatorNoWhite){
<b>    // indicator is not a reader indication, so put in back into stream:</b>
    for (<a href="../ListOfTypes.html#int">int</a> i = indicator.Length() - 1; i &gt; -1; --i){
      stream.putback(indicator(i));
    }
    if (0 == stream.good()){
      cerr 
	&lt;&lt; "ERROR: <a href=".././TReadTree.html#TReadTree:read">TReadTree::read</a>(istream&amp;):" &lt;&lt; endl
	&lt;&lt; "       Unable to putback "" &lt;&lt; indicator
	&lt;&lt; "" into the stream." &lt;&lt; endl;
      abort();
    }
  }
  else {
<b>    // Read the name of the <a href=".././TCandReader.html">TCandReader</a> from the stream:</b>
    string name;
    stream &gt;&gt; name;
    
    if (name.IsNull()) {
      return 0;    // not much to do there
    }
    
    const <a href=".././TCandReader.html">TCandReader</a> * reader = <a href=".././TCandReader.html#TCandReader:Find">TCandReader::Find</a>(name.c_str());
    if (0 == reader){
      <a href="#TReadTree:CheckStatus">CheckStatus</a>(<a href=".././TCandReader.html#TCandReader:NO_READER">TCandReader::NO_READER</a>, 0, name.c_str());
      return 0;
    }

    if (kTRUE == <a href=".././TReadTree.html#TReadTree:_readerFromInput">_readerFromInput</a>){
<b>      // Set the <a href=".././TCandReader.html">TCandReader</a>:</b>
      <a href=".././TReadTree.html#TReadTree:_reader">_reader</a> = reader;
    }
    else {
<b>      // Check that the name is compatible with the current <a href=".././TReadTree.html#TReadTree:_reader">_reader</a>:</b>
      if (<a href=".././TReadTree.html#TReadTree:_reader">_reader</a>-&gt;<a href=".././TCandReader.html#TCandReader:Name">Name</a>() != name.c_str()){
	cerr 
	  &lt;&lt; "ERROR: <a href=".././TReadTree.html">TReadTree</a>:read(istream&amp;):" &lt;&lt; endl
	  &lt;&lt; "       input specified <a href=".././TCandReader.html">TCandReader</a> ""
	  &lt;&lt; name.c_str() &lt;&lt; "", which is different from" &lt;&lt; endl
	  &lt;&lt; "       "" &lt;&lt; <a href=".././TReadTree.html#TReadTree:_reader">_reader</a>-&gt;<a href=".././TCandReader.html#TCandReader:Name">Name</a>() 
	  &lt;&lt; "", which was set by a call to setReader(..)/" &lt;&lt; endl;
	abort();
      }
    }
  }

<b>  // Pass a list to hold the candidate's daughters to the recursive function:</b>
  TCandList daughtersList;
  <a href="#TReadTree:ReadFill">ReadFill</a>(stream, daughtersList);

  if (1 == daughtersList.GetNumberOfCandidates()){
    result = &amp;daughtersList[0];
  }
  else if (0 != daughtersList.GetNumberOfCandidates()){
    cerr &lt;&lt; "<a href=".././TReadTree.html#TReadTree:read">TReadTree::read</a>(istream&amp;): daughtersList length = " 
		  &lt;&lt; daughtersList.GetNumberOfCandidates() 
		  &lt;&lt; " when expecting 1 or 0. Call Abi." 
		  &lt;&lt; endl;
    ::abort();
  }

<b>  // remove result from the <a href=".././TReadTree.html#TReadTree:_tree">_tree</a>, which owns all the temporary candidates,</b>
<b>  // and then delete everything on <a href=".././TReadTree.html#TReadTree:_tree">_tree</a>:</b>
  <a href=".././TReadTree.html#TReadTree:_tree">_tree</a>.Remove(<a href=".././TReadTree.html#TReadTree:_tree">_tree</a>[<a href=".././TReadTree.html#TReadTree:_tree">_tree</a>.GetNumberOfCandidates() - 1]);
  <a href=".././TReadTree.html#TReadTree:_tree">_tree</a>.Cleanup();
*/
  return result;
}

<b>//-----------</b>
<b>// Globals --</b>
<b>//-----------</b>

<b>//-------------------------------------------</b>
<b>//-- Protected Function Member Definitions --</b>
<b>//-------------------------------------------</b>

<a href="../ListOfTypes.html#void">void</a> 
<a name="TReadTree:ReadFill"> </a><a href=".././TReadTree.html#TReadTree:ReadFill">TReadTree::ReadFill</a>(std::istream &amp; stream, 
		      TCandList&amp; daughtersList) {
<b>  // Read a particle from the stream, and use the delimiter to determine</b>
<b>  // open/close of daughter lists, separation betwen sisters, or EOF:</b>
  <a href="../ListOfTypes.html#char">char</a> delimiter = EOF;
  string nodeInfo = (const <a href="../ListOfTypes.html#char">char</a>*) <a href="#TReadTree:Parse">Parse</a>(stream, delimiter);

  if (<a href=".././TReadTree.html#TReadTree:_reader">_reader</a>-&gt;<a href=".././TCandReader.html#TCandReader:Open">Open</a>() == delimiter){   
    ++<a href=".././TReadTree.html#TReadTree:_numOpens">_numOpens</a>;                              // count # of open lists
    TCandList newDaughtersList;
    <a href="#TReadTree:ReadFill">ReadFill</a>(stream, newDaughtersList);      // read daughters into new list

<b>    // Create the candidate and give it its nodeInfo:</b>
    TCandListIterator newDaughterIter(newDaughtersList);
    TCandListIterator * newDaughterIterPtr = &amp;newDaughterIter;
    if (0 == newDaughtersList.GetNumberOfCandidates()){
      newDaughterIterPtr = 0; // send 0 pointer to signal no daughters
    }

    <a href=".././TCandReader.html#TCandReader:Status">TCandReader::Status</a> status;
    TCandidate * cand = <a href=".././TReadTree.html#TReadTree:_reader">_reader</a>-&gt;<a href=".././TCandReader.html#TCandReader:Read">Read</a>(status, nodeInfo.c_str(), newDaughterIterPtr);
    <a href="#TReadTree:CheckStatus">CheckStatus</a>(status, nodeInfo.c_str(), <a href=".././TReadTree.html#TReadTree:_reader">_reader</a>-&gt;<a href=".././TCandReader.html#TCandReader:Name">Name</a>());
    
<b>    // put it on the owning list and its mother's daughters list:</b>
    <a href=".././TReadTree.html#TReadTree:_tree">_tree</a>.Add(*cand);
    daughtersList.Add(*cand);
    
<b>    // The readFill(..) call above may return due to a close(). If there are as</b>
<b>    // many close()'s as open()'s, then this is the end of the input:</b>
    if (0 == <a href=".././TReadTree.html#TReadTree:_numOpens">_numOpens</a>){
      return;
    }
    else {
      <a href="#TReadTree:ReadFill">ReadFill</a>(stream, daughtersList);  // keep reading for sisters or close()
    }
  }
  else if (<a href=".././TReadTree.html#TReadTree:_reader">_reader</a>-&gt;<a href=".././TCandReader.html#TCandReader:Separate">Separate</a>() == delimiter){
<b>    // If there is nodeInfo, create a candidate and put it on the owning list </b>
<b>    // and on its mother's daughters list. Otherwise, we must be at the </b>
<b>    // end of a close(), so no new candidate created:</b>
    if (kFALSE == nodeInfo.empty()){
      <a href=".././TCandReader.html#TCandReader:Status">TCandReader::Status</a> status;
      TCandidate * cand = <a href=".././TReadTree.html#TReadTree:_reader">_reader</a>-&gt;<a href=".././TCandReader.html#TCandReader:Read">Read</a>(status, nodeInfo.c_str(), 0);
      <a href="#TReadTree:CheckStatus">CheckStatus</a>(status, nodeInfo.c_str(), <a href=".././TReadTree.html#TReadTree:_reader">_reader</a>-&gt;<a href=".././TCandReader.html#TCandReader:Name">Name</a>());
      <a href=".././TReadTree.html#TReadTree:_tree">_tree</a>.Add(*cand);
      daughtersList.Add(*cand);
    }
<b>    // In any case, continue to read the sister:</b>
    <a href="#TReadTree:ReadFill">ReadFill</a>(stream, daughtersList);
  }
  else if (<a href=".././TReadTree.html#TReadTree:_reader">_reader</a>-&gt;<a href=".././TCandReader.html#TCandReader:Close">Close</a>() == delimiter){
<b>    // end of a daughters list. Count # of open()'s:</b>
    --<a href=".././TReadTree.html#TReadTree:_numOpens">_numOpens</a>;

<b>    // If there is nodeInfo, create a candidate amd put it on the owning list </b>
<b>    // and on its mother's daughters list. Otherwise, we must be at the </b>
<b>    // end of a close(), so no new candidate created:</b>
    if (kFALSE == nodeInfo.empty()){
      <a href=".././TCandReader.html#TCandReader:Status">TCandReader::Status</a> status;
      TCandidate * cand = <a href=".././TReadTree.html#TReadTree:_reader">_reader</a>-&gt;<a href=".././TCandReader.html#TCandReader:Read">Read</a>(status, nodeInfo.c_str(), 0);
      <a href="#TReadTree:CheckStatus">CheckStatus</a>(status, nodeInfo.c_str(), <a href=".././TReadTree.html#TReadTree:_reader">_reader</a>-&gt;<a href=".././TCandReader.html#TCandReader:Name">Name</a>());
      <a href=".././TReadTree.html#TReadTree:_tree">_tree</a>.Add(*cand);
      daughtersList.Add(*cand);
    }
    return;
  }
  else if (EOF == delimiter){
    if (0 != <a href=".././TReadTree.html#TReadTree:_numOpens">_numOpens</a>){
      cerr &lt;&lt; "<a href=".././TReadTree.html#TReadTree:readFill">TReadTree::readFill</a>(...): end of file with "
		    &lt;&lt; <a href=".././TReadTree.html#TReadTree:_numOpens">_numOpens</a> &lt;&lt; " Open() ('" &lt;&lt; <a href=".././TReadTree.html#TReadTree:_reader">_reader</a>-&gt;<a href=".././TCandReader.html#TCandReader:Open">Open</a>()
		    &lt;&lt; "') characters " &lt;&lt; endl;
      ::abort();
    }
    return;
  }
  else {
    cerr &lt;&lt; "<a href=".././TReadTree.html#TReadTree:read">TReadTree::read</a>(...): unexpectd condition" &lt;&lt; endl;
    ::abort();
  }
}

<b>//------------------------------------------------------------------</b>
TString 
<a name="TReadTree:Parse"> </a><a href=".././TReadTree.html#TReadTree:Parse">TReadTree::Parse</a>(std::istream &amp; stream, <a href="../ListOfTypes.html#char">char</a> &amp; delimiter) const {
  TString result;

<b>  // Read the stream, looking for one of the delimiters. If not found,</b>
<b>  // append the character to the result, ignoring white spaces:</b>
  while (kTRUE) {
    delimiter = stream.get();
    if (<a href=".././TReadTree.html#TReadTree:_reader">_reader</a>-&gt;<a href=".././TCandReader.html#TCandReader:IsDelimiter">IsDelimiter</a>(delimiter) || EOF == delimiter){
      return result;      
    }
    else {// take the character, discarding initial white spaces:
      if (0 == isspace(delimiter) || !result.IsNull()){
	result += delimiter;
      }
    }
  }
}
    
<b>//-------------------------------------------------------------------</b>
<a href="../ListOfTypes.html#void">void</a> 
<a name="TReadTree:CheckStatus"> </a><a href=".././TReadTree.html#TReadTree:CheckStatus">TReadTree::CheckStatus</a>(<a href=".././TCandReader.html#TCandReader:Status">TCandReader::Status</a> status,
			 const <a href="../ListOfTypes.html#char">char</a> * nodeInfo, const <a href="../ListOfTypes.html#char">char</a> * readerName) {
<b>  // Update error statistics, complain and crash if asked to:</b>
  ++<a href=".././TReadTree.html#TReadTree:_numTimes">_numTimes</a>[status];

  if (<a href=".././TCandReader.html#TCandReader:SUCCESS">TCandReader::SUCCESS</a> == status) {
    return;
  }

  cerr &lt;&lt; "ERROR: <a href=".././TReadTree.html">TReadTree</a> read error:" &lt;&lt; endl;
  switch(status) {
  case <a href=".././TCandReader.html#TCandReader:UNKNOWN">TCandReader::UNKNOWN</a>:
    cerr &lt;&lt; "     Input information was not understood."
		  &lt;&lt; endl;
    break;
  case <a href=".././TCandReader.html#TCandReader:MISSING">TCandReader::MISSING</a>:
    cerr &lt;&lt; "     Expected information was missing from the input"
		  &lt;&lt; endl;
    break;
  case <a href=".././TCandReader.html#TCandReader:INVALID">TCandReader::INVALID</a>:
    cerr &lt;&lt; "     Input information understood but incompatible"
		  &lt;&lt; endl;
    break;
  case <a href=".././TCandReader.html#TCandReader:NO_READER">TCandReader::NO_READER</a>:
    cerr &lt;&lt; "     Unregistered <a href=".././TCandReader.html">TCandReader</a> "" &lt;&lt; readerName
		  &lt;&lt; "" requested by input." 
		  &lt;&lt; endl;
    break;
  default:
    cerr &lt;&lt; "     Unknown error status " &lt;&lt; status &lt;&lt; endl;
  }
  
  cerr &lt;&lt; "     Requested <a href=".././TCandReader.html">TCandReader</a> was "" 
		&lt;&lt; readerName &lt;&lt; ""." &lt;&lt; endl
		&lt;&lt; "     Last TCandidate info was ""
		&lt;&lt; nodeInfo &lt;&lt; ""." &lt;&lt; endl;

  if (kTRUE == <a href=".././TReadTree.html#TReadTree:_crashOnError">_crashOnError</a>) {
    abort();
  }
}


<b>//-----------------------------------------</b>
<b>//-- Private Function Member Definitions --</b>
<b>//-----------------------------------------</b>

<a href="../ListOfTypes.html#void">void</a> 
<a name="TReadTree:Initialize"> </a><a href=".././TReadTree.html#TReadTree:Initialize">TReadTree::Initialize</a>() {
  <a href=".././TReadTree.html#TReadTree:_numOpens">_numOpens</a> = 0;
  for (<a href="../ListOfTypes.html#int">int</a> s = 0; s &lt; <a href=".././TCandReader.html#TCandReader:NUM_STATUS_KINDS">TCandReader::NUM_STATUS_KINDS</a>; ++s){
    <a href=".././TReadTree.html#TReadTree:_numTimes">_numTimes</a>[s] = 0;
  }
}
  

<b>//-----------------------------------</b>
<b>//-- Internal Function Definitions --</b>
<b>//-----------------------------------</b>
</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
