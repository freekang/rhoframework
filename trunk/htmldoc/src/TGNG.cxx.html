<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:02:57 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TGNG - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//////////////////////////////////////////////////////////////////////////</b>
<b>//									//</b>
<b>// <a href=".././TGNG.html">TGNG</a>									//</b>
<b>//									//</b>
<b>// Implementation of the GROWING-NEURAL-GAS (GNG)			//</b>
<b>// Part of the Neural Network Objects package (NNO)			//</b>
<b>//									//</b>
<b>// Author List:								//</b>
<b>// Johannes Steffens, Bochum University					//</b>
<b>// M.Kunze, Bochum University						//</b>
<b>// (C) Copyright Johannes Steffens 1995, Ruhr-University Bochum.	//</b>
<b>//									//</b>
<b>//////////////////////////////////////////////////////////////////////////</b>

#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;float.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;
#include "RhoNNO/TGNG.h"
#include "RhoNNO/VNeuralNetPlotter.h"

ClassImp(TGNG)

<a name="TGNG:TGNG"> </a>TGNG::TGNG(Int_t innodes,Int_t maxCells,Double_t winStep,Double_t neiStep,
	   Double_t aWinCount,Double_t aEdgeCount,Double_t minCount,Int_t connectors,
	   Long_t insertStep,Long_t deleteStep,const char* netFile)
	   : VUnsupervisedNet("GNG",innodes,maxCells,netFile) 
{
    fXB.fCells        = 2;
    fXB.fWinStep      = winStep;
    fXB.fNeiStep      = neiStep;
    fXB.fWinCount     = aWinCount;
    fXB.fEdgeCount    = aEdgeCount;
    fXB.fMinCount     = minCount;
    fXB.fConnectors   = connectors;
    fXB.fInsertStep   = insertStep;
    fXB.fDeleteStep   = deleteStep;
    fXB.fInsertCount  = 0;
    fXB.fDeleteCount  = 0;
    
    fXB.fMainEdgeCount = 1;
    fXB.fMainWinCount  = 1;
    
    fU = 0;
    AllocNet();
    InitNet();
}

<b>// copy constructor</b>
<a name="TGNG:TGNG"> </a><a href=".././TGNG.html#TGNG:TGNG">TGNG::TGNG</a>(const <a href=".././TGNG.html">TGNG</a>&amp; gng,const <a href="../ListOfTypes.html#char">char</a>* netFile)
: <a href=".././VUnsupervisedNet.html">VUnsupervisedNet</a>("GNG",gng.<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes,gng.<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes,netFile) 
{
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a> = gng.<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>;
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>  = 0;
    <a href="#TGNG:AllocNet">AllocNet</a>();
    <a href="#TGNG:InitNet">InitNet</a>();
    <a href="#TGNG:CopyData">CopyData</a>(gng);
}


<a name="TGNG:~TGNG"> </a><a href=".././TGNG.html">TGNG</a>::~<a href=".././TGNG.html">TGNG</a>() 
{
    <a href="#TGNG:Deviation">Deviation</a>();
<b>    //transfom fMainWinCount, fMainEdgeCount</b>
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGNG.html#TGNG:fUbound">fUbound</a>;++up) {
	up-&gt;fCount*=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainWinCount;
	for (I=0;I&lt;up-&gt;fNc;++I) up-&gt;fAge[I]*=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainEdgeCount;
    }
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainWinCount=1;
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainEdgeCount=1;
    if (<a href=".././VNeuralNet.html#VNeuralNet:fFilename">fFilename</a>!="") if (<a href=".././VNeuralNet.html#VNeuralNet:fShouldSave">fShouldSave</a>) Save();
    if (<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>!=0) {
	<a href="../ListOfTypes.html#Long_t">Long_t</a> I;
	<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up = <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;
	for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes;++I) {
	    delete[] up-&gt;fVector;
	    delete[] up-&gt;fDiff;
	    delete[] up-&gt;fC;
	    delete[] up-&gt;fAge;
	    ++up;
	}
	delete[] <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;
    }
}

<a name="TGNG:ReadBinary"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGNG.html#TGNG:ReadBinary">TGNG::ReadBinary</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a> = 0;
    fread(&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>,sizeof(<a href=".././TNeuralNetCellParameters.html">TNeuralNetCellParameters</a>),1,<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>);
    <a href="#TGNG:AllocNet">AllocNet</a>();
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGNG.html#TGNG:fUbound">fUbound</a>;++up) {
	<a href=".././TNeuralNetCell.html#TNeuralNetCell:ReadUnitBinary">TNeuralNetCell::ReadUnitBinary</a>(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
	fread(up-&gt;fAge,sizeof(<a href="../ListOfTypes.html#Double_t">Double_t</a>),<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fConnectors,<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>);
        freadvar(up-&gt;fClass);
	for (I=0;I&lt;up-&gt;fNc;++I) up-&gt;fC[I].fPtr = &amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>[up-&gt;fC[I].fID];
    }
}

<a name="TGNG:ReadText"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGNG.html#TGNG:ReadText">TGNG::ReadText</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a> = 0;
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"win_step     %len",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fWinStep);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nei_step     %len",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fNeiStep);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"a_win_count  %len",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fWinCount);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"a_edge_count %len",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fEdgeCount);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"min_count    %len",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMinCount);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"cells        %in",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"connectors   %in",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fConnectors);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"insert_step  %lin",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fInsertStep);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"delete_step  %lin",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fDeleteStep);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"ins_count    %lin",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fInsertCount);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"del_count    %lin",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fDeleteCount);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"n");
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"main_win_count  %len",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainWinCount);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"main_edge_count %len",&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainEdgeCount);
    
    <a href="#TGNG:AllocNet">AllocNet</a>();
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGNG.html#TGNG:fUbound">fUbound</a>;++up) {
	<a href=".././TNeuralNetCell.html#TNeuralNetCell:ReadUnitText">TNeuralNetCell::ReadUnitText</a>(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
	fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nedge count ");
	for (I=0;I&lt;up-&gt;fNc;++I) fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"%le ",&amp;up-&gt;fAge[I]);
	fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nclass            %in",&amp;up-&gt;fClass);
	for (I=0;I&lt;up-&gt;fNc;++I) up-&gt;fC[I].fPtr=&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>[up-&gt;fC[I].fID];
    }
}

<a name="TGNG:WriteBinary"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGNG.html#TGNG:WriteBinary">TGNG::WriteBinary</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    fwrite(&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>,sizeof(<a href=".././TNeuralNetCellParameters.html">TNeuralNetCellParameters</a>),1,<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>);
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGNG.html#TGNG:fUbound">fUbound</a>;++up) {
	<a href=".././TNeuralNetCell.html#TNeuralNetCell:WriteUnitBinary">TNeuralNetCell::WriteUnitBinary</a>(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
	fwrite(up-&gt;fAge,sizeof(<a href="../ListOfTypes.html#Double_t">Double_t</a>),<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fConnectors,<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>);
	fwritevar(up-&gt;fClass);
    }
}

<a name="TGNG:WriteText"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGNG.html#TGNG:WriteText">TGNG::WriteText</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"win_step     %len",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fWinStep);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nei_step     %len",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fNeiStep);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"a_win_count  %len",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fWinCount);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"a_edge_count %len",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fEdgeCount);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"min_count    %len",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMinCount);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"cells        %in",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"connectors   %in",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fConnectors);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"insert_step  %lin",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fInsertStep);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"delete_step  %lin",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fDeleteStep);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"ins_count    %lin",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fInsertCount);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"del_count    %lin",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fDeleteCount);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"n");
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"main_win_count  %len",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainWinCount);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"main_edge_count %len",<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainEdgeCount);
    
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGNG.html#TGNG:fUbound">fUbound</a>;++up) {
	<a href=".././TNeuralNetCell.html#TNeuralNetCell:WriteUnitText">TNeuralNetCell::WriteUnitText</a>(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
	fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nedge count ");
	for (I=0;I&lt;up-&gt;fNc;++I) fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"%le ",up-&gt;fAge[I]);
	fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nclass            %in",up-&gt;fClass);
    }
}

<a name="TGNG:AllocNet"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGNG.html#TGNG:AllocNet">TGNG::AllocNet</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a> = new <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>[<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes]; TestPointer(<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>);
    <a href=".././TGNG.html#TGNG:fUbound">fUbound</a>=&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>[<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells];
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up = <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;
    for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes;++I) {
	up-&gt;fVector    = new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes];  TestPointer(up-&gt;fVector);
	up-&gt;fDiff      = new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes];  TestPointer(up-&gt;fDiff);
	up-&gt;fC         = new connector[<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fConnectors]; TestPointer(up-&gt;fC);
	up-&gt;fAge = new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fConnectors];  TestPointer(up-&gt;fAge);
	up-&gt;fNc = 0;
	up-&gt;fCount = 0;
	up-&gt;fID = I;
	++up;
    }
}

<a name="TGNG:InitNet"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGNG.html#TGNG:InitNet">TGNG::InitNet</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> J;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGNG.html#TGNG:fUbound">fUbound</a>;++up) {
	for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++J) up-&gt;fVector[J]=Random();
	up-&gt;fNc = 0;
    }
    
    for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes;++J) <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>[J].fClass=0;
    
    <a href="#TGNG:Connect">Connect</a>(&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>[0],&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>[1]);
}

<a name="TGNG:CopyData"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGNG.html#TGNG:CopyData">TGNG::CopyData</a>(const <a href=".././TGNG.html">TGNG</a>&amp; gng) 
{
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* thisup = <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* fromup = gng.<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
    
<b>    //check integrity</b>
    if (<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes    !=gng.<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes)     Errorf("cannot copy data; innodes not identical");
    if (<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes   !=gng.<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes)    Errorf("cannot copy data; outnodes not identical");
    if (<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fConnectors!=gng.<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fConnectors) Errorf("cannot copy data; max connectors not identical");
    
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a> = gng.<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>;
    <a href=".././TGNG.html#TGNG:fUbound">fUbound</a> = &amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>[<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells];
    for (I=0;I&lt;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells;++I) {
	memcpy(thisup-&gt;fVector,fromup-&gt;fVector,sizeof(<a href="../ListOfTypes.html#Double_t">Double_t</a>)*<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes);
	thisup-&gt;fNc = fromup-&gt;fNc;
	for (J=0;J&lt;thisup-&gt;fNc;++J) {
            thisup-&gt;fC[J].fPtr=&amp;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>[((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)(fromup-&gt;fC[J].fPtr))-&gt;fID];
            thisup-&gt;fAge[J]=fromup-&gt;fAge[J];
	}
	thisup-&gt;fCount = fromup-&gt;fCount;
	thisup-&gt;fClass = fromup-&gt;fClass;
	++thisup;
	++fromup;
    }
}

<b>//Disconnect only if both units have more than one connectors</b>
<a name="TGNG:CondDisconnect"> </a><a href="../ListOfTypes.html#Int_t">Int_t</a>  <a href=".././TGNG.html#TGNG:CondDisconnect">TGNG::CondDisconnect</a>(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up1,<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up2) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    if ((up1-&gt;fNc==1) || (up2-&gt;fNc==1)) return 0;
    for (I=0;I&lt;up1-&gt;fNc;++I) if ((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up1-&gt;fC[I].fPtr==up2) break;
    if (I&lt;up1-&gt;fNc) up1-&gt;fC[I]=up1-&gt;fC[--up1-&gt;fNc]; else return 0;
    for (I=0;I&lt;up2-&gt;fNc;++I) if ((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up2-&gt;fC[I].fPtr==up1) break;
    if (I&lt;up2-&gt;fNc) up2-&gt;fC[I]=up2-&gt;fC[--up2-&gt;fNc];
    return 1;
}

<a name="TGNG:Connect"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGNG.html#TGNG:Connect">TGNG::Connect</a>(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up1,<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up2) 
{
    if ((up1-&gt;fNc==<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fConnectors)||(up2-&gt;fNc==<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fConnectors)) return;
    up1-&gt;fAge[up1-&gt;fNc]=1.0/<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainEdgeCount;
    up1-&gt;fC[up1-&gt;fNc++].fPtr = up2;
    up2-&gt;fAge[up2-&gt;fNc]=1.0/<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainEdgeCount;
    up2-&gt;fC[up2-&gt;fNc++].fPtr = up1;
}

<a name="TGNG:UpdateConnector"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGNG.html#TGNG:UpdateConnector">TGNG::UpdateConnector</a>(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up1,<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up2) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
    for (I=0;I&lt;up1-&gt;fNc;++I) if ((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up1-&gt;fC[I].fPtr==up2) break;
    if (I==up1-&gt;fNc) { <a href="#TGNG:Connect">Connect</a>(up1,up2); return; }
    up1-&gt;fAge[I] += <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fEdgeCount;
    for (J=0;J&lt;up2-&gt;fNc;++J) if ((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up2-&gt;fC[J].fPtr==up1) break;
    up2-&gt;fAge[J] = up1-&gt;fAge[I];
}

<a name="TGNG:GetWinnerCell"> </a><a href="../ListOfTypes.html#Int_t">Int_t</a>  <a href=".././TGNG.html#TGNG:GetWinnerCell">TGNG::GetWinnerCell</a>(<a href="../ListOfTypes.html#NNO_INTYPE">NNO_INTYPE</a>* in) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> s_dist;
    <a href=".././TGNG.html#TGNG:fMinDistSquare1">fMinDistSquare1</a> = DBL_MAX;
    <a href=".././TGNG.html#TGNG:fMinDistSquare2">fMinDistSquare2</a> = DBL_MAX;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    J = 0;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGNG.html#TGNG:fUbound">fUbound</a>;++up){
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* v = up-&gt;fVector;
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* d = up-&gt;fDiff;
	<a href="../ListOfTypes.html#NNO_INTYPE">NNO_INTYPE</a>* i = in;
	s_dist = 0.0;
	for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++I) { 
	    *d =*i++ - *v++; 
	    s_dist+=*d * *d; 
	    ++d;
	}
	
	<a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a>[J++] = s_dist;
	
	if (s_dist&lt;<a href=".././TGNG.html#TGNG:fMinDistSquare1">fMinDistSquare1</a>) { 
	    <a href=".././TGNG.html#TGNG:fMinDistSquare2">fMinDistSquare2</a> = <a href=".././TGNG.html#TGNG:fMinDistSquare1">fMinDistSquare1</a>; 
	    <a href=".././TGNG.html#TGNG:fUwin2">fUwin2</a> = <a href=".././TGNG.html#TGNG:fUwin1">fUwin1</a>; 
	    <a href=".././TGNG.html#TGNG:fMinDistSquare1">fMinDistSquare1</a> = s_dist; 
	    <a href=".././TGNG.html#TGNG:fUwin1">fUwin1</a> = up; 
	}
	else if (s_dist&lt;<a href=".././TGNG.html#TGNG:fMinDistSquare2">fMinDistSquare2</a>) { 
	    <a href=".././TGNG.html#TGNG:fMinDistSquare2">fMinDistSquare2</a> = s_dist; 
	    <a href=".././TGNG.html#TGNG:fUwin2">fUwin2</a>=up; 
	}
	
    }
    
    if (<a href=".././VNeuralNet.html#VNeuralNet:fPlotter">fPlotter</a>) <a href=".././VNeuralNet.html#VNeuralNet:fPlotter">fPlotter</a>-&gt;<a href=".././VNeuralNetPlotter.html#VNeuralNetPlotter:AddTestSample">AddTestSample</a>(<a href=".././TGNG.html#TGNG:fMinDistSquare1">fMinDistSquare1</a>);
    
    return <a href=".././TGNG.html#TGNG:fUwin1">fUwin1</a>-&gt;fID;
}

<a name="TGNG:Train"> </a><a href="../ListOfTypes.html#Double_t">Double_t</a>  <a href=".././TGNG.html#TGNG:Train">TGNG::Train</a>(<a href="../ListOfTypes.html#NNO_INTYPE">NNO_INTYPE</a>* in,<a href="../ListOfTypes.html#NNO_OUTTYPE">NNO_OUTTYPE</a>*) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
    <a href="#TGNG:Recall">Recall</a>(in);  //make output of all cells and neurons find the winners
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* unei;
    <a href="../ListOfTypes.html#Double_t">Double_t</a>* vwin = <a href=".././TGNG.html#TGNG:fUwin1">fUwin1</a>-&gt;fVector;
    <a href="../ListOfTypes.html#Double_t">Double_t</a>* dwin = <a href=".././TGNG.html#TGNG:fUwin1">fUwin1</a>-&gt;fDiff;
    for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++J) *vwin++ += *dwin++ * <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fWinStep;
    for (I=0;I&lt;<a href=".././TGNG.html#TGNG:fUwin1">fUwin1</a>-&gt;fNc;++I) {
	unei = (<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)<a href=".././TGNG.html#TGNG:fUwin1">fUwin1</a>-&gt;fC[I].fPtr;
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* v = unei-&gt;fVector;
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* d = unei-&gt;fDiff;
	for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++J) *v++ += *d++ * <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fNeiStep;
    }
    <a href="#TGNG:UpdateConnector">UpdateConnector</a>(<a href=".././TGNG.html#TGNG:fUwin1">fUwin1</a>,<a href=".././TGNG.html#TGNG:fUwin2">fUwin2</a>); //update edge_count of connector; if Uwin1,Uwin2 are not connected, connect them
    <a href=".././TGNG.html#TGNG:fUwin1">fUwin1</a>-&gt;fCount += <a href=".././TGNG.html#TGNG:fMinDistSquare1">fMinDistSquare1</a>;
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainWinCount  *= (1.0 - <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fWinCount);
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainEdgeCount *= (1.0 - <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fEdgeCount);
    
    if (<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fInsertStep&gt;0) 
	if (<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fInsertCount++==<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fInsertStep) {
	    <a href="#TGNG:Insert">Insert</a>(); 
	    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fInsertCount = 0;
	}
	
    if (<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fDeleteStep&gt;0) 
	if (<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fDeleteCount++==<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fDeleteStep) {
	    <a href="#TGNG:Prune">Prune</a>(); 
	    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fDeleteCount = 0;
	}
	
    <a href=".././VNeuralNet.html#VNeuralNet:fShouldSave">fShouldSave</a> = kTRUE;
    
    return <a href=".././TGNG.html#TGNG:fUwin1">fUwin1</a>-&gt;fID;
}

<a name="TGNG:Deviation"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGNG.html#TGNG:Deviation">TGNG::Deviation</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGNG.html#TGNG:fUbound">fUbound</a>;++up) <a href=".././TNeuralNetCell.html#TNeuralNetCell:GetSDev">TNeuralNetCell::GetSDev</a>((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
}

<a name="TGNG:Insert"> </a><a href="../ListOfTypes.html#Int_t">Int_t</a> <a href=".././TGNG.html#TGNG:Insert">TGNG::Insert</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* umax1;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* umax2;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* unew;
    
    if (<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells==<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes) return 0; //break if there are no cells availiable
<b>    //find cell with highest win_count</b>
    <a href="../ListOfTypes.html#Double_t">Double_t</a> win_count=-1;
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGNG.html#TGNG:fUbound">fUbound</a>;++up) 
	if (up-&gt;fCount&gt;win_count) {
	    win_count = up-&gt;fCount; 
	    umax1 = up;
	}
	
<b>	//create new cell</b>
	unew = <a href=".././TGNG.html#TGNG:fUbound">fUbound</a>++;
	++<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fCells;
	unew-&gt;fNc = 0;
	
	if (umax1-&gt;fNc==0) { 
	    Warningf(stdout,"CORRUPT NETWORK INTEGRITY! isolated cell found, please call developer"); 
	    return 0; 
	}
	
<b>	//find neigbour to MaxCount with highest win_count</b>
	win_count=-1;
	for (I=0;I&lt;umax1-&gt;fNc;++I) 
	    if (((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax1-&gt;fC[I].fPtr)-&gt;fCount&gt;win_count) { 
		win_count = ((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax1-&gt;fC[I].fPtr)-&gt;fCount; 
		umax2=(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax1-&gt;fC[I].fPtr; 
	    }
	    
<b>	    //connect new cell with common neighbours of umax1 and umax2</b>
	    for (I=0;I&lt;umax1-&gt;fNc;++I) 
		for (J=0;J&lt;umax2-&gt;fNc;++J)
		    if (umax1-&gt;fC[I].fPtr==umax2-&gt;fC[J].fPtr) 
			<a href="#TGNG:Connect">Connect</a>((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax1-&gt;fC[I].fPtr,unew);
		    
		    <a href="#TGNG:Connect">Connect</a>(unew,umax1);     //connect umax1 and unew
		    <a href="#TGNG:Connect">Connect</a>(unew,umax2);     //connect umax2 and unew
		    <a href=".././TNeuralNetCell.html#TNeuralNetCell:Disconnect">TNeuralNetCell::Disconnect</a>((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax1,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax2);  //disconnect umax1 and umax2
		    
		    <a href=".././TNeuralNetCell.html#TNeuralNetCell:InitVector">TNeuralNetCell::InitVector</a>((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)unew,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax1,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax2,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
		    <a href=".././TNeuralNetCell.html#TNeuralNetCell:InitCount">TNeuralNetCell::InitCount</a> ((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)unew);
		    
<b>		    //transfom fMainWinCount, fMainEdgeCount</b>
		    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGNG.html#TGNG:fUbound">fUbound</a>;++up) {
			up-&gt;fCount *= <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainWinCount;
			for (I=0;I&lt;up-&gt;fNc;++I) up-&gt;fAge[I] *= <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainEdgeCount;
		    }
		    
		    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainWinCount  = 1;
		    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainEdgeCount = 1;
		    
		    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGNG.html#TGNG:fUbound">fUbound</a>;++up) <a href=".././TNeuralNetCell.html#TNeuralNetCell:CheckConnections">TNeuralNetCell::CheckConnections</a>((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up);
		    
		    return 1;  //insertion was successful
}

<a name="TGNG:Prune"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TGNG.html#TGNG:Prune">TGNG::Prune</a>(<a href="../ListOfTypes.html#void">void</a>) 
{ // remove edges
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    
<b>    //transfom fMainWinCount, fMainEdgeCount</b>
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGNG.html#TGNG:fUbound">fUbound</a>;++up) {
	up-&gt;fCount*=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainWinCount;
	for (I=0;I&lt;up-&gt;fNc;++I) up-&gt;fAge[I]*=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainEdgeCount;
    }
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainWinCount  = 1;
    <a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMainEdgeCount = 1;
    
<b>    //remove all edges with edge_count&lt;fMinCount</b>
    for(up=<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fU">fU</a>;up&lt;<a href=".././TGNG.html#TGNG:fUbound">fUbound</a>;++up) {
        I = 0;
	while (I&lt;up-&gt;fNc) {
	    if (up-&gt;fAge[I]&lt;<a href=".././VUnsupervisedNet.html#VUnsupervisedNet:fXB">fXB</a>.fMinCount) {
		if (!<a href="#TGNG:CondDisconnect">CondDisconnect</a>(up,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up-&gt;fC[I].fPtr)) ++I;
	    } else ++I;
	}
    }
}

</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
