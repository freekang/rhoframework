<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:03:30 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TThrustVector - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//--------------------------------------------------------------------------</b>
<b>// File and Version Information:</b>
<b>// 	$Id: <a href=".././TThrustVector.html">TThrustVector</a>.cc,v 1.2 1997/1/20 10:05:13 </b>
<b>//</b>
<b>// Description:</b>
<b>//      Class <a href=".././TThrustVector.html">TThrustVector</a> - used to calculate the thrust object </b>
<b>//                              <a href=".././TThrust.html">TThrust</a>, without using TSelectors.</b>
<b>//</b>
<b>// Environment:</b>
<b>//      Software developed for the BaBar Detector at the SLAC B-Factory.</b>
<b>//</b>
<b>// Author List:</b>
<b>//      G. Hamel de Monchenault </b>
<b>//      John Back   Moved to BetaCoreTools</b>
<b>//      </b>
<b>// ROOT Version by Marcel Kunze, RUB</b>
<b>//--------------------------------------------------------------------------</b>

#include &lt;math.h&gt;
#include &lt;assert.h&gt;
#include "RhoTools/TThrustVector.h"
#include "RhoBase/TCandList.h"
#include "RhoBase/TCandListIterator.h"
#include "TLorentzVector.h"
#include "RhoTools/TBooster.h"
#include "RhoBase/TCandidate.h"

ClassImp(TThrustVector)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, TThrustVector *&amp;obj)
{
   obj = (TThrustVector *) buf.ReadObject(TThrustVector::Class());
   return buf;
}

<b>// constants global to this file</b>
const <a href="../ListOfTypes.html#double">double</a> epsilon = 0.0001;
const <a href="../ListOfTypes.html#int">int</a> nSegsTheta = 10; // number of initial segments in theta
const <a href="../ListOfTypes.html#int">int</a> nSegsPhi = 10; // number of initial segments in phi
const <a href="../ListOfTypes.html#int">int</a> nSegs = nSegsTheta * nSegsPhi; // total number of segments

<a name="TThrustVector:TThrustVector"> </a><a href=".././TThrustVector.html#TThrustVector:TThrustVector">TThrustVector::TThrustVector</a>()
  : <a href=".././TThrustVector.html#TThrustVector:_thrust">_thrust</a>(0), <a href=".././TThrustVector.html#TThrustVector:_denom_sum">_denom_sum</a>(0), <a href=".././TThrustVector.html#TThrustVector:_booster">_booster</a>(0), <a href=".././TThrustVector.html#TThrustVector:_cutInCms">_cutInCms</a>(kFALSE), <a href=".././TThrustVector.html#TThrustVector:_charged">_charged</a>(kFALSE),
    <a href=".././TThrustVector.html#TThrustVector:_checkCharge">_checkCharge</a>(kFALSE)
{
}

<a href="../ListOfTypes.html#void">void</a>
<a name="TThrustVector:BoostAndCompute"> </a><a href=".././TThrustVector.html#TThrustVector:BoostAndCompute">TThrustVector::BoostAndCompute</a>( TCandList&amp; list,
				     <a href=".././TBooster.html">TBooster</a>* booster, 
				     <a href="../ListOfTypes.html#Bool_t">Bool_t</a> cutInCms, <a href="../ListOfTypes.html#Bool_t">Bool_t</a> checkCharge,
				     <a href="../ListOfTypes.html#Bool_t">Bool_t</a> charged) {
  <a href=".././TThrustVector.html#TThrustVector:_cutInCms">_cutInCms</a> = cutInCms;
  <a href=".././TThrustVector.html#TThrustVector:_checkCharge">_checkCharge</a> = checkCharge;
  <a href=".././TThrustVector.html#TThrustVector:_charged">_charged</a> = charged;

  <a href=".././TThrustVector.html#TThrustVector:_booster">_booster</a> = booster;

  assert( <a href=".././TThrustVector.html#TThrustVector:_booster">_booster</a> != 0 );
  TCandList boostedList;
  <a href=".././TThrustVector.html#TThrustVector:_booster">_booster</a>-&gt;<a href=".././TBooster.html#TBooster:BoostTo">BoostTo</a>( list, boostedList );
  <a href="#TThrustVector:Compute">Compute</a>( boostedList);
  boostedList.Cleanup();
}

<a href="../ListOfTypes.html#void">void</a>
<a name="TThrustVector:Compute"> </a><a href=".././TThrustVector.html#TThrustVector:Compute">TThrustVector::Compute</a>(TCandList&amp; list) {

<b>  // initialize</b>
  <a href="#TThrustVector:Reset">Reset</a>();
  
<b>  // variables</b>
  TCandidate* trkptr;
  <a href="../ListOfTypes.html#int">int</a> i,j;
 
  TCandListIterator iter(list);
   
  const <a href="../ListOfTypes.html#int">int</a> maxNtracks = 100; // maximum number of tracks in event

<b>  // copy momentum components to local variables for speed</b>
  <a href="../ListOfTypes.html#double">double</a> valX[maxNtracks], valY[maxNtracks], valZ[maxNtracks];
  <a href="../ListOfTypes.html#int">int</a> nTracks = 0; // number of tracks, initialized to 0
  <a href="../ListOfTypes.html#double">double</a> denominator = 0; // sum of magnitudes of momentum
<b>  // start a loop over the all tracks</b>
  while ( (trkptr = iter.Next()) &amp;&amp; (nTracks&lt;maxNtracks) ) {

<b>    // selection</b>

    if (<a href=".././TThrustVector.html#TThrustVector:_checkCharge">_checkCharge</a> == kTRUE &amp;&amp; <a href="#TThrustVector:acceptedTrack">acceptedTrack</a>(trkptr) == kFALSE) continue;

    TLorentzVector cmList(trkptr-&gt;P4());
    TVector3 tmp(cmList.X(),cmList.Y(),cmList.Z());
    valX[nTracks] = tmp.X();
    valY[nTracks] = tmp.Y();
    valZ[nTracks] = tmp.Z();
    denominator += tmp.Mag();
    nTracks++;
  } // end while
<b>  // forward information to other init</b>
  <a href="#TThrustVector:init">init</a>( valX, valY, valZ, denominator, nTracks );
}

<a href="../ListOfTypes.html#Bool_t">Bool_t</a>
<a name="TThrustVector:acceptedTrack"> </a><a href=".././TThrustVector.html#TThrustVector:acceptedTrack">TThrustVector::acceptedTrack</a>(const TCandidate *cand) const {

<b>  // Do what TChargedSelector effectively does...</b>

  <a href="../ListOfTypes.html#Bool_t">Bool_t</a> answer = kTRUE;
  <a href="../ListOfTypes.html#Bool_t">Bool_t</a> cutInCms = kFALSE;
  <a href="../ListOfTypes.html#double">double</a> pMin = 0.0, pMax = 10.0, thMin = 0.0, thMax = TMath::Pi();
  
  <a href="../ListOfTypes.html#double">double</a> q = cand-&gt;Charge();
  <a href="../ListOfTypes.html#Bool_t">Bool_t</a> smallQ = fabs(q)&lt;0.0001;

  if ((<a href=".././TThrustVector.html#TThrustVector:_charged">_charged</a> == kTRUE  &amp;&amp; smallQ == kTRUE) ||
      (<a href=".././TThrustVector.html#TThrustVector:_charged">_charged</a> == kFALSE &amp;&amp; smallQ == kFALSE)) return kFALSE;

  <a href="../ListOfTypes.html#double">double</a> p = cand-&gt;P();
  <a href="../ListOfTypes.html#double">double</a> theta = cand-&gt;P3().Theta();

  if (<a href=".././TThrustVector.html#TThrustVector:_cutInCms">_cutInCms</a> == kTRUE &amp;&amp; <a href=".././TThrustVector.html#TThrustVector:_booster">_booster</a> != 0) {

    TCandidate cCMS = <a href=".././TThrustVector.html#TThrustVector:_booster">_booster</a>-&gt;<a href=".././TBooster.html#TBooster:BoostTo">BoostTo</a>(*cand);
    p     = cCMS.P();
    theta = cCMS.P3().Theta();
  } else {
    p     = cand-&gt;P();
    theta = cand-&gt;P3().Theta();
  }

  if( p &lt; pMin || p &gt; pMax ) {
    answer = kFALSE;
  }

  if( theta &lt; thMin || theta &gt; thMax ) {
    answer = kFALSE;
  }

  return answer;

}

<a href="../ListOfTypes.html#void">void</a>
<a name="TThrustVector:init"> </a><a href=".././TThrustVector.html#TThrustVector:init">TThrustVector::init</a>(const <a href="../ListOfTypes.html#double">double</a> * valX, const <a href="../ListOfTypes.html#double">double</a> * valY,
		      const <a href="../ListOfTypes.html#double">double</a> * valZ, const <a href="../ListOfTypes.html#double">double</a> denominator,
		      const unsigned nTracks) {

  if (nTracks&gt;0) { // make sure there is at least one track
<b>    // calculate denominator</b>
    <a href="#TThrustVector:calc_denom">calc_denom</a>(valX,valY,valZ,nTracks);
<b>    // get initial estimate for thrust axis</b>
    <a href="../ListOfTypes.html#double">double</a> * init_axis = <a href="#TThrustVector:get_initial_axis">get_initial_axis</a>(valX,valY,valZ,nTracks);
<b>    // use initial estimate to get more refined axis</b>
    <a href="../ListOfTypes.html#double">double</a> * final_axis = <a href="#TThrustVector:get_final_axis">get_final_axis</a>(init_axis[0],init_axis[1],valX,valY,
                            valZ,nTracks);
<b>    // convert theta,phi to x,y,z</b>
    <a href="../ListOfTypes.html#double">double</a> * theAxis = <a href="#TThrustVector:get_axis">get_axis</a>(final_axis[0],final_axis[1]);
<b>    // set axis</b>
    <a href=".././TThrustVector.html#TThrustVector:_axis">_axis</a> = TVector3( theAxis[0], theAxis[1], theAxis[2] ); 
    if ( <a href=".././TThrustVector.html#TThrustVector:_axis">_axis</a>.CosTheta()&lt;0 ) 
      {
	<a href=".././TThrustVector.html#TThrustVector:_axis">_axis</a> *= -1;
      } // reverse
<b>    // set thrust</b>
    <a href=".././TThrustVector.html#TThrustVector:_thrust">_thrust</a> = <a href="#TThrustVector:calc_thrust">calc_thrust</a>(theAxis,valX,valY,valZ,nTracks);
<b>    // clean up</b>
    delete [] init_axis;  delete [] final_axis; delete [] theAxis;
  } // end if nTracks&gt;0
}

<a href="../ListOfTypes.html#void">void</a>
<a name="TThrustVector:Reset"> </a><a href=".././TThrustVector.html#TThrustVector:Reset">TThrustVector::Reset</a>() 
{
  <a href=".././TThrustVector.html#TThrustVector:_thrust">_thrust</a>=0;
  <a href=".././TThrustVector.html#TThrustVector:_axis">_axis</a> = TVector3(0.,0.,0.);
  <a href=".././TThrustVector.html#TThrustVector:_denom_sum">_denom_sum</a>=0.;
}

<a name="TThrustVector:~TThrustVector"> </a><a href=".././TThrustVector.html">TThrustVector</a>::~<a href=".././TThrustVector.html">TThrustVector</a>() {}


<b>// return theta, phi initial</b>
<a name="TThrustVector:get_initial_axis"> </a><a href="../ListOfTypes.html#double">double</a> * <a href=".././TThrustVector.html#TThrustVector:get_initial_axis">TThrustVector::get_initial_axis</a>(const <a href="../ListOfTypes.html#double">double</a> * valX, 
					   const <a href="../ListOfTypes.html#double">double</a> * valY,
					   const <a href="../ListOfTypes.html#double">double</a> * valZ, 
					   const unsigned nTracks) const {

  <a href="../ListOfTypes.html#int">int</a> i,j;
<b>  // get initial estimate for thrust axis</b>
  <a href="../ListOfTypes.html#double">double</a> rInitial[3]; // 3 dimensions
  <a href="../ListOfTypes.html#double">double</a> thrust[nSegs], max=0;
  <a href="../ListOfTypes.html#int">int</a> indI=0,indJ=0,index = -1; // index to max

<b>  // calculate the thrust in different theta, phi regions</b>
  for (i=0;i&lt;nSegsTheta;i++) { // loop over theta
      <a href="../ListOfTypes.html#double">double</a> z = cos( TMath::Pi() * i / (nSegsTheta-1) ); // z
    <a href="../ListOfTypes.html#double">double</a> invZ = sqrt(1-z*z);
    for (j=0;j&lt;nSegsPhi;j++) { // loop over phi
      rInitial[0] = invZ * cos( 2 * TMath::Pi() * j / nSegsPhi ); // x
      rInitial[1] = invZ * sin( 2 * TMath::Pi() * j / nSegsPhi ); // x
      rInitial[2] = z;
<b>      // get thrust for this axis</b>
      thrust[i*nSegsPhi+j] = <a href="#TThrustVector:calc_thrust">calc_thrust</a>(rInitial,valX,valY,valZ,nTracks);
      if (thrust[i*nSegsPhi+j]&gt;max) {
        index = i*nSegsPhi+j;
        indI = i;
	indJ = j;
        max = thrust[index];
      } // end if thrust&gt;max
    } // end for i
  } // end for j

<b>  // take max and one point on either size, fitting to a parabola and</b>
<b>  // extrapolating to the <a href="../ListOfTypes.html#real">real</a> max.  Do this separately for each dimension.</b>
<b>  // y = ax^2 + bx + c.  At the max, x = 0, on either side, x = +/-1.</b>
<b>  // do phi first</b>
  <a href="../ListOfTypes.html#double">double</a> a, b, c=max;
  <a href="../ListOfTypes.html#int">int</a> ind1 = indJ + 1;
  if (ind1&gt;=nSegsPhi)
    ind1 -= nSegsPhi;
  <a href="../ListOfTypes.html#int">int</a> ind2 = indJ - 1;
  if (ind2&lt;0)
    ind2 += nSegsPhi;
  a = ( thrust[ind1]+thrust[ind2]-2*c ) / 2;
  b = thrust[ind1] - a - c;
  <a href="../ListOfTypes.html#double">double</a> maxPhiInd = 0; // avoid divide by 0
  if (a!=0)
    maxPhiInd = -b/(2*a); // max 
<b>  // do theta</b>
  <a href="../ListOfTypes.html#double">double</a> maxThetaInd;
  if (indI==0||indI==(nSegsTheta-1)) // special case of end points
    maxThetaInd = indI;
  else { // not at end point
    ind1 = indI + 1;
    ind2 = indI - 1;
    a = ( thrust[ind1] + thrust[ind2] - 2*c ) / 2;
    b = thrust[ind1] - a - c; 
    maxThetaInd = 0; // avoid divide by 0
    if (a!=0)
      maxThetaInd = -b/(2*a); // max
  } // end else

<b>  // calculate best guess at theta and phi then get starting point to iterate</b>
  <a href="../ListOfTypes.html#double">double</a> bestTheta = TMath::Pi() * (maxThetaInd+indI) / (nSegsTheta-1);
  <a href="../ListOfTypes.html#double">double</a> bestPhi = 2 * TMath::Pi() * (maxPhiInd+indJ) / nSegsPhi;

<b>  // set return values</b>
  <a href="../ListOfTypes.html#double">double</a> * result = new <a href="../ListOfTypes.html#double">double</a>[2];
  result[0] = bestTheta;
  result[1] = bestPhi;
  return result;
} // end get_initial_axis

<b>// get the final axis to be used</b>
<a name="TThrustVector:get_final_axis"> </a><a href="../ListOfTypes.html#double">double</a> * <a href=".././TThrustVector.html#TThrustVector:get_final_axis">TThrustVector::get_final_axis</a>(<a href="../ListOfTypes.html#double">double</a> bestTheta, <a href="../ListOfTypes.html#double">double</a> bestPhi,
					 const <a href="../ListOfTypes.html#double">double</a>* valX, 
					 const <a href="../ListOfTypes.html#double">double</a>* valY,
					 const <a href="../ListOfTypes.html#double">double</a>* valZ, 
					 const unsigned nTracks) const {

  <a href="../ListOfTypes.html#double">double</a> maxChange1,maxChange2;
  <a href="../ListOfTypes.html#double">double</a> a,b,c;
  <a href="../ListOfTypes.html#double">double</a> theThrust;
  <a href="../ListOfTypes.html#int">int</a> mand_ct = 3; // mandatory number of passes
  <a href="../ListOfTypes.html#int">int</a> max_ct = 1000; // a very large number of iterations

<b>  // loop until done</b>
  <a href="../ListOfTypes.html#int">int</a> done;
  do { 
<b>    // get three axis to estimate maximum</b>
    <a href="../ListOfTypes.html#double">double</a> * theAxis = <a href="#TThrustVector:get_axis">get_axis</a>(bestTheta,bestPhi);
    <a href="../ListOfTypes.html#double">double</a> * Axis2 = <a href="#TThrustVector:get_axis">get_axis</a>(bestTheta+epsilon,bestPhi); // do differential
    <a href="../ListOfTypes.html#double">double</a> * Axis3 = <a href="#TThrustVector:get_axis">get_axis</a>(bestTheta-epsilon,bestPhi); // do differential

<b>    // use parabolic approx as above</b>
    c = <a href="#TThrustVector:calc_thrust">calc_thrust</a>(theAxis,valX,valY,valZ,nTracks);
    a = ( <a href="#TThrustVector:calc_thrust">calc_thrust</a>(Axis2,valX,valY,valZ,nTracks) - 2 * c +
          <a href="#TThrustVector:calc_thrust">calc_thrust</a>(Axis3,valX,valY,valZ,nTracks) ) / 2;
    b = <a href="#TThrustVector:calc_thrust">calc_thrust</a>(Axis2,valX,valY,valZ,nTracks) - a - c; 

<b>    // calculate max</b>
    maxChange1 = 10 * ( b&lt;0 ? -1 : 1 ); // linear 
    if (a!=0)
      maxChange1 = -b/(2*a);

<b>    // clean up</b>
    delete [] theAxis; delete [] Axis2; delete [] Axis3;

<b>    // make sure change is small to avoid convergence problems</b>
    while (fabs(maxChange1*epsilon)&gt;TMath::Pi()/4) {maxChange1 /= 2;} // small changes

<b>    // special case, use a different phi</b>
    if (maxChange1==0&amp;&amp;(bestTheta==0||bestTheta==TMath::Pi())) { 
      bestPhi += 2*TMath::Pi();
      if (bestPhi&gt;2*TMath::Pi())
        bestPhi -= 2 * TMath::Pi();

<b>      // get three axis to estimate maximum</b>
      theAxis = <a href="#TThrustVector:get_axis">get_axis</a>(bestTheta,bestPhi);
      Axis2 = <a href="#TThrustVector:get_axis">get_axis</a>(bestTheta+epsilon,bestPhi); // do differential
      Axis3 = <a href="#TThrustVector:get_axis">get_axis</a>(bestTheta-epsilon,bestPhi); // do differential

<b>      // use parabolic approx as above</b>
      c = <a href="#TThrustVector:calc_thrust">calc_thrust</a>(theAxis,valX,valY,valZ,nTracks);
      a = ( <a href="#TThrustVector:calc_thrust">calc_thrust</a>(Axis2,valX,valY,valZ,nTracks) - 2 * c +
            <a href="#TThrustVector:calc_thrust">calc_thrust</a>(Axis3,valX,valY,valZ,nTracks) ) / 2;
      b = <a href="#TThrustVector:calc_thrust">calc_thrust</a>(Axis2,valX,valY,valZ,nTracks) - a - c;

<b>      // calculate max</b>
      maxChange1 = 10 * ( b&lt;0 ? -1 : 1 ); // linear 
      if (a!=0)
        maxChange1 = -b/(2*a);

<b>      // clean up</b>
      delete [] theAxis; delete [] Axis2; delete [] Axis3;
    } // end special case

<b>    // loop until change is at least good enough as started with</b>
    do {
      Axis2 = <a href="#TThrustVector:get_axis">get_axis</a>(bestTheta+maxChange1*epsilon,bestPhi);
      theThrust = <a href="#TThrustVector:calc_thrust">calc_thrust</a>(Axis2,valX,valY,valZ,nTracks);
      if (theThrust&lt;c)
        maxChange1 /= 2; // don't trust large jumps so be willing to reduce

<b>      // clean up</b>
      delete [] Axis2;
    } while (theThrust&lt;c); // do until at least equal 

<b>    // put bestTheta in correct units and check for consistency</b>
    bestTheta += maxChange1 * epsilon;
    if (bestTheta&gt;TMath::Pi()) {
      bestTheta = TMath::Pi() - (bestTheta-TMath::Pi());
      bestPhi += TMath::Pi();
      if (bestPhi&gt;2*TMath::Pi())
        bestPhi -= 2 * TMath::Pi();
    } // end if &gt;pi
    if (bestTheta&lt;0) {
      bestTheta *= -1; // change sign
      bestPhi += TMath::Pi();
      if (bestPhi&gt;2*TMath::Pi())
        bestPhi -= 2 * TMath::Pi();
    } // end if &lt;0

<b>    // do again for phi</b>
    theAxis = <a href="#TThrustVector:get_axis">get_axis</a>(bestTheta,bestPhi);
    Axis2 = <a href="#TThrustVector:get_axis">get_axis</a>(bestTheta,bestPhi+epsilon); // do differential
    Axis3 = <a href="#TThrustVector:get_axis">get_axis</a>(bestTheta,bestPhi-epsilon); // do differential

<b>    // use parabolic approx as above</b>
    c = <a href="#TThrustVector:calc_thrust">calc_thrust</a>(theAxis,valX,valY,valZ,nTracks);
    a = ( <a href="#TThrustVector:calc_thrust">calc_thrust</a>(Axis2,valX,valY,valZ,nTracks) - 2 * c +
          <a href="#TThrustVector:calc_thrust">calc_thrust</a>(Axis3,valX,valY,valZ,nTracks) ) / 2;
    b = <a href="#TThrustVector:calc_thrust">calc_thrust</a>(Axis2,valX,valY,valZ,nTracks) - a - c;

<b>    // get maximum</b>
    maxChange2 = 10 * ( b&lt;0 ? -1 : 1 ); // linear 
    if (a!=0)
      maxChange2 = -b/(2*a);

<b>    // clean up</b>
    delete [] theAxis; delete [] Axis2; delete [] Axis3;

<b>    // require small change</b>
    while (fabs(maxChange2*epsilon)&gt;TMath::Pi()/4) { maxChange2 /= 2; }

<b>    // loop until change is at least as good as started with</b>
    do {
      Axis2 = <a href="#TThrustVector:get_axis">get_axis</a>(bestTheta,bestPhi+maxChange2*epsilon);
      theThrust = <a href="#TThrustVector:calc_thrust">calc_thrust</a>(Axis2,valX,valY,valZ,nTracks);
      if (theThrust&lt;c)
        maxChange2 /= 2; // don't trust large jumps so be willing to reduce

<b>      // clean up</b>
      delete [] Axis2;
    } while (theThrust&lt;c); // do until at least equal

<b>    // put bestPhi in correct units and check for consistency</b>
    bestPhi += maxChange2 * epsilon;
    if (bestPhi&gt;2*TMath::Pi())
      bestPhi -= 2 * TMath::Pi();
    if (bestPhi&lt;0)
      bestPhi += 2 * TMath::Pi();

<b>    // update mandatory count</b>
    if (mand_ct&gt;0)
      mand_ct--;
    max_ct--;
    done = (maxChange1*maxChange1&gt;1||maxChange2*maxChange2&gt;1||mand_ct)
           &amp;&amp;(max_ct&gt;0);
  } while (done);
<b>  // continue until both are less than one epsilon</b>

<b>  // set return values</b>
  <a href="../ListOfTypes.html#double">double</a> * result = new <a href="../ListOfTypes.html#double">double</a>[2];
  result[0] = bestTheta;
  result[1] = bestPhi;
  return result;
} // end of get_final_axis

<b>// get x,y,z from theta phi</b>
<a name="TThrustVector:get_axis"> </a><a href="../ListOfTypes.html#double">double</a> * <a href=".././TThrustVector.html#TThrustVector:get_axis">TThrustVector::get_axis</a>(<a href="../ListOfTypes.html#double">double</a> theta, <a href="../ListOfTypes.html#double">double</a> phi) const {

  <a href="../ListOfTypes.html#double">double</a> * result = new <a href="../ListOfTypes.html#double">double</a>[3];
  result[2] = cos(theta); // z
  <a href="../ListOfTypes.html#double">double</a> theSin = sin(theta); // sin calculation is slow
  result[0] = theSin * cos(phi); // x
  result[1] = theSin * sin(phi); // y

  return result;
}  // end of get_axis

<b>// calculate the thrust for a given axis and set of three vectors</b>
<a name="TThrustVector:calc_thrust"> </a><a href="../ListOfTypes.html#double">double</a> <a href=".././TThrustVector.html#TThrustVector:calc_thrust">TThrustVector::calc_thrust</a>(const <a href="../ListOfTypes.html#double">double</a> * axis, 
				    const <a href="../ListOfTypes.html#double">double</a> * valX, 
				    const <a href="../ListOfTypes.html#double">double</a> * valY,
				    const <a href="../ListOfTypes.html#double">double</a> * valZ,
				    const unsigned nTracks) const {

  <a href="../ListOfTypes.html#double">double</a> result = 0;
  <a href="../ListOfTypes.html#double">double</a> num_sum = 0;

  for (<a href="../ListOfTypes.html#int">int</a> i=0;i&lt;nTracks;i++)
<b>    // calculate sum of dot products</b>
    num_sum += fabs( axis[0]*valX[i] + axis[1]*valY[i] + axis[2]*valZ[i] );

<b>  // set return value</b>
  if (<a href=".././TThrustVector.html#TThrustVector:_denom_sum">_denom_sum</a>&gt;0) 
    result = num_sum/<a href=".././TThrustVector.html#TThrustVector:_denom_sum">_denom_sum</a>;
  return result;
}

<a name="TThrustVector:calc_denom"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TThrustVector.html#TThrustVector:calc_denom">TThrustVector::calc_denom</a>(const <a href="../ListOfTypes.html#double">double</a> * valX, const <a href="../ListOfTypes.html#double">double</a> * valY,
				 const <a href="../ListOfTypes.html#double">double</a> * valZ, 
				 const unsigned nTracks) {

    for (<a href="../ListOfTypes.html#int">int</a> i=0;i&lt;nTracks;i++) // loop over all tracks
<b>      // calculate denominator </b>
      <a href=".././TThrustVector.html#TThrustVector:_denom_sum">_denom_sum</a> += sqrt( valX[i]*valX[i] + valY[i]*valY[i] + 
			  valZ[i]*valZ[i] );
}
</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
