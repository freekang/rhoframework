<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:02:23 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>PepBeamsR - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//////////////////////////////////////////////////////////////////////////</b>
<b>//                                                                      //</b>
<b>// <a href=".././TBeams.html">TBeams</a>	    							//</b>
<b>// <a href=".././TBeamSpotCal.html">TBeamSpotCal</a>	    							//</b>
<b>// <a href=".././TEnergies.html">TEnergies</a>	    							//</b>
<b>// <a href=".././TFillPattern.html">TFillPattern</a>	    							//</b>
<b>// <a href=".././TBoostCal.html">TBoostCal</a>								//</b>
<b>//                                                                      //</b>
<b>// Beam calibration classes						//</b>
<b>//                                                                      //</b>
<b>// Author: Marcel Kunze, RUB, Nov. 99					//</b>
<b>// Copyright (C) 1999-2001, Ruhr-University Bochum.			//</b>
<b>//                                                                      //</b>
<b>//////////////////////////////////////////////////////////////////////////</b>

#include "TLorentzVector.h"
#include "TLorentzRotation.h"

#include "RhoConditions/TBeams.h"


ClassImp(PepBeamsR)

#include &lt;iostream&gt;
using namespace std;

<a name="PepBeamsR:PepBeamsR"> </a>PepBeamsR::PepBeamsR() { }
<a name="PepBeamsR:~PepBeamsR"> </a>PepBeamsR::~PepBeamsR() { }

<a name="PepBeamsR:PrintOn"> </a>void PepBeamsR::PrintOn(std::ostream&amp; o) const {
    
<b>    // The interaction point:</b>
    o &lt;&lt; endl &lt;&lt; "Interaction point: " ;
    o &lt;&lt; <a href=".././PepBeamsR.html#PepBeamsR:_interactionPoint">_interactionPoint</a>[0] &lt;&lt; 't' &lt;&lt;
 	 <a href=".././PepBeamsR.html#PepBeamsR:_interactionPoint">_interactionPoint</a>[1] &lt;&lt; 't' &lt;&lt;
 	 <a href=".././PepBeamsR.html#PepBeamsR:_interactionPoint">_interactionPoint</a>[2] &lt;&lt; 't' &lt;&lt;
	 <a href=".././PepBeamsR.html#PepBeamsR:_interactionPoint">_interactionPoint</a>[3] &lt;&lt; endl;
/*    
    o &lt;&lt; endl &lt;&lt; "Error matrix interaction point:";
    for (<a href="../ListOfTypes.html#int">int</a> i = 0; i &lt; 4; ++i){
	o &lt;&lt; endl;
	for (<a href="../ListOfTypes.html#int">int</a> j = 0; j &lt; 4; ++j){
	    <a href="../ListOfTypes.html#int">int</a> ij = i * 4 + j;
	    o &lt;&lt; <a href=".././PepBeamsR.html#PepBeamsR:_interactionPointErr">_interactionPointErr</a>[ij] &lt;&lt; 't';
	}
    }
*/
    o &lt;&lt; endl;
    
<b>    // The e+ momentum:</b>
    
    o &lt;&lt; "Positron beam: " ;
    o &lt;&lt; <a href=".././PepBeamsR.html#PepBeamsR:_ePlusMomentum">_ePlusMomentum</a>[0] &lt;&lt; 't' &lt;&lt;
 	 <a href=".././PepBeamsR.html#PepBeamsR:_ePlusMomentum">_ePlusMomentum</a>[1] &lt;&lt; 't' &lt;&lt;
	 <a href=".././PepBeamsR.html#PepBeamsR:_ePlusMomentum">_ePlusMomentum</a>[2] &lt;&lt; endl;
    o &lt;&lt; "Error: " ;
    o &lt;&lt; <a href=".././PepBeamsR.html#PepBeamsR:_ePlusMomentumErr">_ePlusMomentumErr</a>[0] &lt;&lt; 't' &lt;&lt;
	 <a href=".././PepBeamsR.html#PepBeamsR:_ePlusMomentumErr">_ePlusMomentumErr</a>[4] &lt;&lt; 't' &lt;&lt;
	 <a href=".././PepBeamsR.html#PepBeamsR:_ePlusMomentumErr">_ePlusMomentumErr</a>[8] &lt;&lt; endl;
    
<b>    // The e- momentum:</b>
    
    o &lt;&lt; "Electron beam: " ;
    o &lt;&lt; <a href=".././PepBeamsR.html#PepBeamsR:_eMinusMomentum">_eMinusMomentum</a>[0] &lt;&lt; 't' &lt;&lt;
	 <a href=".././PepBeamsR.html#PepBeamsR:_eMinusMomentum">_eMinusMomentum</a>[1] &lt;&lt; 't' &lt;&lt;
	 <a href=".././PepBeamsR.html#PepBeamsR:_eMinusMomentum">_eMinusMomentum</a>[2] &lt;&lt; endl;
    o &lt;&lt; "Error: " ;
    o &lt;&lt; <a href=".././PepBeamsR.html#PepBeamsR:_eMinusMomentumErr">_eMinusMomentumErr</a>[0] &lt;&lt; 't' &lt;&lt;
	 <a href=".././PepBeamsR.html#PepBeamsR:_eMinusMomentumErr">_eMinusMomentumErr</a>[4] &lt;&lt; 't' &lt;&lt;
	 <a href=".././PepBeamsR.html#PepBeamsR:_eMinusMomentumErr">_eMinusMomentumErr</a>[8] &lt;&lt; endl;
        
<b>    //o &lt;&lt; endl &lt;&lt; endl &lt;&lt; "Number of bunches (empty): ";</b>
<b>    //o &lt;&lt; <a href=".././PepBeamsR.html#PepBeamsR:_numBunches">_numBunches</a> &lt;&lt; " (" &lt;&lt; <a href=".././PepBeamsR.html#PepBeamsR:_numEmptyBunches">_numEmptyBunches</a> &lt;&lt; ")" &lt;&lt; endl;</b>
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././PepBeamsR.html">PepBeamsR</a>&amp; a) { a.<a href="#PepBeamsR:PrintOn">PrintOn</a>(o); return o; }


<b>// Class <a href=".././TBeams.html">TBeams</a></b>

ClassImp(<a href=".././TBeams.html">TBeams</a>)

<a href=".././TBeams.html#TBeams:TBeams">TBeams::TBeams</a>(<a href=".././PepEnergiesR.html">PepEnergiesR</a> &amp;energies,<a href=".././PepBeamSpotCalR.html">PepBeamSpotCalR</a> &amp;cal)
{
    Update(energies,cal);
}

<a href="../ListOfTypes.html#void">void</a> <a href=".././TBeams.html#TBeams:Update">TBeams::Update</a>(<a href=".././PepEnergiesR.html">PepEnergiesR</a> &amp;energies,<a href=".././PepBeamSpotCalR.html">PepBeamSpotCalR</a> &amp;cal) 
{
  <a href="../ListOfTypes.html#Double_t">Double_t</a> ePlusEnergy = energies.LerEnergy();
  <a href="../ListOfTypes.html#Double_t">Double_t</a> eMinusEnergy = energies.HerEnergy();
  SetDefaultMomenta(ePlusEnergy,eMinusEnergy);

  static <a href="../ListOfTypes.html#Double_t">Double_t</a> oldIP = 0;

  TVector3 ip = cal.BeamSpot();
  if (ip.Mag() == oldIP) return; // Nothing to do
  oldIP = ip.Mag();

  <a href=".././PepBeamsR.html#PepBeamsR:_interactionPoint">_interactionPoint</a>[0] = ip.X();
  <a href=".././PepBeamsR.html#PepBeamsR:_interactionPoint">_interactionPoint</a>[1] = ip.Y();
  <a href=".././PepBeamsR.html#PepBeamsR:_interactionPoint">_interactionPoint</a>[2] = ip.Z();
  <a href=".././PepBeamsR.html#PepBeamsR:_interactionPoint">_interactionPoint</a>[3] = 2.0 * sqrt(ePlusEnergy * eMinusEnergy);
  <a href=".././PepBeamsR.html#PepBeamsR:_interactionPointErr">_interactionPointErr</a>[0]  = cal.OrientationXX();
  <a href=".././PepBeamsR.html#PepBeamsR:_interactionPointErr">_interactionPointErr</a>[1]  = cal.OrientationXY();
  <a href=".././PepBeamsR.html#PepBeamsR:_interactionPointErr">_interactionPointErr</a>[2]  = cal.OrientationXZ();
  <a href=".././PepBeamsR.html#PepBeamsR:_interactionPointErr">_interactionPointErr</a>[4]  = cal.OrientationXY();
  <a href=".././PepBeamsR.html#PepBeamsR:_interactionPointErr">_interactionPointErr</a>[5]  = cal.OrientationYY();
  <a href=".././PepBeamsR.html#PepBeamsR:_interactionPointErr">_interactionPointErr</a>[6]  = cal.OrientationYZ();
  <a href=".././PepBeamsR.html#PepBeamsR:_interactionPointErr">_interactionPointErr</a>[8]  = cal.OrientationXZ();
  <a href=".././PepBeamsR.html#PepBeamsR:_interactionPointErr">_interactionPointErr</a>[9]  = cal.OrientationYZ();
  <a href=".././PepBeamsR.html#PepBeamsR:_interactionPointErr">_interactionPointErr</a>[10] = cal.OrientationZZ();
}

TLorentzVector 
<a href=".././TBeams.html#TBeams:InteractionPoint">TBeams::InteractionPoint</a>() {
    return TLorentzVector(<a href=".././PepBeamsR.html#PepBeamsR:_interactionPoint">_interactionPoint</a>[0],<a href=".././PepBeamsR.html#PepBeamsR:_interactionPoint">_interactionPoint</a>[1],<a href=".././PepBeamsR.html#PepBeamsR:_interactionPoint">_interactionPoint</a>[2],<a href=".././PepBeamsR.html#PepBeamsR:_interactionPoint">_interactionPoint</a>[3]);
}

TVector3 
<a href=".././TBeams.html#TBeams:Interaction3Point">TBeams::Interaction3Point</a>() {
    return TVector3(<a href=".././PepBeamsR.html#PepBeamsR:_interactionPoint">_interactionPoint</a>[0],<a href=".././PepBeamsR.html#PepBeamsR:_interactionPoint">_interactionPoint</a>[1],<a href=".././PepBeamsR.html#PepBeamsR:_interactionPoint">_interactionPoint</a>[2]);
}

TVector3
<a href=".././TBeams.html#TBeams:EPlusMomentum">TBeams::EPlusMomentum</a>() {
    return TVector3(<a href=".././PepBeamsR.html#PepBeamsR:_ePlusMomentum">_ePlusMomentum</a>[0],<a href=".././PepBeamsR.html#PepBeamsR:_ePlusMomentum">_ePlusMomentum</a>[1],<a href=".././PepBeamsR.html#PepBeamsR:_ePlusMomentum">_ePlusMomentum</a>[2]); 
}    

TVector3
<a href=".././TBeams.html#TBeams:EMinusMomentum">TBeams::EMinusMomentum</a>() {
    return TVector3(<a href=".././PepBeamsR.html#PepBeamsR:_eMinusMomentum">_eMinusMomentum</a>[0],<a href=".././PepBeamsR.html#PepBeamsR:_eMinusMomentum">_eMinusMomentum</a>[1],<a href=".././PepBeamsR.html#PepBeamsR:_eMinusMomentum">_eMinusMomentum</a>[2]);
}    

<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href=".././TBeams.html#TBeams:EPlusEnergy">TBeams::EPlusEnergy</a>() { return ElectronEnergy(EPlusMomentum()); }
<a href="../ListOfTypes.html#Double_t">Double_t</a> <a href=".././TBeams.html#TBeams:EMinusEnergy">TBeams::EMinusEnergy</a>() { return ElectronEnergy(EMinusMomentum()); }

<b>//----------------------------------------------------------------------</b>
<b>// Given a momentum, return the energy of an electron with that momentum:</b>

<a href="../ListOfTypes.html#Double_t">Double_t</a> 
<a href=".././TBeams.html#TBeams:ElectronEnergy">TBeams::ElectronEnergy</a>(TVector3 momentum) {
    static <a href="../ListOfTypes.html#Double_t">Double_t</a> electronMass =  0.000510999;
    static const <a href="../ListOfTypes.html#Double_t">Double_t</a> electronMassSquared = electronMass * electronMass;
    return sqrt(electronMassSquared + momentum.Mag2());
}


<b>//-----------------------------------------------------------------</b>
TLorentzVector 
<a href=".././TBeams.html#TBeams:EMinus4Momentum">TBeams::EMinus4Momentum</a>() {
    return TLorentzVector(EMinusMomentum(), EMinusEnergy());
}


<b>//-----------------------------------------------------------------</b>
TLorentzVector 
<a href=".././TBeams.html#TBeams:EPlus4Momentum">TBeams::EPlus4Momentum</a>() {
    return TLorentzVector(EPlusMomentum(), EPlusEnergy());
}

<b>//-----------------------------------------------------------------</b>
TLorentzVector
<a href=".././TBeams.html#TBeams:Total4Momentum">TBeams::Total4Momentum</a>() {
    return EPlus4Momentum() + EMinus4Momentum();
}

<b>//-----------------------------------------------------------------</b>
TLorentzVector
<a href=".././TBeams.html#TBeams:Total4MomentumCM">TBeams::Total4MomentumCM</a>() {
    TLorentzVector result = Total4Momentum();
    TLorentzRotation boost(-result.BoostVector());
    result.Transform(boost);
    return result;
}

<b>//--------------------------------------------------------------------------</b>
TVector3 
<a href=".././TBeams.html#TBeams:TotalMomentum">TBeams::TotalMomentum</a>() {
    return (const TVector3 &amp;)EMinusMomentum() + 
	(const TVector3 &amp;)EPlusMomentum();
}

<b>//-----------------------------------------------------------------</b>
<a href="../ListOfTypes.html#Double_t">Double_t</a> 
<a href=".././TBeams.html#TBeams:CrossingAngle">TBeams::CrossingAngle</a>() {
    return EPlusMomentum().Angle(EMinusMomentum());
}

<b>//-----------------------------------------------------------------</b>
TVector3
<a href=".././TBeams.html#TBeams:BoostCMtoLab">TBeams::BoostCMtoLab</a>() {  
    return Total4Momentum().BoostVector();
}


<b>//-----------------------------------------------------------------</b>
<a href="../ListOfTypes.html#Double_t">Double_t</a>
<a href=".././TBeams.html#TBeams:EnergyCM">TBeams::EnergyCM</a>() {
    return Total4MomentumCM().T();
}


<b>//-------------------------------------------------------------------</b>
<a href="../ListOfTypes.html#void">void</a>
<a href=".././TBeams.html#TBeams:SetDefaultMomenta">TBeams::SetDefaultMomenta</a>(<a href="../ListOfTypes.html#Double_t">Double_t</a> ePlusEnergy, <a href="../ListOfTypes.html#Double_t">Double_t</a> eMinusEnergy) {

<b>  // Check cache</b>
  static <a href="../ListOfTypes.html#Double_t">Double_t</a> oldPlus = 0, oldMinus = 0;
  if (oldPlus==ePlusEnergy &amp;&amp; oldMinus==eMinusEnergy) return;

  oldPlus  = ePlusEnergy;
  oldMinus = eMinusEnergy;

<b>  // The rotation in the xz plane:</b>
  const TVector3 yAxis(0.0, 1.0, 0.0);
  TRotation beamRotation;
  beamRotation.Rotate(-0.0188, yAxis);

<b>  // Rotate the momenta:</b>
  TVector3 ePlus(0,0,-ePlusEnergy);
  ePlus.Transform(beamRotation);

  TVector3 eMinus(0,0,eMinusEnergy);
  eMinus.Transform(beamRotation);

<b>  // Set the momenta:</b>
  <a href=".././PepBeamsR.html#PepBeamsR:_ePlusMomentum">_ePlusMomentum</a>[0] = ePlus.X();
  <a href=".././PepBeamsR.html#PepBeamsR:_ePlusMomentum">_ePlusMomentum</a>[1] = ePlus.Y();
  <a href=".././PepBeamsR.html#PepBeamsR:_ePlusMomentum">_ePlusMomentum</a>[2] = ePlus.Z();
  <a href=".././PepBeamsR.html#PepBeamsR:_ePlusMomentumErr">_ePlusMomentumErr</a>[0] = pow(0.0013, 2);
  <a href=".././PepBeamsR.html#PepBeamsR:_ePlusMomentumErr">_ePlusMomentumErr</a>[4] = pow(0.0013, 2);
  <a href=".././PepBeamsR.html#PepBeamsR:_ePlusMomentumErr">_ePlusMomentumErr</a>[8] = pow(0.0024, 2);

  <a href=".././PepBeamsR.html#PepBeamsR:_eMinusMomentum">_eMinusMomentum</a>[0] = eMinus.X();
  <a href=".././PepBeamsR.html#PepBeamsR:_eMinusMomentum">_eMinusMomentum</a>[1] = eMinus.Y();
  <a href=".././PepBeamsR.html#PepBeamsR:_eMinusMomentum">_eMinusMomentum</a>[2] = eMinus.Z();
  <a href=".././PepBeamsR.html#PepBeamsR:_eMinusMomentumErr">_eMinusMomentumErr</a>[0] = pow(0.0028, 2);
  <a href=".././PepBeamsR.html#PepBeamsR:_eMinusMomentumErr">_eMinusMomentumErr</a>[4] = pow(0.0028, 2);
  <a href=".././PepBeamsR.html#PepBeamsR:_eMinusMomentumErr">_eMinusMomentumErr</a>[8] = pow(0.0055, 2);

}

<a href=".././TVectorErr.html">TVectorErr</a>   <a href=".././TBeams.html#TBeams:EPlusMomentumWErr">TBeams::EPlusMomentumWErr</a>()
{
  <a href=".././TError.html">TError</a> pErr(3);
  <a href="../ListOfTypes.html#int">int</a> i, j;
  for (i = 0; i &lt; 3; ++i){
    for (j = 0; j &lt; 3; ++j){
      pErr(i,j) = EPlusMomentumErr(i,j);
    }
  }
  return <a href=".././TVectorErr.html">TVectorErr</a>(EPlusMomentum(),pErr);
}

<a href=".././TVectorErr.html">TVectorErr</a>   <a href=".././TBeams.html#TBeams:EMinusMomentumWErr">TBeams::EMinusMomentumWErr</a>()
{
  <a href=".././TError.html">TError</a> pErr(3);
  <a href="../ListOfTypes.html#int">int</a> i, j;
  for (i = 0; i &lt; 3; ++i){
    for (j = 0; j &lt; 3; ++j){
      pErr(i,j) = EMinusMomentumErr(i,j);
    }
  }
  return <a href=".././TVectorErr.html">TVectorErr</a>(EMinusMomentum(),pErr);
}

<a href=".././TVectorErr.html">TVectorErr</a>   <a href=".././TBeams.html#TBeams:TotalMomentumWErr">TBeams::TotalMomentumWErr</a>()
{
  return EMinusMomentumWErr() + EPlusMomentumWErr();
}

<a href=".././TLorentzVectorErr.html">TLorentzVectorErr</a> <a href=".././TBeams.html#TBeams:Total4MomentumWErr">TBeams::Total4MomentumWErr</a>()
{
  return EPlus4MomentumWErr() + EMinus4MomentumWErr();
}

<a href=".././TLorentzVectorErr.html">TLorentzVectorErr</a> <a href=".././TBeams.html#TBeams:Total4MomentumCMWErr">TBeams::Total4MomentumCMWErr</a>() 
{
  <a href=".././TLorentzVectorErr.html">TLorentzVectorErr</a> result = Total4MomentumWErr();
  TLorentzRotation boost(-result.BoostVector());
  result.Transform(boost);
  return result;
}

<a href=".././TDoubleErr.html">TDoubleErr</a>        <a href=".././TBeams.html#TBeams:EPlusEnergyWErr">TBeams::EPlusEnergyWErr</a>()
{
  <a href=".././TDoubleErr.html">TDoubleErr</a> result;
  const <a href="../ListOfTypes.html#double">double</a> value = ElectronEnergy(<a href=".././PepBeamsR.html#PepBeamsR:_ePlusMomentum">_ePlusMomentum</a>);
  result.SetValue(value);

  if (value != 0){
    <a href="../ListOfTypes.html#double">double</a> cov = 0.0;
    <a href=".././TError.html">TError</a> momErr = EPlusMomentumWErr().CovMatrix();
    for (<a href="../ListOfTypes.html#int">int</a> i = 0; i &lt; 3; ++i){
      for (<a href="../ListOfTypes.html#int">int</a> j = 0; j &lt; 3; ++j){
	cov += EPlusMomentum()[i] * EPlusMomentum()[j] * momErr(i, j);
      }
    }
    cov /= (value * value);
    result.SetCovariance(cov);
  }
  return result;
}

<a href=".././TDoubleErr.html">TDoubleErr</a>        <a href=".././TBeams.html#TBeams:EMinusEnergyWErr">TBeams::EMinusEnergyWErr</a>()
{
  <a href=".././TDoubleErr.html">TDoubleErr</a> result;
  const <a href="../ListOfTypes.html#double">double</a> value = ElectronEnergy(<a href=".././PepBeamsR.html#PepBeamsR:_eMinusMomentum">_eMinusMomentum</a>);
  result.SetValue(value);

  if (value != 0){
    <a href="../ListOfTypes.html#double">double</a> cov = 0.0;
    <a href=".././TError.html">TError</a> momErr = EMinusMomentumWErr().CovMatrix();
    for (<a href="../ListOfTypes.html#int">int</a> i = 0; i &lt; 3; ++i){
      for (<a href="../ListOfTypes.html#int">int</a> j = 0; j &lt; 3; ++j){
	cov += EMinusMomentum()[i] * EMinusMomentum()[j] * momErr(i, j);
      }
    }
    cov /= (value * value);
    result.SetCovariance(cov);
  }
  return result;
}

<a href=".././TLorentzVectorErr.html">TLorentzVectorErr</a> <a href=".././TBeams.html#TBeams:EPlus4MomentumWErr">TBeams::EPlus4MomentumWErr</a>()
{
<b>  // The 3-vector part of the error, initialized as a 0-matrix, then copied </b>
<b>  // from p3:</b>
  <a href=".././TError.html">TError</a> p4Err(4);
  <a href="../ListOfTypes.html#int">int</a> i, j;
  for (i = 0; i &lt; 3; ++i){
    for (j = 0; j &lt; 3; ++j){
      p4Err(i,j) = EPlusMomentumErr(i,j);
    }
  }
  
<b>  // The energy part of the error:</b>
  p4Err(3,3) = EPlusEnergyWErr().Covariance();
  
<b>  // The E-p correlated part of the error is</b>
<b>  // &lt;(E - &lt;E&gt;) (Pi - &lt;Pi&gt;)&gt; = dE/dPj Vjk dPi/dPk</b>
<b>  // Since dPi/dPk = delta_ik, we get dE/dPj Vji.</b>
  const <a href="../ListOfTypes.html#double">double</a> ePlusE = EPlusEnergy();
  for (i = 0; i &lt; 3; ++i){
    for (j = 0; j &lt; 3; ++j){
      p4Err(i,3) += EPlusMomentum()[j] / ePlusE * 
	EPlusMomentumErr(j,i);
    }
  }

  return <a href=".././TLorentzVectorErr.html">TLorentzVectorErr</a>(EPlus4Momentum(), p4Err);
}


<a href=".././TLorentzVectorErr.html">TLorentzVectorErr</a> <a href=".././TBeams.html#TBeams:EMinus4MomentumWErr">TBeams::EMinus4MomentumWErr</a>() 
{
<b>  // The 3-vector part of the error, initialized as a 0-matrix, then copied </b>
<b>  // from p3:</b>
  <a href=".././TError.html">TError</a> p4Err(4);
  <a href="../ListOfTypes.html#int">int</a> i, j;
  for (i = 0; i &lt; 3; ++i){
    for (j = 0; j &lt; 3; ++j){
      p4Err(i,j) = EMinusMomentumErr(i,j);
    }
  }
  
<b>  // The energy part of the error:</b>
  p4Err(3,3) = EMinusEnergyWErr().Covariance();
  
<b>  // The E-p correlated part of the error is</b>
<b>  // &lt;(E - &lt;E&gt;) (Pi - &lt;Pi&gt;)&gt; = dE/dPj Vjk dPi/dPk</b>
<b>  // Since dPi/dPk = delta_ik, we get dE/dPj Vji.</b>
  const <a href="../ListOfTypes.html#double">double</a> eMinusE = EMinusEnergy();
  for (i = 0; i &lt; 3; ++i){
    for (j = 0; j &lt; 3; ++j){
      p4Err(i,3) += EMinusMomentum()[j] / eMinusE * 
	EMinusMomentumErr(j,i);
    }
  }

  return <a href=".././TLorentzVectorErr.html">TLorentzVectorErr</a>(EMinus4Momentum(), p4Err);
}

<a href=".././TDoubleErr.html">TDoubleErr</a>        <a href=".././TBeams.html#TBeams:EnergyCMWErr">TBeams::EnergyCMWErr</a>()
{
  <a href=".././TLorentzVectorErr.html">TLorentzVectorErr</a> p4CM = Total4MomentumCMWErr();
  <a href="../ListOfTypes.html#double">double</a> value = p4CM.T();
  <a href="../ListOfTypes.html#double">double</a> err = p4CM.CovMatrix()(3,3);

  return <a href=".././TDoubleErr.html">TDoubleErr</a>(value, err);
} 

<a href=".././TVectorErr.html">TVectorErr</a>        <a href=".././TBeams.html#TBeams:BoostCMtoLabWErr">TBeams::BoostCMtoLabWErr</a>()
{
  <a href=".././TLorentzVectorErr.html">TLorentzVectorErr</a> p4 = Total4MomentumWErr();

<b>  // The value part of the result:</b>
  TVector3 value = p4.BoostVector();  // = p/E

<b>  // The error part, given by (B is the boost vector, P is the 4-momentum,</b>
<b>  // i,j = 1,3, m,n = 1,4, Vmn is the 4-momentum error matrix):</b>
<b>  // &lt;(Bi - &lt;Bi&gt;) (Bj - &lt;Bj&gt;)&gt; = sum_{m,n} dBi/dPm Vmn dBj/dPn</b>
<b>  // where dBi/dPk = delta_{ik} / E</b>
<b>  //       dBi/dE = -Pi / E^2</b>
  const <a href="../ListOfTypes.html#double">double</a> Esq = p4.T() * p4.T();
  const <a href="../ListOfTypes.html#double">double</a> Ecu = Esq * p4.T();

  <a href=".././TError.html">TError</a> err(3);
  <a href="../ListOfTypes.html#int">int</a> i, j;
  for (i = 0; i &lt; 3; ++i){
    for (j = i; j &lt; 3; ++j){    // start from i since (i,j) = (j,i)
      err(i,j) =                // m=n=0:
	(p4(i) / Esq) * (p4(j) / Esq) * p4.CovMatrix()(3,3)
<b>	                        // m=0, n=k leads to delta_{jk}:</b>
	- (p4(i) / Ecu) * p4.CovMatrix()(3,j)
<b>	                        // m=k, n=0 leads to delta_{ik}:</b>
	- (p4(j) / Ecu) * p4.CovMatrix()(i,3)
<b>	                        // m=k, n=l, leads to delta_{ik} delta{jl}:</b>
	+ p4.CovMatrix()(i,j) / Esq;
    }
  }
  
  return <a href=".././TVectorErr.html">TVectorErr</a>(value, err);
} // from CM frame to lab  

<b>//-----------------------------------------------------------------</b>
ClassImp(<a href=".././PepBeamSpotCalR.html">PepBeamSpotCalR</a>)
ClassImp(<a href=".././TBeamSpotCal.html">TBeamSpotCal</a>)

<b>//static const <a href="../ListOfTypes.html#char">char</a> rcsid[] =</b>
<b>//"$Id: PepBeamsR.cxx.html,v 1.1.1.1 2002-12-20 15:05:30 marcel Exp $";</b>

<a href=".././PepBeamSpotCalR.html#PepBeamSpotCalR:PepBeamSpotCalR">PepBeamSpotCalR::PepBeamSpotCalR</a>() {
}

<a href=".././PepBeamSpotCalR.html">PepBeamSpotCalR</a>::~<a href=".././PepBeamSpotCalR.html">PepBeamSpotCalR</a>() { }

<a href="../ListOfTypes.html#void">void</a>
<a href=".././PepBeamSpotCalR.html#PepBeamSpotCalR:PrintOn">PepBeamSpotCalR::PrintOn</a>(std::ostream &amp; o) const {
	o &lt;&lt; "beamSpot " &lt;&lt; _x &lt;&lt; " " &lt;&lt; _y &lt;&lt; " " &lt;&lt; _z &lt;&lt; endl;
	o &lt;&lt; "background " &lt;&lt; Background() &lt;&lt; " numTracks " &lt;&lt; NumTracks() &lt;&lt; endl;
<b>	//o &lt;&lt; "errorMatrix " &lt;&lt; errorMatrix() &lt;&lt; endl;</b>
}

const <a href="../ListOfTypes.html#Double_t">Double_t</a>&amp; <a href=".././PepBeamSpotCalR.html#PepBeamSpotCalR:ErrorMatrix">PepBeamSpotCalR::ErrorMatrix</a>(<a href="../ListOfTypes.html#int">int</a> row, <a href="../ListOfTypes.html#int">int</a> col) const {
    if (row &lt; col){
	<a href="../ListOfTypes.html#int">int</a> temp = row; row = col; col = temp;
    }
    <a href="../ListOfTypes.html#int">int</a> index = row * (row - 1) / 2 + col - 1;
    return _errorMatrix[index];
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././PepBeamSpotCalR.html">PepBeamSpotCalR</a>&amp; a) { a.<a href="#PepBeamsR:PrintOn">PrintOn</a>(o); return o; }

<b>//-----------------------------------------------------------------</b>
ClassImp(<a href=".././PepEnergiesR.html">PepEnergiesR</a>)
ClassImp(<a href=".././TEnergies.html">TEnergies</a>)

<b>//static const <a href="../ListOfTypes.html#char">char</a> rcsid[] =</b>
<b>//"$Id: PepBeamsR.cxx.html,v 1.1.1.1 2002-12-20 15:05:30 marcel Exp $";</b>

<a href=".././PepEnergiesR.html#PepEnergiesR:PepEnergiesR">PepEnergiesR::PepEnergiesR</a>() {
}

<a href=".././PepEnergiesR.html">PepEnergiesR</a>::~<a href=".././PepEnergiesR.html">PepEnergiesR</a>() { }

<a href="../ListOfTypes.html#void">void</a>
<a href=".././PepEnergiesR.html#PepEnergiesR:PrintOn">PepEnergiesR::PrintOn</a>(std::ostream &amp; stream) const {
    stream &lt;&lt; "lerEnergy " &lt;&lt; _lerEnergy &lt;&lt; " herEnergy " &lt;&lt; _herEnergy;
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././PepEnergiesR.html">PepEnergiesR</a>&amp; a) { a.<a href="#PepBeamsR:PrintOn">PrintOn</a>(o); return o; }

<b>//-----------------------------------------------------------------</b>

ClassImp(<a href=".././PepFillPatternR.html">PepFillPatternR</a>)
ClassImp(<a href=".././TFillPattern.html">TFillPattern</a>)

<b>//static const <a href="../ListOfTypes.html#char">char</a> rcsid[] =</b>
<b>//"$Id: PepBeamsR.cxx.html,v 1.1.1.1 2002-12-20 15:05:30 marcel Exp $";</b>

<a href=".././PepFillPatternR.html#PepFillPatternR:PepFillPatternR">PepFillPatternR::PepFillPatternR</a>() {
}

<a href=".././PepFillPatternR.html">PepFillPatternR</a>::~<a href=".././PepFillPatternR.html">PepFillPatternR</a>() { }

<a href="../ListOfTypes.html#void">void</a>
<a href=".././PepFillPatternR.html#PepFillPatternR:PrintOn">PepFillPatternR::PrintOn</a>(std::ostream &amp; stream) const {
    stream &lt;&lt; "herFirstBucket " &lt;&lt; HerFirstBucket()
	&lt;&lt; " herLastBucket " &lt;&lt; HerLastBucket()
	&lt;&lt; " herStepSize " &lt;&lt; HerStepSize() &lt;&lt; endl
	&lt;&lt; "lerFirstBucket " &lt;&lt; LerFirstBucket()
	&lt;&lt; " lerLastBucket " &lt;&lt; LerLastBucket()
	&lt;&lt; " lerStepSize " &lt;&lt; LerStepSize();
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././PepFillPatternR.html">PepFillPatternR</a>&amp; a) { a.<a href="#PepBeamsR:PrintOn">PrintOn</a>(o); return o; }

<b>//-----------------------------------------------------------------</b>

ClassImp(<a href=".././PepBoostCalR.html">PepBoostCalR</a>)
ClassImp(<a href=".././TBoostCal.html">TBoostCal</a>)

<a href=".././PepBoostCalR.html#PepBoostCalR:PepBoostCalR">PepBoostCalR::PepBoostCalR</a>() {
  _numEvents= 2000;
  _betaX= -0.0091;
  _betaY= 0.0;
  _betaZ= 0.48508;
  _errXX= 3.0e-08;
  _errXY= 9.8e-10;
  _errXZ= -2.8e-09;
  _errYY= 2.9e-08;
  _errYZ= 1.7e-09;
  _errZZ= 2.0e-07;
}

<b>// The boost from the CM to the lab and its error matrix:</b>
TVector3 <a href=".././PepBoostCalR.html#PepBoostCalR:Beta">PepBoostCalR::Beta</a>() const {return TVector3(_betaX,_betaY,_betaZ); }

<b>// # of events used in the caliubration:</b>
<a href="../ListOfTypes.html#int">int</a> <a href=".././PepBoostCalR.html#PepBoostCalR:NumEvents">PepBoostCalR::NumEvents</a>() const {return _numEvents;}

<a href=".././PepBoostCalR.html">PepBoostCalR</a>::~<a href=".././PepBoostCalR.html">PepBoostCalR</a>() { }

<a href="../ListOfTypes.html#void">void</a> <a href=".././PepBoostCalR.html#PepBoostCalR:PrintOn">PepBoostCalR::PrintOn</a>(std::ostream &amp;o) const {
  o &lt;&lt; " beta " &lt;&lt; Beta().X() &lt;&lt; 't' &lt;&lt; Beta().Y() &lt;&lt; 't' &lt;&lt; Beta().Z() &lt;&lt; endl;
  o &lt;&lt; " numEvents " &lt;&lt; NumEvents() &lt;&lt; endl;
}

std::ostream&amp;  operator &lt;&lt; (std::ostream&amp; o, const <a href=".././PepBoostCalR.html">PepBoostCalR</a>&amp; a) { a.<a href="#PepBeamsR:PrintOn">PrintOn</a>(o); return o; }

</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
