<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:03:21 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TPrintTree - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//==========================================================================</b>
<b>// File and Version Information:</b>
<b>// 	$Id: TPrintTree.cxx.html,v 1.1.1.1 2002-12-20 15:05:30 marcel Exp $</b>
<b>//</b>
<b>//--------------------------------------------------------------------------</b>
<b>// Description:</b>
<b>//	See <a href=".././TPrintTree.html">TPrintTree</a>.h</b>
<b>//</b>
<b>//--------------------------------------------------------------------------</b>
<b>// Sample User Code:</b>
<b>//</b>
<b>//--------------------------------------------------------------------------</b>
<b>// Environment:</b>
<b>//	Software developed for the BaBar Detector at the SLAC B-Factory.</b>
<b>//</b>
<b>//--------------------------------------------------------------------------</b>
<b>// Author List:</b>
<b>//	Abi Soffer              (Original author)</b>
<b>//  Marcel Kunze             Adaptation to T</b>
<b>//</b>
<b>//--------------------------------------------------------------------------</b>
<b>// Copyright Information:</b>
<b>//	Copyright (C) 1998	Colorado State University</b>
<b>//</b>
<b>// ROOT Version by Marcel Kunze, RUB</b>
<b>//==========================================================================</b>

#include "TList.h"
#include "TObjString.h"
#include "RhoTools/TPrintTree.h"
#include "RhoBase/TCandidate.h"
#include "RhoBase/VAbsTruth.h"
#include "RhoBase/VAbsVertex.h"
#include "RhoBase/TRho.h"
#include "RhoBase/TCandList.h"
#include "RhoBase/TCandListIterator.h"

ClassImp(TPrintTree)

TBuffer &amp;operator&gt;&gt;(TBuffer &amp;buf, TPrintTree *&amp;obj)
{
   obj = (TPrintTree *) buf.ReadObject(TPrintTree::Class());
   return buf;
}

#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;strstream&gt;
using namespace std;

<b>//-----------------------------------------------</b>
<b>//-- Static Data &amp; Function Member Definitions --</b>
<b>//-----------------------------------------------</b>
const <a href="../ListOfTypes.html#char">char</a>* 
<a name="TPrintTree:PrintName"> </a><a href=".././TPrintTree.html#TPrintTree:PrintName">TPrintTree::PrintName</a>(const TCandidate &amp; cand) {
    TString result;
    const TParticlePDG * pdtEntry = cand.PdtEntry();
    if (0 != pdtEntry){
	result += pdtEntry-&gt;GetName();
    }
    return result.Data();
}

<b>//------------------------------------------------------------------</b>
const <a href="../ListOfTypes.html#char">char</a>* 
<a name="TPrintTree:PrintP4"> </a><a href=".././TPrintTree.html#TPrintTree:PrintP4">TPrintTree::PrintP4</a>(const TCandidate &amp; cand) {
    ostrstream stream;
    TLorentzVector q = cand.P4();
<b>    // Reproduce the LorentzVector printout since the effect of setw(..) is lost</b>
<b>    // after each floating point output:</b>
    stream &lt;&lt; "(" 
	&lt;&lt;  q.X() &lt;&lt; "," 
	&lt;&lt;  q.Y() &lt;&lt; ","
	&lt;&lt;  q.Z() &lt;&lt; ";" 
	&lt;&lt;  q.T() &lt;&lt; ")" &lt;&lt; ends;
    
    TString result(stream.str());
    delete [] stream.str();           // must take ownership here
    return result.Data();
}

<b>//------------------------------------------------------------------</b>
const <a href="../ListOfTypes.html#char">char</a>* 
<a name="TPrintTree:PrintVertex"> </a><a href=".././TPrintTree.html#TPrintTree:PrintVertex">TPrintTree::PrintVertex</a>(const TCandidate &amp; cand) {
    TString result;
    const VAbsVertex * vertex = cand.DecayVtx();
    if (0 != vertex){
	TVector3 q = vertex-&gt;Point();
	ostrstream stream;
	stream &lt;&lt; "(" 
	    &lt;&lt; q.X() &lt;&lt; "," 
	    &lt;&lt; q.Y() &lt;&lt; "," 
	    &lt;&lt; q.Z() &lt;&lt; ")" &lt;&lt; ends;
	
	result += stream.str();
	delete [] stream.str();      // must take ownership here
    }
    return result.Data();
}

<b>//----------------------------------------</b>
<b>//-- Public Function Member Definitions --</b>
<b>//----------------------------------------</b>

<b>//----------------</b>
<b>// Constructors --</b>
<b>//----------------</b>
<b>//-----------------------------------------------------------</b>
<a name="TPrintTree:TPrintTree"> </a><a href=".././TPrintTree.html#TPrintTree:TPrintTree">TPrintTree::TPrintTree</a>() {
    <a href="#TPrintTree:Initialize">Initialize</a>();
    <a href=".././TPrintTree.html#TPrintTree:fTerm">fTerm</a> = 0;
}

<b>//--------------</b>
<b>// Destructor --</b>
<b>//--------------</b>
<a name="TPrintTree:~TPrintTree"> </a><a href=".././TPrintTree.html">TPrintTree</a>::~<a href=".././TPrintTree.html">TPrintTree</a>() {
    <a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.Delete();  
}


<b>//-------------</b>
<b>// Accessors --</b>
<b>//-------------</b>
<b>//-----------------------------------------------------------</b>
TStringLong
<a name="TPrintTree:Print"> </a><a href=".././TPrintTree.html#TPrintTree:Print">TPrintTree::Print</a>(const TCandidate &amp; cand) {
    <a href="#TPrintTree:MakeLines">MakeLines</a>(cand);
    return <a href="#TPrintTree:PrintAgain">PrintAgain</a>();
}

TStringLong
<a name="TPrintTree:Print"> </a><a href=".././TPrintTree.html#TPrintTree:Print">TPrintTree::Print</a>(const VAbsTruth &amp; cand) {
    <a href="#TPrintTree:MakeLines">MakeLines</a>(cand);
    return <a href="#TPrintTree:PrintAgain">PrintAgain</a>();
}

<b>//--------------------------------------------------------------------  </b>
TStringLong 
<a name="TPrintTree:PrintAgain"> </a><a href=".././TPrintTree.html#TPrintTree:PrintAgain">TPrintTree::PrintAgain</a>() const {
    TStringLong result;
    for (<a href="../ListOfTypes.html#int">int</a> l = 0; l &lt; <a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.GetSize(); ++l){
	TObjString *string = (TObjString *) <a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.At(l);
	result = result + string-&gt;GetString()  + TString("n");
    }
    result = result + TString("0");
    return result;
}

<b>//-------------</b>
<b>// Modifiers --</b>
<b>//-------------</b>
<a href="../ListOfTypes.html#void">void</a> 
<a name="TPrintTree:SetSeparator"> </a><a href=".././TPrintTree.html#TPrintTree:SetSeparator">TPrintTree::SetSeparator</a>(const <a href="../ListOfTypes.html#char">char</a> * div) {
    <a href=".././TPrintTree.html#TPrintTree:_separator">_separator</a> = div;
}

<b>//-----------------------------------------------------------</b>
<a href="../ListOfTypes.html#void">void</a> 
<a name="TPrintTree:SetLastMark"> </a><a href=".././TPrintTree.html#TPrintTree:SetLastMark">TPrintTree::SetLastMark</a>(const <a href="../ListOfTypes.html#char">char</a> * div) {
    <a href=".././TPrintTree.html#TPrintTree:_lastMark">_lastMark</a> = div;
}

<b>//-----------------------------------------------------------</b>
<a href="../ListOfTypes.html#void">void</a> 
<a name="TPrintTree:SetAligner"> </a><a href=".././TPrintTree.html#TPrintTree:SetAligner">TPrintTree::SetAligner</a>(const <a href="../ListOfTypes.html#char">char</a> * div) {
    <a href=".././TPrintTree.html#TPrintTree:_aligner">_aligner</a> = div;
}

<b>//-----------------------------------------------------------</b>
<a href="../ListOfTypes.html#void">void</a> 
<a name="TPrintTree:SetSpaceFiller"> </a><a href=".././TPrintTree.html#TPrintTree:SetSpaceFiller">TPrintTree::SetSpaceFiller</a>(<a href="../ListOfTypes.html#char">char</a> spa) {
    <a href=".././TPrintTree.html#TPrintTree:_spaceFiller">_spaceFiller</a> = spa;
}

<b>//-----------------------------------------------------------</b>
<a href="../ListOfTypes.html#void">void</a> 
<a name="TPrintTree:SetMissingInfo"> </a><a href=".././TPrintTree.html#TPrintTree:SetMissingInfo">TPrintTree::SetMissingInfo</a>(const <a href="../ListOfTypes.html#char">char</a> * info) {
    <a href=".././TPrintTree.html#TPrintTree:_missingInfo">_missingInfo</a> = info;
}

<b>//-------------------------------------------------------------</b>
<a href="../ListOfTypes.html#void">void</a> 
<a name="TPrintTree:AddTerminal"> </a><a href=".././TPrintTree.html#TPrintTree:AddTerminal">TPrintTree::AddTerminal</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> particle) {
    if (<a href=".././TPrintTree.html#TPrintTree:fTerm">fTerm</a>&lt;100) <a href=".././TPrintTree.html#TPrintTree:_terminals">_terminals</a>[<a href=".././TPrintTree.html#TPrintTree:fTerm">fTerm</a>++] = particle;
}

<a href="../ListOfTypes.html#void">void</a> 
<a name="TPrintTree:AddTerminal"> </a><a href=".././TPrintTree.html#TPrintTree:AddTerminal">TPrintTree::AddTerminal</a>(TString particles) {
<b>    // Don't print the daughters of terminal particles:</b>
    istrstream terminalsStream((<a href="../ListOfTypes.html#char">char</a>*)particles.Data());
    <a href="../ListOfTypes.html#char">char</a> terminal[128];
    while (terminalsStream &gt;&gt; terminal){
	const TParticlePDG * entry = TRho::Instance()-&gt;GetPDG()-&gt;GetParticle(terminal);
	if (entry != 0){
	    <a href="#TPrintTree:AddTerminal">AddTerminal</a>(entry-&gt;PdgCode());
	}
    }
}

<b>//-------------------------------------------------------------</b>
<a href="../ListOfTypes.html#void">void</a> 
<a name="TPrintTree:RemoveTerminal"> </a><a href=".././TPrintTree.html#TPrintTree:RemoveTerminal">TPrintTree::RemoveTerminal</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> particle) {
}


<b>//-----------</b>
<b>// Globals --</b>
<b>//-----------</b>

<b>//-------------------------------------------</b>
<b>//-- Protected Function Member Definitions --</b>
<b>//-------------------------------------------</b>

<a href="../ListOfTypes.html#void">void</a> 
<a name="TPrintTree:MakeLines"> </a><a href=".././TPrintTree.html#TPrintTree:MakeLines">TPrintTree::MakeLines</a>(const TCandidate &amp; cand) {
    <a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.Delete();  
    <a href=".././TPrintTree.html#TPrintTree:_daughtersLineNum">_daughtersLineNum</a> = 0;
    <a href="#TPrintTree:MakeLines">MakeLines</a>(cand, 0, kFALSE, kTRUE, 0);
}

<b>//-------------------------------------------------------------</b>
<a href="../ListOfTypes.html#void">void</a>
<a name="TPrintTree:MakeLines"> </a><a href=".././TPrintTree.html#TPrintTree:MakeLines">TPrintTree::MakeLines</a>(const TCandidate &amp; cand, <a href="../ListOfTypes.html#int">int</a> lineNumber,
			<a href="../ListOfTypes.html#Bool_t">Bool_t</a> firstDaughter, <a href="../ListOfTypes.html#Bool_t">Bool_t</a> lastDaughter,
			<a href="../ListOfTypes.html#int">int</a> numInitialSpaces) {
    
<b>    // See if the line number exists in <a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>. If not, new it:</b>
    TObjString *line = 0;
    if (<a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.GetSize() &gt; lineNumber){
	line = (TObjString*)<a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.At(lineNumber);
    }
    else{
	line = new TObjString();
    }
    
    TString stringLine = line-&gt;GetString();
    
<b>    // If cand is the first daughter, align it with is parent.</b>
<b>    // Otherwise, push it beyond the longest line below it:</b>
    if (kTRUE == firstDaughter){
<b>	// Regardless of <a href=".././TPrintTree.html#TPrintTree:_spaceFiller">_spaceFiller</a>, always use ' ' for first daughter:</b>
	<a href="../ListOfTypes.html#char">char</a> localSpaceFiller = ' ';
	
	stringLine = stringLine + <a href="#TPrintTree:SpaceFillerString">SpaceFillerString</a>(numInitialSpaces - stringLine.Length(), 
	    localSpaceFiller);
    }
    else {
<b>	// Use spaceFillers only of cand needs space for daughters in next line:</b>
	if (cand.NDaughters() &gt; 0){
	    <a href="../ListOfTypes.html#int">int</a> longestLineLength = 0;
	    for (<a href="../ListOfTypes.html#int">int</a> l = lineNumber; l &lt; <a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.GetSize(); ++l){
		if (longestLineLength &lt; (((TObjString*)<a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.At(l))-&gt;GetString()).Length()){
		    longestLineLength = (((TObjString*)<a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.At(l))-&gt;GetString()).Length();
		}
	    }
	    stringLine = stringLine + <a href="#TPrintTree:SpaceFillerString">SpaceFillerString</a>(longestLineLength - stringLine.Length(), 
		<a href=".././TPrintTree.html#TPrintTree:_spaceFiller">_spaceFiller</a>);
	}
    }
    
<b>    // If first daughter, indicate decay from parent using aligner:</b>
    if (kTRUE == firstDaughter){
	stringLine = stringLine + TString(<a href=".././TPrintTree.html#TPrintTree:_aligner">_aligner</a>);
    }
    
<b>    // numInitialSpaces for next recursive calls:</b>
    const <a href="../ListOfTypes.html#int">int</a> nextNumInitialSpaces = stringLine.Length();
    
<b>    // print the information of interest on the line:</b>
    TString funcOutput;
    if (funcOutput==""){
<b>	///		funcOutput += <a href=".././TPrintTree.html#TPrintTree:_missingInfo">_missingInfo</a>;</b>
	if(cand.PdtEntry()) {
	    funcOutput += cand.PdtEntry()-&gt;GetName();
	}
	else {
	    funcOutput += <a href=".././TPrintTree.html#TPrintTree:_missingInfo">_missingInfo</a>;
	}
    }
    
<b>    // Add separators:</b>
    if (kTRUE == lastDaughter) {
	stringLine = stringLine + funcOutput + TString(<a href=".././TPrintTree.html#TPrintTree:_lastMark">_lastMark</a>);
    }
    else {
	stringLine = stringLine + funcOutput + TString(<a href=".././TPrintTree.html#TPrintTree:_separator">_separator</a>);
    }
    
<b>    // If line is not in <a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a> yet, append it to the list:</b>
    if (<a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.GetSize() &lt;= lineNumber){
	<a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.Add(new TObjString(stringLine));
    }
    else
	line-&gt;SetString((<a href="../ListOfTypes.html#char">char</a>*)stringLine.Data());
    
<b>    // If cand is a terminal particle, ignore its daughters:</b>
    const TParticlePDG * candEntry = cand.PdtEntry();
    if (0 != candEntry){
	const <a href="../ListOfTypes.html#int">int</a> candType = candEntry-&gt;PdgCode();
	for (<a href="../ListOfTypes.html#int">int</a> t = 0; t &lt; <a href=".././TPrintTree.html#TPrintTree:fTerm">fTerm</a>; ++t){
	    if (<a href=".././TPrintTree.html#TPrintTree:_terminals">_terminals</a>[t] == candType){
		return;
	    }
	}
    }
    
<b>    // Otherwise, recursively call this function for daughters:</b>
    <a href="../ListOfTypes.html#Bool_t">Bool_t</a> nextFirstDaughter = kTRUE;
    <a href="../ListOfTypes.html#int">int</a> nextLineNumber = lineNumber + 1;
    TCandListIterator iter(cand.DaughterIterator());
    const TCandidate * daughter;
    
    <a href="../ListOfTypes.html#int">int</a> sisterNum = 0;
    
    if(cand.NDaughters()&gt;0) {
	while (daughter = iter.Next()){
	    <a href="../ListOfTypes.html#Bool_t">Bool_t</a> nextLastDaughter = kFALSE;
	    if (++sisterNum == cand.NDaughters()){
		nextLastDaughter = kTRUE;
	    }
	    
	    <a href="#TPrintTree:MakeLines">MakeLines</a>(*daughter, nextLineNumber, nextFirstDaughter, 
		nextLastDaughter, nextNumInitialSpaces);
	    nextFirstDaughter = kFALSE;
	}
    }
}

<b>//-----------------------------------------------------------</b>
<a href="../ListOfTypes.html#void">void</a> 
<a name="TPrintTree:MakeLines"> </a><a href=".././TPrintTree.html#TPrintTree:MakeLines">TPrintTree::MakeLines</a>(const VAbsTruth &amp; cand) {
    <a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.Delete();  
    <a href=".././TPrintTree.html#TPrintTree:_daughtersLineNum">_daughtersLineNum</a> = 0;
    <a href="#TPrintTree:MakeLines">MakeLines</a>(cand, 0, kFALSE, kTRUE, 0);
}

<b>//-------------------------------------------------------------</b>
<a href="../ListOfTypes.html#void">void</a>
<a name="TPrintTree:MakeLines"> </a><a href=".././TPrintTree.html#TPrintTree:MakeLines">TPrintTree::MakeLines</a>(const VAbsTruth &amp; cand, <a href="../ListOfTypes.html#int">int</a> lineNumber,
			<a href="../ListOfTypes.html#Bool_t">Bool_t</a> firstDaughter, <a href="../ListOfTypes.html#Bool_t">Bool_t</a> lastDaughter,
			<a href="../ListOfTypes.html#int">int</a> numInitialSpaces) {
    
<b>    // See if the line number exists in <a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>. If not, new it:</b>
    TObjString *line = 0;
    if (<a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.GetSize() &gt; lineNumber){
	line = (TObjString*)<a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.At(lineNumber);
    }
    else{
	line = new TObjString();
    }
    
    TString stringLine = line-&gt;GetString();
    
<b>    // If cand is the first daughter, align it with is parent.</b>
<b>    // Otherwise, push it beyond the longest line below it:</b>
    if (kTRUE == firstDaughter){
<b>	// Regardless of <a href=".././TPrintTree.html#TPrintTree:_spaceFiller">_spaceFiller</a>, always use ' ' for first daughter:</b>
	<a href="../ListOfTypes.html#char">char</a> localSpaceFiller = ' ';
	
	stringLine = stringLine + <a href="#TPrintTree:SpaceFillerString">SpaceFillerString</a>(numInitialSpaces - stringLine.Length(), 
	    localSpaceFiller);
    }
    else {
<b>	// Use spaceFillers only of cand needs space for daughters in next line:</b>
	if (cand.GetNumberOfDaughters() &gt; 0){
	    <a href="../ListOfTypes.html#int">int</a> longestLineLength = 0;
	    for (<a href="../ListOfTypes.html#int">int</a> l = lineNumber; l &lt; <a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.GetSize(); ++l){
		if (longestLineLength &lt; (((TObjString*)<a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.At(l))-&gt;GetString()).Length()){
		    longestLineLength = (((TObjString*)<a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.At(l))-&gt;GetString()).Length();
		}
	    }
	    stringLine = stringLine + <a href="#TPrintTree:SpaceFillerString">SpaceFillerString</a>(longestLineLength - stringLine.Length(), 
		<a href=".././TPrintTree.html#TPrintTree:_spaceFiller">_spaceFiller</a>);
	}
    }
    
<b>    // If first daughter, indicate decay from parent using aligner:</b>
    if (kTRUE == firstDaughter){
	stringLine = stringLine + TString(<a href=".././TPrintTree.html#TPrintTree:_aligner">_aligner</a>);
    }
    
<b>    // numInitialSpaces for next recursive calls:</b>
    const <a href="../ListOfTypes.html#int">int</a> nextNumInitialSpaces = stringLine.Length();
    
<b>    // print the information of interest on the line:</b>
    TString funcOutput;
    if (funcOutput==""){
<b>	///		funcOutput += <a href=".././TPrintTree.html#TPrintTree:_missingInfo">_missingInfo</a>;</b>
	if(cand.GetPdtEntry()) {
	    funcOutput += cand.GetPdtEntry()-&gt;GetName();
	}
	else {
	    funcOutput += <a href=".././TPrintTree.html#TPrintTree:_missingInfo">_missingInfo</a>;
	}
    }
    
<b>    // Add separators:</b>
    if (kTRUE == lastDaughter) {
	stringLine = stringLine + funcOutput + TString(<a href=".././TPrintTree.html#TPrintTree:_lastMark">_lastMark</a>);
    }
    else {
	stringLine = stringLine + funcOutput + TString(<a href=".././TPrintTree.html#TPrintTree:_separator">_separator</a>);
    }
    
<b>    // If line is not in <a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a> yet, append it to the list:</b>
    if (<a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.GetSize() &lt;= lineNumber){
	<a href=".././TPrintTree.html#TPrintTree:_lines">_lines</a>.Add(new TObjString(stringLine));
    }
    else
	line-&gt;SetString((<a href="../ListOfTypes.html#char">char</a>*)stringLine.Data());
    
<b>    // If cand is a terminal particle, ignore its daughters:</b>
    const TParticlePDG * candEntry = cand.GetPdtEntry();
    if (0 != candEntry){
	const <a href="../ListOfTypes.html#int">int</a> candType = candEntry-&gt;PdgCode();
	for (<a href="../ListOfTypes.html#int">int</a> t = 0; t &lt; <a href=".././TPrintTree.html#TPrintTree:fTerm">fTerm</a>; ++t){
	    if (<a href=".././TPrintTree.html#TPrintTree:_terminals">_terminals</a>[t] == candType){
		return;
	    }
	}
    }
    
<b>    // Otherwise, recursively call this function for daughters:</b>
    <a href="../ListOfTypes.html#Bool_t">Bool_t</a> nextFirstDaughter = kTRUE;
    <a href="../ListOfTypes.html#int">int</a> nextLineNumber = lineNumber + 1;
    
    <a href="../ListOfTypes.html#int">int</a> sisterNum = 0;
    
    if(cand.GetNumberOfDaughters()&gt;0) {
	for (<a href="../ListOfTypes.html#int">int</a> i=0;i&lt;cand.GetNumberOfDaughters();i++) {
	    const VAbsTruth* daughter = cand.GetDaughter(i);
	    <a href="../ListOfTypes.html#Bool_t">Bool_t</a> nextLastDaughter = kFALSE;
	    if (++sisterNum == cand.GetNumberOfDaughters()){
		nextLastDaughter = kTRUE;
	    }
	    
	    <a href="#TPrintTree:MakeLines">MakeLines</a>(*daughter, nextLineNumber, nextFirstDaughter, 
		nextLastDaughter, nextNumInitialSpaces);
	    nextFirstDaughter = kFALSE;
	}
    }
}

<b>//-----------------------------------------------------------</b>
TString 
<a name="TPrintTree:SpaceFillerString"> </a><a href=".././TPrintTree.html#TPrintTree:SpaceFillerString">TPrintTree::SpaceFillerString</a>(<a href="../ListOfTypes.html#int">int</a> length, <a href="../ListOfTypes.html#char">char</a> spaceFiller) {
    TString result;
    if (length &lt;= 0){
	return result;
    }
    else {
	<a href="../ListOfTypes.html#char">char</a> * spaces = new <a href="../ListOfTypes.html#char">char</a>[length + 1];  
	for (<a href="../ListOfTypes.html#int">int</a> s = 0; s &lt; length; ++s){
	    spaces[s] = spaceFiller;
	}
	spaces[length] = '0';
	result += spaces;
	delete[] spaces;
	return result;
    }
}

<b>//-----------------------------------------</b>
<b>//-- Private Function Member Definitions --</b>
<b>//-----------------------------------------</b>
<b>// Do work common to different constructors:</b>
<a href="../ListOfTypes.html#void">void</a> 
<a name="TPrintTree:Initialize"> </a><a href=".././TPrintTree.html#TPrintTree:Initialize">TPrintTree::Initialize</a>() {
    <a href=".././TPrintTree.html#TPrintTree:_aligner">_aligner</a> = "|_ ";
    <a href=".././TPrintTree.html#TPrintTree:_separator">_separator</a> = " ";
    <a href=".././TPrintTree.html#TPrintTree:_lastMark">_lastMark</a> = " ";
    <a href=".././TPrintTree.html#TPrintTree:_spaceFiller">_spaceFiller</a> = '-';
    <a href=".././TPrintTree.html#TPrintTree:_missingInfo">_missingInfo</a> = "NoInfo";
    <a href=".././TPrintTree.html#TPrintTree:_daughtersLineNum">_daughtersLineNum</a> = 0;
}

<b>//-----------------------------------</b>
<b>//-- Internal Function Definitions --</b>
<b>//-----------------------------------</b>
</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
