<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec 20 16:03:26 2002            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TSGNG - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
<b>//////////////////////////////////////////////////////////////////////////</b>
<b>//									//</b>
<b>// <a href=".././TSGNG.html">TSGNG</a>								//</b>
<b>//									//</b>
<b>// Implementation of the SUPERVISED-GROWING-NEURAL-GAS (SGNG)		//</b>
<b>// Part of the Neural Network Objects package (NNO)			//</b>
<b>//									//</b>
<b>// Author List:								//</b>
<b>// Johannes Steffens, Bochum University					//</b>
<b>// M.Kunze, Bochum University						//</b>
<b>// (C) Copyright Johannes Steffens 1995, Ruhr-University Bochum.	//</b>
<b>//									//</b>
<b>//////////////////////////////////////////////////////////////////////////</b>

#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;float.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;
#include "RhoNNO/TSGNG.h"
#include "RhoNNO/VNeuralNetPlotter.h"

ClassImp(TSGNG)

<a name="TSGNG:TSGNG"> </a>TSGNG::TSGNG(Int_t innodes,
	     Int_t outnodes,
	     Int_t maxCells,
	     Double_t winStep,
	     Double_t neiStep,
	     Double_t neuStep,
	     Double_t aErrCount,
	     Double_t aEdgeCount,
	     Double_t bSDev,
	     Double_t minCount,
	     Int_t  connectors,
	     Long_t insertStep,
	     Long_t deleteStep,
	     const char* netFile)
	     : VSupervisedNet("SGNG",innodes,outnodes,netFile) 
{
    fXB.fWinStep     = winStep;
    fXB.fNeiStep     = neiStep;
    fXB.fNeuStep     = neuStep;
    fXB.fErrCount    = aErrCount;
    fXB.fEdgeCount   = aEdgeCount;
    fXB.fNeiCount    = bSDev;
    fXB.fMinCount    = minCount;
    fXB.fCells	     = 2;
    fXB.fMaxCells    = maxCells;
    fXB.fConnectors  = connectors;
    fXB.fInsertStep  = insertStep;
    fXB.fDeleteStep  = deleteStep;
    fXB.fInsertCount = 0;
    fXB.fDeleteCount = 0;
    
    fXB.fMainEdgeCount	= 1;
    fXB.fMainErrCount	= 1;
    
    fU = 0;
    AllocNet();
    InitNet();
}

<b>// copy constructor</b>
<a name="TSGNG:TSGNG"> </a><a href=".././TSGNG.html#TSGNG:TSGNG">TSGNG::TSGNG</a>(const <a href=".././TSGNG.html">TSGNG</a>&amp; sgng,const <a href="../ListOfTypes.html#char">char</a>* netFile)
: <a href=".././VSupervisedNet.html">VSupervisedNet</a>("SGNG",sgng.<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes,sgng.<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes,netFile) 
{
    <a href=".././TSGNG.html#TSGNG:fXB">fXB</a> = sgng.<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>;
    <a href=".././TSGNG.html#TSGNG:fU">fU</a>  = 0;
    <a href="#TSGNG:AllocNet">AllocNet</a>();
    <a href="#TSGNG:InitNet">InitNet</a>();
    <a href="#TSGNG:CopyData">CopyData</a>(sgng);
}

<a name="TSGNG:~TSGNG"> </a><a href=".././TSGNG.html">TSGNG</a>::~<a href=".././TSGNG.html">TSGNG</a>() 
{
<b>    //transform main_err_count, main_edge_count</b>
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    for(up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up) {
	up-&gt;fCount*=<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainErrCount;
	for (I=0;I&lt;up-&gt;fNc;++I) up-&gt;fAge[I]*=<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainEdgeCount;
    }
    <a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainErrCount=1;
    <a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainEdgeCount=1;
    if (<a href=".././VNeuralNet.html#VNeuralNet:fFilename">fFilename</a>!="") if (<a href=".././VNeuralNet.html#VNeuralNet:fShouldSave">fShouldSave</a>) Save();
    if (<a href=".././TSGNG.html#TSGNG:fU">fU</a>!=0) {
	<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up = <a href=".././TSGNG.html#TSGNG:fU">fU</a>;
	<a href="../ListOfTypes.html#Int_t">Int_t</a> I;
	for (I=0;I&lt;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMaxCells;++I) {
	    delete[] up-&gt;fVector;
	    delete[] up-&gt;fWeight;
	    delete[] up-&gt;fDiff;
	    delete[] up-&gt;fC;
	    delete[] up-&gt;fAge;
	    ++up;
	}
	delete[] <a href=".././TSGNG.html#TSGNG:fU">fU</a>;
    }
}

<a name="TSGNG:ReadBinary"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TSGNG.html#TSGNG:ReadBinary">TSGNG::ReadBinary</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././TSGNG.html#TSGNG:fU">fU</a> = 0;
    fread(&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>,sizeof(<a href=".././TNeuralNetCellParameters.html">TNeuralNetCellParameters</a>),1,<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>);
    <a href="#TSGNG:AllocNet">AllocNet</a>();
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    for(up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up) {
	<a href=".././TNeuralNetCell.html#TNeuralNetCell:ReadUnitBinary">TNeuralNetCell::ReadUnitBinary</a>(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
	fread(up-&gt;fAge,sizeof(<a href="../ListOfTypes.html#Double_t">Double_t</a>),up-&gt;fNc,<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>);
	fread(up-&gt;fWeight,sizeof(<a href="../ListOfTypes.html#Double_t">Double_t</a>),<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes,<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>);
	for (I=0;I&lt;up-&gt;fNc;++I) up-&gt;fC[I].fPtr = &amp;<a href=".././TSGNG.html#TSGNG:fU">fU</a>[up-&gt;fC[I].fID];
    }
}

<a name="TSGNG:ReadText"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TSGNG.html#TSGNG:ReadText">TSGNG::ReadText</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././TSGNG.html#TSGNG:fU">fU</a> = 0;
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"win_step     %len",&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fWinStep);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nei_step     %len",&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fNeiStep);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"neu_step     %len",&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fNeuStep);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"a_err_count  %len",&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fErrCount);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"a_edge_count %len",&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fEdgeCount);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"b_s_dev      %len",&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fNeiCount);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"min_count    %len",&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMinCount);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"cells        %in",&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fCells);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"max_cells    %in",&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMaxCells);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"connectors   %in",&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fConnectors);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"insert_step  %lin",&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fInsertStep);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"delete_step  %lin",&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fDeleteStep);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"ins_count    %lin",&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fInsertCount);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"del_count    %lin",&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fDeleteCount);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"n");
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"main_err_count  %len",&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainErrCount);
    fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"main_edge_count %len",&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainEdgeCount);
    
    <a href="#TSGNG:AllocNet">AllocNet</a>();
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    for(up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up) {
	<a href=".././TNeuralNetCell.html#TNeuralNetCell:ReadUnitText">TNeuralNetCell::ReadUnitText</a>(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
	fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nedge count ");
	for (I=0;I&lt;up-&gt;fNc;++I) fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"%le ",&amp;up-&gt;fAge[I]);
	fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nweights ");
	for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes;++I) fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"%le ",&amp;up-&gt;fWeight[I]);
	fscanf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"n");
	for (I=0;I&lt;up-&gt;fNc;++I) up-&gt;fC[I].fPtr=&amp;<a href=".././TSGNG.html#TSGNG:fU">fU</a>[up-&gt;fC[I].fID];
    }
}

<a name="TSGNG:WriteBinary"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TSGNG.html#TSGNG:WriteBinary">TSGNG::WriteBinary</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    fwrite(&amp;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>,sizeof(<a href=".././TNeuralNetCellParameters.html">TNeuralNetCellParameters</a>),1,<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>);
    for(up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up) {
	<a href=".././TNeuralNetCell.html#TNeuralNetCell:WriteUnitBinary">TNeuralNetCell::WriteUnitBinary</a>(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
	fwrite(up-&gt;fAge,sizeof(<a href="../ListOfTypes.html#Double_t">Double_t</a>),up-&gt;fNc,<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>);
	fwrite(up-&gt;fWeight,sizeof(<a href="../ListOfTypes.html#Double_t">Double_t</a>),<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes,<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>);
    }
}

<a name="TSGNG:WriteText"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TSGNG.html#TSGNG:WriteText">TSGNG::WriteText</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"win_step     %len",<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fWinStep);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nei_step     %len",<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fNeiStep);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"neu_step     %len",<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fNeuStep);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"a_err_count  %len",<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fErrCount);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"a_edge_count %len",<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fEdgeCount);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"b_s_dev      %len",<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fNeiCount);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"min_count    %len",<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMinCount);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"cells        %in",<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fCells);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"max_cells    %in",<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMaxCells);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"connectors   %in",<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fConnectors);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"insert_step  %lin",<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fInsertStep);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"delete_step  %lin",<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fDeleteStep);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"ins_count    %lin",<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fInsertCount);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"del_count    %lin",<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fDeleteCount);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"n");
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"main_err_count  %len",<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainErrCount);
    fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"main_edge_count %len",<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainEdgeCount);
    
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    for(up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up) {
	<a href=".././TNeuralNetCell.html#TNeuralNetCell:WriteUnitText">TNeuralNetCell::WriteUnitText</a>(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
	fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nedge count ");
	for (I=0;I&lt;up-&gt;fNc;++I) fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"%le ",up-&gt;fAge[I]);
	fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"nweights ");
	for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes;++I) fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"%le ",up-&gt;fWeight[I]);
	fprintf(<a href=".././VNeuralNet.html#VNeuralNet:fFile">fFile</a>,"n");
    }
}

<a name="TSGNG:AllocNet"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TSGNG.html#TSGNG:AllocNet">TSGNG::AllocNet</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    <a href=".././TSGNG.html#TSGNG:fU">fU</a> = new <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>[<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMaxCells];  TestPointer(<a href=".././TSGNG.html#TSGNG:fU">fU</a>);
    <a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a> = &amp;<a href=".././TSGNG.html#TSGNG:fU">fU</a>[<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fCells];
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up = <a href=".././TSGNG.html#TSGNG:fU">fU</a>;
    for (I=0;I&lt;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMaxCells;++I) {
	up-&gt;fVector = new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes];    TestPointer(up-&gt;fVector);
	up-&gt;fWeight = new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes];    TestPointer(up-&gt;fWeight);
	up-&gt;fDiff   = new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes];    TestPointer(up-&gt;fDiff);
	up-&gt;fC	    = new connector[<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fConnectors]; TestPointer(up-&gt;fC);
	up-&gt;fAge    = new <a href="../ListOfTypes.html#Double_t">Double_t</a>[<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fConnectors];    TestPointer(up-&gt;fAge);
	up-&gt;fNc     = 0;
	up-&gt;fChi2   = 0;
	up-&gt;fCount  = 0;
	up-&gt;<a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a>    = 0;
	up-&gt;fID     = I;
	++up;
    }
}

<a name="TSGNG:InitNet"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TSGNG.html#TSGNG:InitNet">TSGNG::InitNet</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
    for(up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up) {
	for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++J) up-&gt;fVector[J]=Random();
	for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes;++J) up-&gt;fWeight[J]=Random();
	up-&gt;fNc=0;
    }
    <a href="#TSGNG:Connect">Connect</a>(&amp;<a href=".././TSGNG.html#TSGNG:fU">fU</a>[0],&amp;<a href=".././TSGNG.html#TSGNG:fU">fU</a>[1]);
    for(up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up) {
	<a href="../ListOfTypes.html#Double_t">Double_t</a> s_dist;
	up-&gt;fChi2 = 0;
	for (J=0;J&lt;up-&gt;fNc;++J) {
	    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* unei = (<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up-&gt;fC[J].fPtr;
	    s_dist = 0;
	    for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++I) {<a href="../ListOfTypes.html#Double_t">Double_t</a> diff=up-&gt;fVector[I]-unei-&gt;fVector[I]; s_dist+=diff*diff;}
	    up-&gt;fChi2 += s_dist;
	}
	up-&gt;fChi2 /= up-&gt;fNc;
    }
}

<a name="TSGNG:CopyData"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TSGNG.html#TSGNG:CopyData">TSGNG::CopyData</a>(const <a href=".././TSGNG.html">TSGNG</a>&amp; sgng) 
{
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* thisup = <a href=".././TSGNG.html#TSGNG:fU">fU</a>;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* fromup = sgng.<a href=".././TSGNG.html#TSGNG:fU">fU</a>;
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
    
<b>    //check integrity</b>
    if (<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes    !=sgng.<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes)     Errorf("cannot copy data; innodes not identical");
    if (<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes   !=sgng.<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes)    Errorf("cannot copy data; outnodes not identical");
    if (<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fConnectors!=sgng.<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fConnectors) Errorf("cannot copy data; max connectors not identical");
    if (<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMaxCells  !=sgng.<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMaxCells )  Errorf("cannot copy data; max_cells not identical");
    
    <a href=".././TSGNG.html#TSGNG:fXB">fXB</a>=sgng.<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>;
    <a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>=&amp;<a href=".././TSGNG.html#TSGNG:fU">fU</a>[<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fCells];
    for (I=0;I&lt;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fCells;++I) {
	memcpy(thisup-&gt;fVector,fromup-&gt;fVector,sizeof(<a href="../ListOfTypes.html#Double_t">Double_t</a>)*<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes);
	memcpy(thisup-&gt;fWeight,fromup-&gt;fWeight,sizeof(<a href="../ListOfTypes.html#Double_t">Double_t</a>)*<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes);
	thisup-&gt;fNc=fromup-&gt;fNc;
	for (J=0;J&lt;thisup-&gt;fNc;++J) {
            thisup-&gt;fC[J].fPtr = &amp;<a href=".././TSGNG.html#TSGNG:fU">fU</a>[((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)(fromup-&gt;fC[J].fPtr))-&gt;fID];
            thisup-&gt;fAge[J] = fromup-&gt;fAge[J];
	}
	thisup-&gt;fCount = fromup-&gt;fCount;
	++thisup;
	++fromup;
    }
}

<b>//Disconnect only if both TNeuralNetCells have more than one connectors</b>
<a name="TSGNG:CondDisconnect"> </a><a href="../ListOfTypes.html#Int_t">Int_t</a>  <a href=".././TSGNG.html#TSGNG:CondDisconnect">TSGNG::CondDisconnect</a>(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up1,<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up2) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    if ((up1-&gt;fNc==1) || (up2-&gt;fNc==1)) return 0;
    for (I=0;I&lt;up1-&gt;fNc;++I) if ((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up1-&gt;fC[I].fPtr==up2) break;
    if (I&lt;up1-&gt;fNc) up1-&gt;fC[I]=up1-&gt;fC[--up1-&gt;fNc]; else return 0;
    for (I=0;I&lt;up2-&gt;fNc;++I) if ((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up2-&gt;fC[I].fPtr==up1) break;
    if (I&lt;up2-&gt;fNc) up2-&gt;fC[I]=up2-&gt;fC[--up2-&gt;fNc];
    return 1;
}

<a name="TSGNG:Connect"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TSGNG.html#TSGNG:Connect">TSGNG::Connect</a>(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up1,<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up2) 
{
    if ((up1-&gt;fNc==<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fConnectors)||(up2-&gt;fNc==<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fConnectors)) return;
    up1-&gt;fAge[up1-&gt;fNc]=1.0/<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainEdgeCount;
    up1-&gt;fC[up1-&gt;fNc++].fPtr=up2;
    up2-&gt;fAge[up2-&gt;fNc]=1.0/<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainEdgeCount;
    up2-&gt;fC[up2-&gt;fNc++].fPtr=up1;
}

<a name="TSGNG:UpdateConnector"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TSGNG.html#TSGNG:UpdateConnector">TSGNG::UpdateConnector</a>(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up1,<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up2) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
    for (I=0;I&lt;up1-&gt;fNc;++I) if ((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up1-&gt;fC[I].fPtr==up2) break;
    if (I==up1-&gt;fNc) { <a href="#TSGNG:Connect">Connect</a>(up1,up2); return; }
    up1-&gt;fAge[I]+=<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fEdgeCount;
    for (J=0;J&lt;up2-&gt;fNc;++J) if ((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up2-&gt;fC[J].fPtr==up1) break;
    up2-&gt;fAge[J]=up1-&gt;fAge[I];
}

<a name="TSGNG:Recall"> </a><a href="../ListOfTypes.html#Double_t">Double_t</a>* <a href=".././TSGNG.html#TSGNG:Recall">TSGNG::Recall</a>(<a href="../ListOfTypes.html#NNO_INTYPE">NNO_INTYPE</a>* in,<a href="../ListOfTypes.html#NNO_OUTTYPE">NNO_OUTTYPE</a>* out) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> s_dist;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> sum_out = 0;
    <a href=".././TSGNG.html#TSGNG:fMinDistSquare1">fMinDistSquare1</a> = DBL_MAX;
    <a href=".././TSGNG.html#TSGNG:fMinDistSquare2">fMinDistSquare2</a> = DBL_MAX;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    
    for(up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up){
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* v = up-&gt;fVector;
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* d = up-&gt;fDiff;
	<a href="../ListOfTypes.html#NNO_INTYPE">NNO_INTYPE</a>* i = in;
	s_dist = 0;
	for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++I) { *d =*i++ - *v++; s_dist+=*d * *d; ++d; }
	up-&gt;<a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a> = exp(-s_dist/up-&gt;fChi2);
	sum_out += up-&gt;<a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a>;
	if (s_dist&lt;<a href=".././TSGNG.html#TSGNG:fMinDistSquare1">fMinDistSquare1</a>) { 
	    <a href=".././TSGNG.html#TSGNG:fMinDistSquare2">fMinDistSquare2</a> = <a href=".././TSGNG.html#TSGNG:fMinDistSquare1">fMinDistSquare1</a>; 
	    <a href=".././TSGNG.html#TSGNG:fUwin2">fUwin2</a>=<a href=".././TSGNG.html#TSGNG:fUwin1">fUwin1</a>; 
	    <a href=".././TSGNG.html#TSGNG:fMinDistSquare1">fMinDistSquare1</a>=s_dist; 
	    <a href=".././TSGNG.html#TSGNG:fUwin1">fUwin1</a>=up; 
	}
	else if (s_dist&lt;<a href=".././TSGNG.html#TSGNG:fMinDistSquare2">fMinDistSquare2</a>) { 
	    <a href=".././TSGNG.html#TSGNG:fMinDistSquare2">fMinDistSquare2</a> = s_dist; 
	    <a href=".././TSGNG.html#TSGNG:fUwin2">fUwin2</a>=up; 
	}
    }

    for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes;++J) <a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a>[J] = 0;

    if (sum_out&gt;0) {
	for(up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up) {
	    up-&gt;<a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a> /= sum_out;
	    for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes;++J) 
		<a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a>[J] += up-&gt;<a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a> * up-&gt;fWeight[J];
	}
    }

    if (<a href=".././VNeuralNet.html#VNeuralNet:fPlotter">fPlotter</a>) {
	<a href="../ListOfTypes.html#Bool_t">Bool_t</a> good = kTRUE;
	if (out!=0) good = out[0]&gt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fThreshold;
	<a href=".././VNeuralNet.html#VNeuralNet:fPlotter">fPlotter</a>-&gt;<a href=".././VNeuralNetPlotter.html#VNeuralNetPlotter:AddTestSample">AddTestSample</a>(<a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a>[0],good);
    }

    return <a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a>;
}


<a name="TSGNG:Train"> </a><a href="../ListOfTypes.html#Double_t">Double_t</a> <a href=".././TSGNG.html#TSGNG:Train">TSGNG::Train</a>(<a href="../ListOfTypes.html#NNO_INTYPE">NNO_INTYPE</a>* in,<a href="../ListOfTypes.html#NNO_OUTTYPE">NNO_OUTTYPE</a>* out) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> S_Err;

    <a href="../ListOfTypes.html#Double_t">Double_t</a> s_dist;
    <a href="../ListOfTypes.html#Double_t">Double_t</a> sum_out = 0;
    <a href=".././TSGNG.html#TSGNG:fMinDistSquare1">fMinDistSquare1</a> = DBL_MAX;
    <a href=".././TSGNG.html#TSGNG:fMinDistSquare2">fMinDistSquare2</a> = DBL_MAX;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;

<b>    // Recall</b>
    for(up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up){
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* v = up-&gt;fVector;
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* d = up-&gt;fDiff;
	<a href="../ListOfTypes.html#NNO_INTYPE">NNO_INTYPE</a>* i = in;
	s_dist = 0;
	for (I=0;I&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++I) { *d =*i++ - *v++; s_dist+=*d * *d; ++d; }
	up-&gt;<a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a> = exp(-s_dist/up-&gt;fChi2);
	sum_out += up-&gt;<a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a>;
	if (s_dist&lt;<a href=".././TSGNG.html#TSGNG:fMinDistSquare1">fMinDistSquare1</a>) { 
	    <a href=".././TSGNG.html#TSGNG:fMinDistSquare2">fMinDistSquare2</a> = <a href=".././TSGNG.html#TSGNG:fMinDistSquare1">fMinDistSquare1</a>; 
	    <a href=".././TSGNG.html#TSGNG:fUwin2">fUwin2</a>=<a href=".././TSGNG.html#TSGNG:fUwin1">fUwin1</a>; 
	    <a href=".././TSGNG.html#TSGNG:fMinDistSquare1">fMinDistSquare1</a>=s_dist; 
	    <a href=".././TSGNG.html#TSGNG:fUwin1">fUwin1</a>=up; 
	}
	else if (s_dist&lt;<a href=".././TSGNG.html#TSGNG:fMinDistSquare2">fMinDistSquare2</a>) { 
	    <a href=".././TSGNG.html#TSGNG:fMinDistSquare2">fMinDistSquare2</a> = s_dist; 
	    <a href=".././TSGNG.html#TSGNG:fUwin2">fUwin2</a>=up; 
	}
    }

    for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes;++J) <a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a>[J] = 0;

    if (sum_out&gt;0) {
	for(up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up) {
	    up-&gt;<a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a> /= sum_out;
	    for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes;++J) 
		<a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a>[J] += up-&gt;<a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a> * up-&gt;fWeight[J];
	}
    }

<b>    // Weights update</b>
    <a href="#TSGNG:UpdateConnector">UpdateConnector</a>(<a href=".././TSGNG.html#TSGNG:fUwin1">fUwin1</a>,<a href=".././TSGNG.html#TSGNG:fUwin2">fUwin2</a>); //update edge_count of connector; if <a href=".././TSGNG.html#TSGNG:fUwin1">fUwin1</a>,<a href=".././TSGNG.html#TSGNG:fUwin2">fUwin2</a> are not connected, connect them
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* unei;
    <a href="../ListOfTypes.html#Double_t">Double_t</a>* vwin = <a href=".././TSGNG.html#TSGNG:fUwin1">fUwin1</a>-&gt;fVector;
    <a href="../ListOfTypes.html#Double_t">Double_t</a>* dwin = <a href=".././TSGNG.html#TSGNG:fUwin1">fUwin1</a>-&gt;fDiff;
    for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++J) *vwin++ += *dwin++ * <a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fWinStep;
    <a href=".././TSGNG.html#TSGNG:fUwin1">fUwin1</a>-&gt;fChi2 = 0;
    for (I=0;I&lt;<a href=".././TSGNG.html#TSGNG:fUwin1">fUwin1</a>-&gt;fNc;++I) {
	unei = (<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)<a href=".././TSGNG.html#TSGNG:fUwin1">fUwin1</a>-&gt;fC[I].fPtr;
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* v = unei-&gt;fVector;
	<a href="../ListOfTypes.html#Double_t">Double_t</a>* d = unei-&gt;fDiff;
	<a href="../ListOfTypes.html#Double_t">Double_t</a> s_dist = 0.0;
	<a href="../ListOfTypes.html#Double_t">Double_t</a> diff;
	vwin = <a href=".././TSGNG.html#TSGNG:fUwin1">fUwin1</a>-&gt;fVector;
	for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fInNodes;++J) {*v += *d++ * <a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fNeiStep; diff=*vwin++ - *v++; s_dist+=diff*diff;}
	<a href=".././TSGNG.html#TSGNG:fUwin1">fUwin1</a>-&gt;fChi2 += s_dist;
	unei-&gt;fChi2 += (s_dist-unei-&gt;fChi2)*<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fNeiCount;
    }

    <a href=".././TSGNG.html#TSGNG:fUwin1">fUwin1</a>-&gt;fChi2 /= <a href=".././TSGNG.html#TSGNG:fUwin1">fUwin1</a>-&gt;fNc;
    
    S_Err=0;
    for (J=0;J&lt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fOutNodes;++J) {
	<a href="../ListOfTypes.html#Double_t">Double_t</a> diff = out[J] - <a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a>[J];
	S_Err+=diff*diff;
	for(up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up) up-&gt;fWeight[J] += diff * up-&gt;<a href=".././VNeuralNet.html#VNeuralNet:fOut">fOut</a> * <a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fNeuStep;
    }

    <a href=".././TSGNG.html#TSGNG:fUwin1">fUwin1</a>-&gt;fCount += S_Err;
    <a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainErrCount *=(1.0-<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fErrCount);
    <a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainEdgeCount*=(1.0-<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fEdgeCount);

    if (<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fInsertStep&gt;0) 
	if (<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fInsertCount++==<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fInsertStep) {
	    <a href="#TSGNG:Insert">Insert</a>(); 
	    <a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fInsertCount=0;
	}

    if (<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fDeleteStep&gt;0) 
	if (<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fDeleteCount++==<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fDeleteStep) {
	    <a href="#TSGNG:Prune">Prune</a>(); 
	    <a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fDeleteCount=0;
	}

    <a href=".././VNeuralNet.html#VNeuralNet:fShouldSave">fShouldSave</a> = kTRUE;

    if (<a href=".././VNeuralNet.html#VNeuralNet:fPlotter">fPlotter</a>) <a href=".././VNeuralNet.html#VNeuralNet:fPlotter">fPlotter</a>-&gt;<a href=".././VNeuralNetPlotter.html#VNeuralNetPlotter:AddTrainSample">AddTrainSample</a>(out[0],out[0]&gt;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>.fThreshold);

    return S_Err;
}

<a name="TSGNG:Insert"> </a><a href="../ListOfTypes.html#Int_t">Int_t</a> <a href=".././TSGNG.html#TSGNG:Insert">TSGNG::Insert</a>(<a href="../ListOfTypes.html#void">void</a>) 
{
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I,J;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* umax1;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* umax2;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* unew;
    if (<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fCells==<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMaxCells) return 0; //break if there are no cells availiable
    
<b>    //find cell with highest err_count</b>
    <a href="../ListOfTypes.html#Double_t">Double_t</a> err_count = -1;
    for(up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up) if (up-&gt;fCount&gt;err_count) {err_count=up-&gt;fCount; umax1=up;}
    
<b>    //create new cell</b>
    unew = <a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>++;
    ++<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fCells;
    unew-&gt;fNc = 0;
    
    if (umax1-&gt;fNc==0) { Warningf(stdout,"CORRUPT NETWORK INTEGRITY! isolated cell found, please call developer"); return 0; }
    
<b>    //find neighbour with highest err_count</b>
    err_count=-1;
    for (I=0;I&lt;umax1-&gt;fNc;++I) if (((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax1-&gt;fC[I].fPtr)-&gt;fCount&gt;err_count) { err_count=((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax1-&gt;fC[I].fPtr)-&gt;fCount; umax2=(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax1-&gt;fC[I].fPtr; }
    
<b>    //connect new cell with common neighbours of umax1 and umax2</b>
    for (I=0;I&lt;umax1-&gt;fNc;++I) 
      for (J=0;J&lt;umax2-&gt;fNc;++J)
	if (umax1-&gt;fC[I].fPtr==umax2-&gt;fC[J].fPtr) 
	    <a href="#TSGNG:Connect">Connect</a>((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax1-&gt;fC[I].fPtr,unew);
	
    <a href="#TSGNG:Connect">Connect</a>(unew,umax1);     //connect umax1 and unew
    <a href="#TSGNG:Connect">Connect</a>(unew,umax2);     //connect umax2 and unew
    <a href=".././TNeuralNetCell.html#TNeuralNetCell:Disconnect">TNeuralNetCell::Disconnect</a>((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax1,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax2);  //disconnect umax1 and umax2
    
    <a href=".././TNeuralNetCell.html#TNeuralNetCell:InitVector">TNeuralNetCell::InitVector</a>((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)unew,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax1,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)umax2,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
    <a href=".././TNeuralNetCell.html#TNeuralNetCell:InitCount">TNeuralNetCell::InitCount</a> ((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)unew);
    <a href=".././TNeuralNetCell.html#TNeuralNetCell:InitWgt">TNeuralNetCell::InitWgt</a>   ((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)unew,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
    <a href=".././TNeuralNetCell.html#TNeuralNetCell:GetSDev">TNeuralNetCell::GetSDev</a>   ((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)unew,&amp;<a href=".././VNeuralNet.html#VNeuralNet:fParm">fParm</a>);
    
<b>    //transfom main_err_count, main_edge_count</b>
    for (up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up) {
	up-&gt;fCount*=<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainErrCount;
	for (I=0;I&lt;up-&gt;fNc;++I) up-&gt;fAge[I] *= <a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainEdgeCount;
    }
    <a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainErrCount=1;
    <a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainEdgeCount=1;
    
    for(up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up) <a href=".././TNeuralNetCell.html#TNeuralNetCell:CheckConnections">TNeuralNetCell::CheckConnections</a>((<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up);
    
    return 1;  //insertion was successful
}

<a name="TSGNG:Prune"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././TSGNG.html#TSGNG:Prune">TSGNG::Prune</a>(<a href="../ListOfTypes.html#void">void</a>) 
{ // remove edges
    <a href="../ListOfTypes.html#Int_t">Int_t</a> I;
    <a href=".././TNeuralNetCell.html">TNeuralNetCell</a>* up;
    
<b>    //transfom main_err_count, main_edge_count</b>
    for(up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up) {
	up-&gt;fCount*=<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainErrCount;
	for (I=0;I&lt;up-&gt;fNc;++I) up-&gt;fAge[I] *= <a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainEdgeCount;
    }
    <a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainErrCount  = 1;
    <a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMainEdgeCount = 1;
    
<b>    //remove all edges with edge_count&lt;min_count</b>
    for(up=<a href=".././TSGNG.html#TSGNG:fU">fU</a>;up&lt;<a href=".././TSGNG.html#TSGNG:fUbound">fUbound</a>;++up) {
	I=0;
	while (I&lt;up-&gt;fNc) {
	    if (up-&gt;fAge[I]&lt;<a href=".././TSGNG.html#TSGNG:fXB">fXB</a>.fMinCount) {
		if (!<a href="#TSGNG:CondDisconnect">CondDisconnect</a>(up,(<a href=".././TNeuralNetCell.html">TNeuralNetCell</a>*)up-&gt;fC[I].fPtr)) ++I;
	    } else ++I;
	}
    }
}

</pre>

<!--SIGNATURE-->
<br>
<hr>
<center>
<address>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</address>
</center>
<hr>
<address>
This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
